<!--

OS13k is a tiny pseudo operating system designed for a JS13k community project. It has native support for Shadertoys, Dweets, ZzFX, trophies, and much more.

Your mission, if you choose to accept it, is to help us fill it up with as much cool stuff as we can fit.

Please keep this project confidential!

✌️😄 ❤️ OS13k Team

// Minification Steps
// 1. Remove touch support
// 2. Paste programs.js to top
// 3. Google Closure
// 4. Terser
// 5. HTML Compressor

-->

<title>OS13k - A tiny operating system for JS13k</title>
<link rel=icon type=image/x-icon href='favicon.png?1'/>
<meta name=viewport content='width=device-width,initial-scale=1,user-scalable=0'>

<!-- HTML above is optional -->

<script>var OS13k</script>
<meta charset=utf-8>
<style>
body
{
    touch-action:none;
    margin:0;
    overflow:hidden;
    font-family:sans-serif;
    font-size:22;
    user-select:none;
    white-space:nowrap;
    background:#000;
}
#taskbar
{
    position:absolute;
    z-index:10000;
    width:100%;
    left:-2;
    background:linear-gradient(#888,#333);
    box-shadow:0px 1px 9px;
    border:2px solid;
}
.taskbarIcon
{
    width:50;
    height:40;
    text-shadow:1px 1px 3px #000;
    border-radius:22px;
}
#tray
{
    margin:2;
    padding:2;
    padding-left:9;
    padding-right:9;
    color:#fff;
    background:linear-gradient(#000,#333);
    border:1px solid;
    border-radius:6px;
}
.trayIcon       
{ 
    padding-left:5;
    padding-right:5;
    border-radius:6px;
}
.trayIcon:hover { background:#fff3; }
#menu
{
    visibility:hidden;
    display:flex;
    flex-direction:column;
    background:#000;
}
.folder, #menu
{
    position:absolute;
    z-index:20000;
    box-shadow:5px 5px 9px;
    border:2px solid;
}
.trophyPopup
{
    position:relative;
    z-index:10001;
    width:200;
    margin:9;
    padding:8;
    white-space:normal;
    pointer-events:none;
    overflow:hidden;
    font-size:20;
    text-align:center;
    background:linear-gradient(#eee,#888);
    box-shadow:9px 9px 19px;
    border:2px solid;
    border-radius:9px;
}
.trophyIcon
{
    padding:9;
    font-size:40;
    text-shadow:2px 2px 4px #000;
    white-space:nowrap;
}
.program
{
    font-size:18;
    height:18;
    padding:4;
}
.programActive,
.taskbarIconActive         { background:linear-gradient(#ff8,#fff); }
.taskbarIcon:hover         { background:linear-gradient(#fff,#44f); }
.taskbarIconActive:hover   { background:linear-gradient(#ff8,#44f); }
.folder                    { background:linear-gradient(#fff,#777); }
#title
{
    position:absolute;
    width:100%;
    height:100%;
    color:#0002;
    font-family:fantasy;
    font-size:20vw;
    font-weight:900;
    background:linear-gradient(#223,#322);
}
.flexCenter, .taskbarIcon, #taskbar, .program, #tray, #title
{
    display:flex;
    align-items:center;
    justify-content:center;
}
.activeWindow { border:3px solid #aaa; }
</style>
<template id=templateWindow>
<style>
:host
{
    position:absolute;
    display:flex;
    flex-direction:column;
    overflow:hidden;
    background:#000;
    box-shadow:5px 5px 9px;
    border:3px solid #222;
    border-radius:6px;
}
.titlebar
{
    height:44;
    font-size:26;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    white-space:nowrap;
    background:linear-gradient(#ccc,#444);
}
.titlebarActive
{
    background:linear-gradient(#eee,#88f);
}
.titlebarSticky
{
    background:linear-gradient(#ccc,#844);
}
#nameWrapper
{
    width:100%;
    overflow:hidden;
    cursor:grab;
}
#icon
{
    text-shadow:1px 1px 3px #000;
    margin-left:9;
    margin-right:9;
}
#name, #icon
{
    pointer-events:none;
    display:inline;
}
#frame
{
    width:100%;
    height:100%;
    overflow:hidden;
    background:#fff;
    border:none;
}
#helpDisplay
{
    height:99;
    resize:none;
    display:none;
    background:#000;
    border:1px solid #fff;
    color:#fff;
    outline:none;
}
#full:hover   { background:#fff; }
#help:hover   { background:#0ff; }
#code:hover   { background:#f0f; }
#shrink:hover,
#grow:hover   { background:#0f0; }
#reload:hover { background:#ff0; }
#close:hover  { background:#f00; }
div svg       { width:28;pointer-events:none; }
</style>
<svg height=0 width=0>
<symbol id=icon-full viewBox='0 0 10 10'>
    <rect stroke=#000 fill=none x=1 y=2 width=8 height=6 />
<symbol id=icon-help viewBox='0 0 10 10'>
    <path stroke=#000 fill=none d='M5 8L8 2L2 2L5 8L8 2'/>
<symbol id=icon-code viewBox='0 0 10 10'>
    <path stroke=#000 fill=none d='M5 2L8 8L2 8L5 2L8 8'/>
<symbol id=icon-shrink viewBox='0 0 10 10'>
    <path stroke=#000 d='M2 5L8 5'/>
<symbol id=icon-grow viewBox='0 0 10 10'>
    <path stroke=#000 d='M2 5L8 5M5 8L5 2'/>
<symbol id=icon-reload viewBox='0 0 10 10'>
    <circle stroke=#000 fill=none cx=5 cy=5 r=3 />
<symbol id=icon-close viewBox='0 0 10 10'>
    <path stroke=#000 d='M2 2L8 8M8 2L2 8'/>
</template>
<div id=desktop style=opacity:0>
<div id=taskbar>
<div id=traySpace style=flex:1></div>
<div id=tray>
    <div id=trayTrophy class=trayIcon title='Trophy Case'></div>
    <div id=trayVolume class=trayIcon title='Toggle Mute'>🔊</div>
    <div id=trayTime class=trayIcon></div>
</div>
</div>
<div id=trophyPopups style=float:right;position:relative></div>
<div id=programsFolder style=position:absolute></div>
<div id=title>OS13k
<div id=menu>
<button id=buttonFullScreen>Fullscreen
<button id=buttonShowHelp>Help
<button id=buttonShowCode>Code
<button id=buttonResetSize>Reset Size
<button id=buttonReload>Reload
<button id=buttonClose>Close
<script src=programs.js?103></script>
<script>

/////////////////////////////////////////////////////////////////////////////
// OS13k Debug Stuff (remove from minified)

// version check, clear local storage if older
const OS13kVersion = 26;
if (localStorage.OS13kVersion != OS13kVersion)
    localStorage.clear(), localStorage.OS13kVersion = OS13kVersion;
    
// load default programs if none found
if (typeof programs == 'undefined')
{
    alert('No programs found, using defaults!')
    programs = [{src:'system/test.html'},{src:'system/trophyCase.html'},{src:'system/clock.dweet.js', icon:'🕰️', width:200, height:200, sleep:0, full:0, reload:0, sticky:1}];
}

/////////////////////////////////////////////////////////////////////////////
// Use Strict and Google Closure Config

'use strict';

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs OS13kFolder, OS13kProgram, OS13kWindow, OS13kTaskbarIcon
// @js_externs OS13k, zzfx, iframeContent.zzfx
// @js_externs OS13k.Trophy, OS13k.GetTrophies, OS13k.KeyDirection, OS13k.Speak
// @js_externs OS13k.CreateShader, OS13k.RenderShader, OS13k.CreateCanvas
// @js_externs OS13k.PlaySamples, OS13k.PlaySeed, OS13k.GetNote
// @js_externs OS13k.Random, OS13k.randomSeed 
// @js_externs OS13k.Clamp, OS13k.Percent, OS13k.Lerp
// @js_externs localStorage.OS13kTrophies, localStorage.OS13kVersion
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==

/////////////////////////////////////////////////////////////////////////////
// OS13k System

class _OS13k
{
    Trophy(game='OS13k', name='', icon='', message='')
    {
        // remove commas
        game = game.replace(',','');
        name = name.replace(',','');
        icon = icon.replace(',','');
    
        // build key
        const key = game + ',' + name + ',' + icon;
        const storageKey = 'OS13kTrophy,' + key;
        
        // remove html tags
        const RemoveHTML =string=> (string||'').replace('<','');
        icon    = RemoveHTML(icon) || '🏆';
        name    = RemoveHTML(name);
        game    = RemoveHTML(game);
        message = RemoveHTML(message);
        
        // find in trophy list
        const trophyIndex = trophies.findIndex(e=>e[4]==key)
        
        // skip if no game or same message
        if (!game || trophyIndex >=0 && trophies[trophyIndex][3] == message)
            return;
        
        // add or update trophy list
        const trophyData = [game, name, icon, message, key];
        trophyIndex < 0 ? 
            trophies.push( trophyData ) :
            trophies[trophyIndex] = trophyData;

        if (loadIcon)
        {
            // save local storage if loading is finished
            localStorage[storageKey] = message;
            localStorage.OS13kTrophies = JSON.stringify(trophies);
        }
        
        // use game as name if there is no name
        name || (name = game, game = '');
        
        // speak the trophy name
        this.Speak(name);

        // build trophy popup element
        const trophyPopup = document.createElement('div');
        trophyPopup.className = 'trophyPopup';
        trophyPopup.innerHTML =
            '<div class=trophyIcon>' + icon + '</div>' + // icon
            '<div>' +                                    // info
                '<b>' + name + '</b><br>' +              // name
                '<i>' + game + '</i>' +                  // game
            '</div>' + message;                          // message
            
        // add trophy to bottom of screen
        trophyPopup.style.top = innerHeight;
        trophyPopups.appendChild(trophyPopup);
        
        // refresh trophy window if it is being displayed
        trophyProgram && trophyProgram.window && trophyProgram.window.iframeContent &&
            trophyProgram.window.iframeContent.OS13kStart();
    }
    
    GetTrophies() { return trophies } 
    
    KeyDirection(keyCode)
    {
        // get direction from wasd or arrow keys
        let x = 0, y = 0;
        (keyCode == 87 || keyCode == 38) && ++y; // up
        (keyCode == 83 || keyCode == 40) && --y; // down
        (keyCode == 68 || keyCode == 39) && ++x; // right
        (keyCode == 65 || keyCode == 37) && --x; // left
        return {x, y};
    }
    
    PlaySeed(seed, lengthScale=1, volume=1, randomness=.05)
    {
        // set random seed
        const R=()=>this.Random(), C=()=>R()<.5, S=()=>C()?1:-1;
        this.randomSeed = seed;
        
        // randomize sound length
        lengthScale /= 2;
        const attack  = R()**3*lengthScale;
        const sustain = R()**3*lengthScale;
        const release = R()**3*lengthScale;
        const length  = attack + sustain + release;
        
        // create random sound
        return zzfx(...
        [
           volume,               // volume
           randomness,           // randomness
           R()**2*2e3,           // frequency
           attack,               // attack
           sustain,              // sustain
           release,              // release
           R()*5|0,              // shape
           R()**2*3,             // shapeCurve
           C() * R()**3*99*S(),  // slide
           C() * R()**3*99*S(),  // deltaSlide
           C() * R()**2*1e3*S(), // pitchJump
           R()**2 * length,      // pitchJumpTime
           C() * R() * length,   // repeatTime
           C() * R()**4,         // noise
           C() * R()**3*9*S(),   // modulation
           C() * R()**4,         // bitCrush
           C() * R()**3/2,       // delay
        ]);
    }
    
    PlaySamples(samples, sampleRate=44100)
    {
        // play raw audio sample data
        const buffer = audioContext.createBuffer(1, samples.length, sampleRate);
        const source = audioContext.createBufferSource();
        buffer.getChannelData(0).set(samples);
        source.buffer = buffer;
        source.connect(gain);
        source.start();
        return source;
    }
    
    GetNote(rootNoteFrequency=440, semitoneOffset=0)
    {
        // get frequency of a musical note on a diatonic scale
        return rootNoteFrequency * 2**(semitoneOffset/12);
    }

    Speak(text, rate=1, pitch=1, volume=1, language='en')
    {
        // common languages (not supported in all browsers)
        // it - italian, fr - french,  de - german,   es - spanish, pl - polish
        // hi - hindi,   ru - russian, ja - japanese, zh - chinese, ko - korean
    
        // must have speech and not be muted
        if (speechSynthesis && gain.gain.value)
        {
            // speak with utterance parameters
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.volume = volume;
            utterance.pitch = pitch;
            utterance.rate = rate;
            utterance.lang = language;
            speechSynthesis.speak(utterance);
        }
    }
    
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');

        // create a simple pass through vertex shader
        const vertexShader = x.createShader(x.VERTEX_SHADER);
        x.shaderSource(vertexShader,
            '#version 300 es\n' +
            'in vec4 p;' +
            'void main()' +
            '{gl_Position=p;}');
        x.compileShader(vertexShader);
        
        // create vertex buffer that is a big triangle
        const vertexBuffer = x.ARRAY_BUFFER;
        x.bindBuffer(vertexBuffer,x.createBuffer());
        x.bufferData(vertexBuffer,new Int8Array([-3,1,1,-3,1,1]),x.STATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0,2,x.BYTE,0,0,0); // 2D vertex
        
        // check vertex shader for errors
        //if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
        //    throw x.getShaderInfoLog(vertexShader);
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(x.FRAGMENT_SHADER)
        const shaderProgramCode = 
            '#version 300 es\n' +
            'precision mediump float;' +
            'uniform float iTime;' +
            'uniform int iFrame;' +
            'uniform vec4 iMouse;' +
            'uniform vec3 iResolution;' +
            'uniform sampler2D iChannel0;' +
            'out vec4 outColor;\n' +
            code +
            '\nvoid main()' +
            '{mainImage(outColor,gl_FragCoord.xy);' +
            'outColor.a=1.;}';
        x.shaderSource(pixelShader, shaderProgramCode)
        x.compileShader(pixelShader);

        // check pixel shader for errors
        if (!x.getShaderParameter(pixelShader, x.COMPILE_STATUS))
            throw x.getShaderInfoLog(pixelShader);

        // create texture
        x.bindTexture(x.TEXTURE_2D, x.createTexture());
        x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.LINEAR);
        x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL, 1); 
        
        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    RenderShader(canvas, shaderProgram, time=0, frame=0)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // set uniforms
        const uniformLocation=name=>x.getUniformLocation(shaderProgram, name);
        x.uniform3f(uniformLocation('iResolution'), canvas.width, canvas.height, 1);
        x.uniform1f(uniformLocation('iTime'), time);
        x.uniform1f(uniformLocation('iFrame'), frame);
        x.uniform1i(uniformLocation('iChannel0'), 0);
        
        // render shader
        x.viewport(0, 0, canvas.width, canvas.height);
        x.drawArrays(x.TRIANGLE_FAN, 0, 3);
        
        // set texture to the newly renderd canvas
        x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, x.RGBA, x.UNSIGNED_BYTE, canvas);
    }
    
    // helper functions
    Clamp(a, min=0, max=1) { return Math.min(Math.max(a, min),max) }
    Percent(v, a, b)       { return b-a? this.Clamp((v-a)/(b-a), 0, 1) : 0 }
    Lerp(p, a, b)          { return a + this.Clamp(p, 0, 1) * (b-a) }
    Random(max=1, min=0)
    {
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= (this.randomSeed||-1) << 13;
        this.randomSeed ^= this.randomSeed >> 17;
        this.randomSeed ^= this.randomSeed << 5;
        return this.Percent(Math.abs(this.randomSeed) % 1e9 / 1e9, min, max);
    }
}; // _OS13k

/////////////////////////////////////////////////////////////////////////////
// OS13k Desktop

const taskbarHeight = 42, programHeight = 26, titlebarHeight = 50,
      startWindowOpenX = 9, startWindowOpenY = 51, 
      trophyPopupTime = 3, defaultVolume = .3;
      
let grabWindow, grabOffsetX, grabOffsetY, finishedStartup,
    activeWindow, activeProgram, firstProgram, activeTaskbarIcon,
    lastActiveElement, loadIcon, topZ = 0, loading = 0,
    windowOpenX = startWindowOpenX, windowOpenY = startWindowOpenY,
    trophies = [], trophyProgram, clockProgram;

const Init=()=>
{
    // parse trophy list
    trophies = localStorage.OS13kTrophies ? JSON.parse(localStorage.OS13kTrophies) : [];

    const CheckForTrophy=key=>
    {
        const keyParts = key.split(',');
        keyParts.length = 4;
        if (keyParts.shift() == 'OS13kTrophy') 
            OS13k.Trophy(...keyParts, localStorage[key])
    }

    // search local storage for trophies
    for (let i = localStorage.length; i--;)
        CheckForTrophy(localStorage.key(i));
    
    // listen for trophies from other windows
    window.onstorage =e=> CheckForTrophy(e.key);
    
    // save trophies
    localStorage.OS13kTrophies = JSON.stringify(trophies);
    
    // set functions
    trayTrophy.onmousedown   = trayTrophy.ontouchstart =()=> trophyProgram.Toggle();
    trayTime.onmousedown     = trayTime.ontouchstart =()=> clockProgram.Toggle();
    trayVolume.onmousedown   = trayVolume.ontouchstart = ToggleMute;

    buttonFullScreen.onmousedown =()=> activeWindow.FullScreen();
    buttonShowHelp.onmousedown   =()=> activeWindow.ShowHelp();
    buttonShowCode.onmousedown   =()=> activeWindow.ShowHelp();
    buttonResetSize.onmousedown  =()=> activeWindow.Resize();
    buttonReload.onmousedown     =()=> activeWindow.Reload();
    buttonClose.onmousedown      =()=> activeWindow.Close();

    // create the folder taskbar icon and add folders/programs
    loadIcon = new OS13kTaskbarIcon( {icon:'💾', name:'Load Program'} );
    loadIcon.windowOrFolder = new OS13kFolder(programs);
    
    OS13k.Trophy(undefined,'Welcome!','👋');
    if (localStorage.OS13kFrozen)
    {
        OS13k.Trophy(undefined,'Frozen','🧊',`Froze The Browser\n${localStorage.OS13kFrozen}`);
        delete localStorage.OS13kFrozen;
    }
    
    CloseMenus();
    HandleStartup();
}

const HandleStartup=()=>
{
    if (!loading && !finishedStartup)
    {
        finishedStartup = 1;
        
        // focus on first program in list after startup if not sticky closed
        firstProgram.window ? 
            firstProgram.window.Focus(1) :
            (firstProgram.sticky && firstProgram.LoadInfo().open==0) || 
            firstProgram.Click();
    }
}

const Update=()=>
{
    requestAnimationFrame(Update);

    // listen for iframe becomming new active element
    const activeElement = document.activeElement;
    if (lastActiveElement != activeElement)
    {
        // set focus to new active element
        activeElement.SetActive && activeElement.SetActive();
        lastActiveElement = activeElement;
    }
    
    // update trophy popups if not fullscreen
    if (!document.fullscreenElement)
    {
        let offsetHeight = 0, waitToFade = 0;
        
        // use copy of trophies to prevent skipping if removed
        for(const popup of [...trophyPopups.children])
        {
            let y = parseInt(popup.style.top) + offsetHeight - 9;
            if (y < taskbarHeight)
            {
                if (!waitToFade && !(popup.style.opacity = (popup.style.opacity || trophyPopupTime) - .01))
                {
                    // remove when invisible and adjust for height
                    const rect = popup.getBoundingClientRect();
                    offsetHeight += rect.height;
                    trophyPopups.removeChild(popup);
                }
                waitToFade = y = taskbarHeight;
            }

            popup.style.top = y;
        }
    }
    
    // update trophy count
    trayTrophy.innerHTML = trophies.length + ' 🏆';
    
    // update time
    trayTime.title = new Date();
    const time = trayTime.title.slice(16,24).split(':')
    trayTime.innerHTML = (time[0]%12?time[0]%12:12) + ':' + time[1];
    
    // fade in desktop
    loading || (desktop.style.opacity = .02 + desktop.style.opacity*1);
}

const CloseMenus=()=>
{
    // hide all drop down folders
    for (const c of programsFolder.children)
        c.localName == 'os13k-folder' && (c.style.visibility = 'hidden');
        
    // hide menu
    menu.style.visibility = '';
}

const FocusTopWindow=()=>
{
    // find the top window and focus on it
    let topWindow;
    for (const c of desktop.children)
    {
        c.localName == 'os13k-window' &&
        (!topWindow || topWindow.style.zIndex < c.style.zIndex) &&
            (topWindow = c);
    }
    topWindow && topWindow.Focus();
}

const ToggleMute=()=>
{
    speechSynthesis && speechSynthesis.cancel();
    gain.gain.value = gain.gain.value ? 0 : defaultVolume;
    trayVolume.innerHTML = gain.gain.value ? '🔊' : '🔇';
    
    OS13k.Trophy(undefined,'Shut Up','🔇','Muted');
}

/////////////////////////////////////////////////////////////////////////////
// OS13kTaskbarIcon

class OS13kTaskbarIcon extends HTMLElement
{
	constructor(program, windowOrFolder = 0)
    {
		super();
        
        // create icon
        this.className = 'taskbarIcon';
        this.innerHTML = '<div style=pointer-events:none>' + program.icon;
        this.windowOrFolder = windowOrFolder;
        this.title = program.title || program.name;
        
        // add to taskbar
        traySpace.before(this);
    }
    
    Click() { this.windowOrFolder.Focus(); }
    
    SetActive(active=1)
    {
        // unselect old icon and set style
        activeTaskbarIcon && activeTaskbarIcon.SetActive(activeTaskbarIcon = 0);
        activeTaskbarIcon = this;
        this.className = 'taskbarIcon' + (active ? ' taskbarIconActive' : '');
    }
} // OS13kTaskbarIcon

customElements.define('os13k-taskbar-icon', OS13kTaskbarIcon);

/////////////////////////////////////////////////////////////////////////////
// OS13kFolder

class OS13kFolder extends HTMLElement
{
	constructor(infos, x=0, y=0, parentFolder)
    {
		super();
        
        // add to desktop
        this.className = 'folder';
        this.style.left = x;
        this.style.top = y;
        this.parentFolder = parentFolder;
        programsFolder.appendChild(this);
        
        // add programs to folder
        for (const info of infos)
            this.appendChild(info.program = new OS13kProgram(info));
        
        // get width offset and add new folders recursively
        const rect = this.getBoundingClientRect();
        for (const info of infos)
        {
            // create the folder and hook up to programs
            info.folder && (info.program.folder = new OS13kFolder(info.folder, rect.right - 2, y, this));
            y += programHeight;
        }
    }

    Focus()
    {
        // check if it is visible
        //const wasVisible = !this.style.visibility;
        
        // close menus so they can reopen with this focused
        CloseMenus();
        
        // reset position if from taskbar click
        //if (!wasVisible)
        {
            // make visible
            this.parentFolder && this.parentFolder.Focus();
            this.style.visibility = '';
        }
        
    }
} // OS13kFolder

customElements.define('os13k-folder', OS13kFolder);

/////////////////////////////////////////////////////////////////////////////
// OS13kProgram

class OS13kProgram extends HTMLElement
{
	constructor({x, y, name, icon, src='', width=720, height=405, author, folder, help, full=1, reload=1, code, sleep=1, sticky, resize=1})
    {
		super();
        
        const srcParts = src.split('.');
        
        // set icon defaults
        src = src || '';
        icon = icon || '💠';
        
        if (!name)
        {
            // infer name from camel case src
            let srcCleanName = srcParts[0].split('/');
            srcCleanName = srcCleanName[Math.max(0,srcCleanName.length-1)].replace(/([a-z](?=[A-Z]))/g, '$1 ');
            name = srcCleanName.charAt(0).toUpperCase() + srcCleanName.slice(1);
        }
        
        // check for special extensions
        const extension = src? srcParts[1] : '';
        this.isDweet = extension == 'dweet';
        this.isShader = extension == 'shader';
        this.hasExtension = this.isDweet || this.isShader

        // set icon data
        this.className = 'program';
        this.name = name;
        this.icon = icon;
        this.src = src;
        this.srcShort = srcParts[0];
        this.width = width;
        this.height = height;
        this.author = author;
        this.sleep = sleep;
        this.full = full;
        this.reload = reload;
        this.code = code || (this.hasExtension && code === undefined);
        this.sticky = sticky;
        this.help = help;
        this.resize = resize;
        
        // set title if not a folder
        if (!folder)
            this.title = name +
                ( this.isDweet ? ' - Dweet' :  this.isShader ? ' - Shader' : '') +
                (author ? '\nBy ' + author : '');
            
        // icon
        const iconDisplay = document.createElement('div');
        iconDisplay.style = 'pointer-events:none;width:45;text-shadow:1px 1px 3px #000;text-align:center';
        iconDisplay.innerHTML = icon;
        this.appendChild(iconDisplay);
        
        // name
        const nameDisplay = document.createElement('div');
        nameDisplay.style = 'pointer-events:none;flex:1'
        nameDisplay.innerHTML = name;
        this.appendChild(nameDisplay);
        
        if (folder)
        {
            // folder arrow
            const folderDisplay = document.createElement('div');
            folderDisplay.style = 'pointer-events:none'
            folderDisplay.innerHTML = '&nbsp;&nbsp;▶';
            this.appendChild(folderDisplay);
        }
        
        // save trophy program
        name == 'Trophy Case' && (trophyProgram = this);
        
        // save clock program
        name == 'Clock' && (clockProgram = this);

        // check for sticky
        if (sticky && this.LoadInfo().open)
            this.Click();
            
        // save first program in list
        firstProgram || src && (firstProgram=this);
    }
    
    Move()
    {
        // set active
        activeProgram = this;
        this.className = 'program programActive';
        (this.folder? this.folder : this.offsetParent).Focus();
    }
    
    Click() 
    {
        if (this.src)
        {
            // load save info
            const info = this.LoadInfo(windowOpenX, windowOpenY);

            // update window open positions
            if (info.updatePosition)
            {
                (windowOpenX += titlebarHeight) > 400 && (windowOpenX = startWindowOpenX);
                (windowOpenY += titlebarHeight) > 200 && (windowOpenY = startWindowOpenY);
            }

            // open the window
            this.window || (this.window = new OS13kWindow(this, info.x, info.y));

            // set focus to window
            //this.window.Focus(1);
            
            // save info on open if sticky
            this.sticky && this.SaveInfo(1);
        }
        else if (!this.folder)
        {
            // close all windows if no src or folder
            for (const c of [...desktop.children])
                c.Close && c.Close()

            // reset window open position
            windowOpenX = startWindowOpenX;
            windowOpenY = startWindowOpenY;

            OS13k.Trophy(undefined,'Coffee Is For Closers','☕','Closed All');
        }
        
        this == trophyProgram && OS13k.Trophy(undefined,'Hoarder','','Viewed Trophys');
        this == clockProgram && OS13k.Trophy(undefined,'Clock Watcher','🕰️','Checked Time');
    }
    
    Toggle() { this.window ? this.window.Close() : this.Click() }
    
    SaveInfo(open)
    {
        // save info to local storage
        const rect = this.window.getBoundingClientRect();
        localStorage['OS13kProgram'+this.src] = 
            JSON.stringify({x:rect.x, y:rect.y, open});
    }
    
    LoadInfo(x, y)
    {
        // try to load saved window data from local storage
        const saveWindowJSON = localStorage['OS13kProgram'+this.src];
        return saveWindowJSON && this.sticky ?
            JSON.parse(saveWindowJSON) : {x, y, updatePosition:1}
    }
} // OS13kProgram

customElements.define('os13k-program', OS13kProgram);

/////////////////////////////////////////////////////////////////////////////
// OS13kWindow

class OS13kWindow extends HTMLElement
{
	constructor(program, x, y)
    {
		super();

        // add to desktop
        desktop.appendChild(this);
        
        // create taskbar program
        this.taskbarIcon = new OS13kTaskbarIcon(program, this);
        this.program = program;
        
        // set position
        this.style.left = x;
        this.style.top = y;
        
        // shadow root
		this.shadow = this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = templateWindow.innerHTML;
        
        // title bar
        this.titlebar = document.createElement('div');
        this.titlebar.id = 'titlebar';
        this.titlebar.title = program.title;
        this.shadowRoot.appendChild(this.titlebar);
        
        // title bar wrapper
        this.nameWrapper = document.createElement('div');
        this.nameWrapper.id = 'nameWrapper';
        this.titlebar.appendChild(this.nameWrapper);

        // icon
        const iconDisplay = document.createElement('div');
        iconDisplay.id = 'icon';
        iconDisplay.innerHTML = program.icon;
        this.nameWrapper.appendChild(iconDisplay);
        
        // name
        const nameDisplay = document.createElement('div');
        nameDisplay.id = 'name';
        nameDisplay.innerHTML = program.name;
        this.nameWrapper.appendChild(nameDisplay);
        
        // create title bar icons
        const AddTitlebarIcon=(id, title)=>
        {
            const icon = document.createElement('div');
            icon.innerHTML = `<svg><use href=#icon-${icon.id = id}>`;
            icon.title = title;
            this.titlebar.appendChild(icon);
        }
        program.full && AddTitlebarIcon('full', 'Full Screen');
        program.help && AddTitlebarIcon('help', 'Help');
        program.help || program.code && AddTitlebarIcon('code', 'Code')
        program.resize && 
        ( AddTitlebarIcon('shrink', 'Shrink'), AddTitlebarIcon('grow', 'Grow'));
        program.reload && AddTitlebarIcon('reload', 'Reload');
        AddTitlebarIcon('close', 'Close');
        
        // create thin line below title bar
        const titlebarGap = document.createElement('div');
        titlebarGap.style='height:3';
        this.shadowRoot.appendChild(titlebarGap);

        // create content wrapper
        const frameWrapper = this.frameWrapper = document.createElement('div');
        frameWrapper.style.background = '#000';
        this.shadowRoot.appendChild(frameWrapper);
        
        // limit window size to inner size while preserving aspect
        const width = program.resize ? 
            Math.min(program.width, innerWidth-6) : program.width;
        this.frameWrapper.style.width  = width;
        this.frameWrapper.style.height = width * program.height / program.width;
        this.scale = width / program.width;
        this.titlebar.style.width = width;

        // create iframe
        const iframe = this.iframe = document.createElement('iframe'); 
        iframe.id = 'frame';
        this.style.visibility = 'hidden';
        
        // track if programs are loading
        ++loading;
                
        // wait for frame to load
        iframe.onload=e=>
        {
            // track if programs are loading
            --loading;
        
            // set up iframe          
            const iframeContent = this.iframeContent = e.target.contentWindow;
            let iframeDocument, iframeText;
            
            try
            {
                // get the document and text, will fail if cross site
                iframeDocument = iframeContent.document;
                iframeText = program.hasExtension ?
                    iframeDocument.body.innerText : iframeDocument.body.innerHTML;

                // create help display
                this.helpDisplay = document.createElement('textarea');
                this.helpDisplay.id = 'helpDisplay'; 
                this.helpDisplay.setAttribute('readOnly', 1);
                this.helpDisplay.value = this.program.help || iframeText;
                this.shadowRoot.appendChild(this.helpDisplay);
            }
            catch (e) {}
            
            if (iframeDocument)
            {
                // pass zzfx to iframe
                iframeContent.OS13k || (iframeContent.OS13k = OS13k);
                iframeContent.zzfx = zzfx;
                
                // prevent iframes context menu
                iframeContent.oncontextmenu =()=> false;
                
            }

            // check for extensions
            if (iframeDocument && program.hasExtension)
            {
                // create full size canvas
                iframeDocument.body.innerHTML = 
                    `<canvas id=c width=1920 height=1080 style=` +
                    'width:100%;background:#' +
                    (program.isDweet ? 'fff' : '000') +'>';
                iframeDocument.body.style = 
                    'background:#111;' +
                    'overflow:hidden;' +
                    'margin:0;' +
                    'display:flex;' +
                    'align-items:center';

                // create dweet
                program.isDweet && iframeContent.eval(
                    'u=t=>{' + iframeText + '};' +
                    'x=c.getContext`2d`;' +
                    'S=Math.sin;' +
                    'C=Math.cos;' +
                    'T=Math.tan;' +
                    'R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;' +
                    'loop=t=>requestAnimationFrame(loop,' +
                        `${program.sleep?'document.hasFocus()':1}&&` +
                        'u((60*(frame++/60)-frame-1|0?frame-1:frame)/60));' +
                    'loop(frame=0)');

                // create shader
                program.isShader && iframeContent.eval(
                    'g=c.getContext`webgl2`;' +
                    'x=y=z=w=f=0;' +
                    'onmousemove=e=>e.buttons&&(x=e.x,y=c.height-e.y);' +
                    'onmousedown=e=>(x=z=e.x,y=w=c.height-e.y);' +
                    'onmouseup=e=>z=w=0;' +
                    'loop=t=>requestAnimationFrame(loop,' +
                        `${program.sleep?'document.hasFocus()':1}&&(` +
                        'c.width=innerWidth,' + 
                        'c.height=innerHeight,' + 
                        'g.uniform4f(g.getUniformLocation(s,"iMouse"),x,y,z,w),' +
                        'parent.OS13k.RenderShader(c,s,t/1e3,f++)));' + 
                    'loop(s=parent.OS13k.CreateShader(c,`' + iframeText + '`))');
            }

            // make visible
            this.style.visibility = this.iframe.style.visibility = '';
            
            // only focus if not grabbing
            grabWindow || this.Focus(1);
    
            // special logic during startup
            HandleStartup();
        }
        
        // load the iframe
        iframe.src = program.src;
        frameWrapper.appendChild(iframe);
    }
    
    Click(e, target)
    {
        // set grab object if name is clicked on
        target.id == 'nameWrapper' && (grabWindow = this);
        
        // check for title bar buttons
        target.id == 'full'        && this.FullScreen();
        target.id == 'reload'      && this.Reload();
        target.id == 'close'       && this.Close();
        target.id != 'helpDisplay' && this.Focus();
        (target.id == 'help' || target.id == 'code') && this.ShowHelp();
        target.id == 'shrink'      && this.Resize(this.scale - .5);
        target.id == 'grow'        && this.Resize(this.scale + .5);
        
        // set focus
        this.Focus();
    }
    
    Resize(scale=1)
    {
        // change size of window
        const wNew = OS13k.Clamp(this.program.width * scale, 300, 2e3);
        const hNew = this.program.height * (this.scale = wNew / this.program.width);
        
        // set new size
        const w = parseInt(this.frameWrapper.style.width);
        this.titlebar.style.width = this.frameWrapper.style.width = wNew;
        this.frameWrapper.style.height = hNew;
    
        // adjust window position for offset
        this.style.left = parseInt(this.style.left) + w - wNew;
    }
    
    Focus(clamp)
    {
        // set focus
        this.iframeContent && this.iframeContent.focus();
        this.SetActive();
        
        if (clamp)
        {
            // clamp window to screen
            const rect = this.getBoundingClientRect();
            this.style.left = OS13k.Clamp(rect.x, 0, innerWidth - rect.width);
            this.style.top = OS13k.Clamp(rect.y, taskbarHeight, 
                Math.max(taskbarHeight, innerHeight - rect.height));
        }
    }
    
    SetActive(active=1)
    {
        if (active)
        {
            this.taskbarIcon.SetActive();
            if (activeWindow != this)
            {
                // deactivate old window
                activeWindow && activeWindow.SetActive(0);

                // move z to top
                this.style.zIndex = ++topZ;

                // show menu buttons
                buttonFullScreen.style.display = this.program.full?   '' : 'none';
                buttonShowHelp.style.display   = this.program.help?   '' : 'none';
                buttonShowCode.style.display   = this.program.code?   '' : 'none';
                buttonReload.style.display     = this.program.reload? '' : 'none';
                buttonResetSize.style.display  = this.program.resize? '' : 'none';
            }
            
            // close menus incase iframe stole focus
            CloseMenus();
        }
            
        // set active
        activeWindow = active && this;
        this.className = active? 'activeWindow' : '';
        this.titlebar.className = 'titlebar titlebar' 
            + (active ? 'Active' : this.program.sticky ? 'Sticky' : '');
        (this.program.sleep ? this : this.titlebar).style.filter = 
            active? '' : 'saturate(.7)brightness(.7';
    }
    
    FullScreen()
    {
        this.Focus();
        if (!this.program.full)
            return;
        
        // set full screen
        const fullScreenElement = this.frameWrapper;
        fullScreenElement.webkitRequestFullScreen = 
            fullScreenElement.webkitRequestFullScreen || 
            fullScreenElement.mozRequestFullScreen
        if (fullScreenElement.webkitRequestFullScreen)
            fullScreenElement.webkitRequestFullScreen();
            
        OS13k.Trophy(undefined,'Pro Gamer','🕹️','Went Fullscreen');
    }
    
    ShowHelp()
    {
        // toggle showing code
        this.Focus();
        this.helpDisplay.style.display = 
            (this.showHelp = !this.showHelp) ? 'block' : '';
        
        this.program.help?
            OS13k.Trophy(undefined,'Avid Reader','📘','Viewed Help') :
            OS13k.Trophy(undefined,'Hacker','👨‍💻','Viewed Code');
    }
    
    Reload()
    {
        // hide iframe and reload it
        this.iframe.style.visibility = 'hidden';
        this.iframeContent.location.reload();
    }
    
    Close()
    {
        // save info
        this.program.SaveInfo(0);
        
        // destroy window
        this.program.window = 0;
        this.taskbarIcon.remove();
        this.remove();
        
        // try to focus on top window
        FocusTopWindow();
    }
} // OS13kWindow

customElements.define('os13k-window', OS13kWindow);

/////////////////////////////////////////////////////////////////////////////
// Mouse Input

onmousedown =e=>
{
    // prevent stuck grab
    if (grabWindow)
        return onmouseup(e);
    
    // only look for left mouse button
    if (e.button)
    {
        CloseMenus();
        const openMenu = e.button == 2;
        if (openMenu)
        {
            // open context menu
            let menuElement = menu;
            if (!e.target.SetActive || e.target == loadIcon)
            {
                // open folder if clicked on desktop or folder icon
                menuElement = programsFolder;
                loadIcon.Click();
            }

            // set target active
            const target = (e.target.window || e.target);
            target.SetActive && target.SetActive();

            // show menu
            menuElement.style.left = e.x;
            menuElement.style.top = e.y;
            menuElement.style.visibility = 'visible';
        }
    
        return openMenu;
    }
    
    // close menus if visible and loadIcon clicked on 
    if (e.target == loadIcon && !loadIcon.windowOrFolder.style.visibility)
        return CloseMenus();
    CloseMenus();
    
    // handle mouse down
    e.target.Click && e.target.Click(e, e.originalTarget || e.path[0]);
    
    if (grabWindow)
    {
        // set grabbing mode
        document.body.style.cursor = grabWindow.nameWrapper.style.cursor = 'grabbing';
        grabWindow.frameWrapper.style.pointerEvents = 'none';
        
        // save grab offset
        const rect = e.target.getBoundingClientRect();
        grabOffsetX = e.x - rect.x;
        grabOffsetY = e.y - rect.y;
    }
    
    programsFolder.style.left = 0;
    programsFolder.style.top = taskbarHeight;
}

onmousemove =e=>
{
    if (grabWindow)
    {
        // update grab position
        grabWindow.style.left = e.x - grabOffsetX;
        grabWindow.style.top = e.y - grabOffsetY;
        
        // save info
        grabWindow.program.SaveInfo(1);
    }
    
    // unselect active program
    activeProgram && (activeProgram.className = 'program');
    
    // handle mouse move
    e.target.Move && e.target.Move();
}

onmouseup =e=>
{
    // allow pointer events and reset cursor
    document.body.style.cursor = '';
    if (grabWindow)
    {
        grabWindow.nameWrapper.style.cursor =
        grabWindow.frameWrapper.style.pointerEvents = '';
        
        // release grab object
        grabWindow = 0;
    }
}

ondblclick =e=>
{
    // go fullscreen if titlebar name or icon is double clicked
    const originalTarget = e.originalTarget || e.path[0];
    const target = e.target.window || e.target;
    if ((originalTarget.id == 'name') || e.target.window)
        target.FullScreen && target.FullScreen();
}

// prevent default context menu
oncontextmenu =e=> false;

/////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth 

// init web audio
const audioContext = new (AudioContext || webkitAudioContext);
audioContext.Z = audioContext.createBufferSource;
audioContext.createBufferSource = (s = audioContext.Z())=>
(
    s.start = s.start || s.noteOn,
    s.stop  = s.stop  || s.noteOff,
    s
);

// setup gain node
const gain = audioContext.createGain();
gain.connect(audioContext.destination);
gain.gain.value = defaultVolume;

// play zzfx sound
const zzfx =
(
    // parameters
    volume=1, randomness=.05, frequency=220, attack=0, sustain=0, release=.1, shape=0, shapeCurve=1, slide=0, deltaSlide=0, pitchJump=0, pitchJumpTime=0, repeatTime=0, noise=0, modulation=0, bitCrush=0, delay=0,

    // locals
    PI2 = Math.PI*2,
    sampleRate = 44100,
    random = r => r*2*Math.random()-r,
    sign = v => v>0?1:-1,
    startSlide = slide *= 500 * PI2 / sampleRate**2,
    startFrequency = frequency *= (1 + random(randomness)) * PI2 / sampleRate,
    modPhase = sign(modulation) * PI2/4,
    b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, d=.5,
    length, buffer
) =>
{
    // init parameters
    attack = 99 + attack * sampleRate | 0;
    sustain = sustain * sampleRate | 0;
    release = release * sampleRate | 0;
    delay = delay * sampleRate | 0;
    deltaSlide *= 500 * PI2 / sampleRate**3;
    length = attack + sustain + release + delay;
    modulation *= PI2 / sampleRate;
    pitchJump *= PI2 / sampleRate;
    pitchJumpTime = pitchJumpTime * sampleRate;
    repeatTime = repeatTime * sampleRate;

    // generate waveform
    for(; i < length;b[i++] = s)
    {
        if (++c > bitCrush*100)                          // bit crush
        {
            c = 0;                                       // reset bit crush
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation - modPhase);    // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
                Math.sin((s%PI2)**3) :                   // 4 noise
                Math.max(Math.min(Math.tan(s),1),-1):    // 3 tan
                1-(2*s/PI2%2+2)%2:                       // 2 saw
                1-4*Math.abs(Math.round(s/PI2)-s/PI2):   // 1 triangle
                Math.sin(s);                             // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * (                              // envelope
                i < attack ? i/attack :                  // attack
                i < attack + sustain ? 1 :               // sustain
                i < length - delay ?                     // post release
                1 - (i - attack - sustain)/release : 0); // release
                
            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i-delay]/2) : s;
        }

        t += 1 + random(noise);             // noise
        tm += 1 + random(noise);            // modulation noise
        frequency += slide += deltaSlide;   // frequency slide

        if (j && ++j > pitchJumpTime)       // pitch jump
        {
            frequency += pitchJump;         // apply pitch jump
            startFrequency += pitchJump;    // also apply to start frequency
            j = 0;                          // reset pitch jump time
        };

        if (repeatTime && ++r > repeatTime) // repeat
        {
            frequency = startFrequency;     // reset frequency
            slide = startSlide;             // reset slide
            r = 1;                          // reset repeat time
            j = j || 1;                     // reset pitch jump time
        }
    }
    
    return OS13k.PlaySamples(b);
}

/////////////////////////////////////////////////////////////////////////////
// Start OS13k!

OS13k = new _OS13k;
Init();
Update();

/////////////////////////////////////////////////////////////////////////////////////
// Touch Input (optional)

try
{
    let wasTouching;
    const ProcessTouch=e=>
    {
        const touching = e.touches.length;
        if (touching)
        {
            // set event pos
            e.x = e.touches[0].clientX;
            e.y = e.touches[0].clientY;
            
            // pass event on to mouse input
            !wasTouching && onmousedown(e);
            onmousemove(e);
        }
        else
            wasTouching && onclick(e);
        wasTouching = touching;
        
        return false; // prevent default
    }

    // set all touch events
    ontouchstart = ontouchmove = ontouchend = ontouchcancel = ProcessTouch;
}
catch (e) {}

</script>