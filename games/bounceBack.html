<html><head><title>Bounce Back</title><style>
body{background:#000;overflow:hidden;margin:0;}
canvas{width:100%;height:100%;image-rendering:-moz-crisp-edges;image-rendering:pixelated;}
</style></head><body><canvas id=c1></canvas><canvas id=c2 style=visibility:hidden></canvas><script>

OS13k = parent.OS13k;

///////////////////////////////////////////////////////////////////////////////
// helper functions

let RGBA             = (r=0,g=0,b=0,a=1)=>(`rgba(${r*255|0},${g*255|0},${b*255|0},${a})`);
let PI               = Math.PI;
let Rand             = (m=1)=>Math.random()*m;
let RandInt          = m=>Rand(m)|0;
let RandBetween      = (a,b)=>a+Rand(b-a);
let RandIntBetween   = (a,b)=>a+RandInt(b-a+1);
let RandVector       = (scale=1)=>     (new Vector2(scale,0)).Rotate(Rand(2*PI));
let RandColorBetween = (c1,c2)=>       c1.Clone().Lerp(c2,Rand());
let IsArrayValid     = (x,y,size)=>    (x>=0 && y>=0 && x < size && y < size);

let Min=(a, b)=>                       (a<b)? a : b;
let Max=(a, b)=>                       (a>b)? a : b;
let Clamp=(v, min, max)=>              Min(Max(v, min), max);
let Percent=(v, a, b)=>                (a==b)? 0 : Clamp((v-a)/(b-a), 0, 1);
let Lerp=(p, a, b)=>                   a + Clamp(p, 0, 1) * (b-a);
let FormatTime=(t)=>                   
{
    let s = (t|0)%60;
    return (t/60|0)+':'+(s<10?'0':'')+s;
}

class Timer 
{
    constructor()           { this.endTime=0; }
    Set(timeLeft=0)         { this.endTime = time + timeLeft; }
    Get()                   { return this.IsSet()? time - this.endTime : 1e9; }
    IsSet()                 { return this.endTime > 0; }
    UnSet()                 { this.endTime = 0; }
    Elapsed()               { return !this.IsSet() || time > this.endTime; }
}
    
class Vector2 
{
    constructor(x=0, y=0) { this.x = x; this.y = y; }
    Copy(v)               { this.x = v.x; this.y = v.y; return this; }
    Clone(s=1)            { return (new Vector2(this.x, this.y)).Multiply(s); }
	Add(v)                { (v instanceof Vector2)? (this.x += v.x, this.y += v.y) : (this.x += v, this.y += v); return this;  }
	Subtract(v)           { (this.x -= v.x, this.y -= v.y) ; return this;  }
	Multiply(v)           { (v instanceof Vector2)? (this.x *= v.x, this.y *= v.y) : (this.x *= v, this.y *= v); return this;  }
	Set(x, y)             { this.x = x; this.y = y; return this;  }
    AddXY(x, y)           { this.x += x; this.y += y; return this;  }
    Normalize(scale=1)    { let l = this.Length(); return l > 0 ? this.Multiply(scale/l) : this.Set(scale,y=0); }
    ClampLength(length)   { let l = this.Length(); return l > length ? this.Multiply(length/l) : this; }
    Rotate(a)             { let c=Math.cos(a);let s=Math.sin(a);return this.Set(this.x*c - this.y*s,this.x*s - this.y*c); }
    Round()               { this.x = Math.round(this.x); this.y = Math.round(this.y); return this; }
    Length()              { return Math.hypot(this.x, this.y ); }
    Distance(v)           { return Math.hypot(this.x - v.x, this.y - v.y ); }
    Angle()               { return Math.atan2(this.y, this.x); };
    Rotation()            { return (Math.abs(this.x)>Math.abs(this.y))?(this.x>0?2:0):(this.y>0?1:3); }   
    Lerp(v,p)             { return this.Add(v.Clone().Subtract(this).Multiply(p)); }
    DotProduct(v)         { return this.x*v.x+this.y*v.y; }
}

class Color
{
    constructor(r=0,g=0,b=0,a=1) { this.r=r;this.g=g;this.b=b;this.a=a; }
    Copy(c)                      { this.r=c.r;this.g=c.g;this.b=c.b;this.a=c.a; return this; }
    Clone(s=1)                   { return new Color(this.r*s, this.g*s, this.b*s, this.a*s); }
    //Add(c)                       { this.r+=c.r;this.g+=c.g;this.b+=c.b;this.a+=c.a; return this; }
    Subtract(c)                  { this.r-=c.r;this.g-=c.g;this.b-=c.b;this.a-=c.a; return this; }
    //Multiply(c)                  { (c instanceof Color)? (this.r*=c.r,this.g*=c.g,this.b*=c.b,this.a*=c.a) : (this.r*=c,this.g*=c,this.b*=c,this.a*=c); return this; } 
    SetAlpha(a)                  { this.a=a; return this; } 
    Lerp(c,p)                    { return c.Clone().Subtract(c.Clone().Subtract(this).Clone(1-p)); }
    RGBA()                       { return RGBA(this.r, this.g, this.b, this.a); }
}

///////////////////////////////////////////////////////////////////////////////
// game object

class GameObject 
{
    constructor(pos,tileX,tileY,size=.5,collisionSize=0,health=1) 
    { 
        this.pos = pos.Clone();
        this.tileX = tileX;
        this.tileY = tileY;
        this.size = new Vector2(size,size);
        this.collisionSize = collisionSize;
        this.health = health;
        this.healthMax = health;
        this.damageTimer = new Timer();
        this.lifeTimer = new Timer();
        this.lifeTimer.Set();
        this.acceleration = new Vector2();
        this.velocity = new Vector2();
        this.angle = 0;
        this.angleVelocity = 0;
        this.damping = .8;
        this.mirror = 0;
        this.height = 0;
        this.damageFlashTime = .5;
        this.differenceFlash = 1;
        
        gameObjects.push(this); 
    }
    
    Update() 
    {
        // apply accel
        this.velocity.Add(this.acceleration);
        
        // apply velocity
        let oldPos = this.pos;
        let newPos = this.pos.Clone();
        newPos.Add(this.velocity);
        
        // check collision
        let size = this.collisionSize;
        let clear = level.IsAreaClear(newPos,size,this);
        if (!clear)
        {
            // test which side we bounced off of (or both)
            let isClearX = level.IsAreaClear(new Vector2(newPos.x,oldPos.y),size);
            let isClearY = level.IsAreaClear(new Vector2(oldPos.x,newPos.y),size);
            if (!isClearX || isClearY)
            {
                newPos.x = oldPos.x;
                this.velocity.x *= -.5;
            }
            if (!isClearY || isClearX)
            {
                newPos.y = oldPos.y;
                this.velocity.y *= -.5;
            }
        }
        this.pos = newPos;
        
        // apply physics
        this.velocity.Multiply(this.damping);
        this.acceleration.Multiply(0);
        this.angle += this.angleVelocity;
    }
       
    Render() { DrawTile(this.pos,this.size,this.tileX,this.tileY,this.angle,this.mirror,this.height);}
    
    Heal(health)
    {
        if (this.IsDead())
            return 0;
        
        let startHealth = this.health;
        this.health = Min(this.health+health,this.healthMax);
        return this.health - startHealth;
    }
    
    Damage(damage) 
    {
        if (this.IsDead() || this.GetDamageTime() < .5)
            return 0;
            
        this.damageTimer.Set();
        let startHealth = this.health;
        this.health = Max(this.health-damage,0);
        if (!this.health)
            this.Kill();
            
        return startHealth - this.health;
    }
    
    ReflectDamage(direction){ return 0; }
    Accelerate(accel)       { this.acceleration.Add(accel); }
    GetLifeTime()           { return this.lifeTimer.Get(); }
    GetDamageTime()         { return this.damageTimer.Get(); }
    GetDamageFlashPercent() { return Clamp(1- this.GetDamageTime()/this.damageFlashTime,0,1); }
    IsTouching(object)      { return this.Distance(object) < object.collisionSize + this.collisionSize; }
    IsDead()                { return !this.health; }
    Kill()                  { this.health = 0; this.Destroy(); }
    Destroy()               { gameObjects.splice(gameObjects.indexOf(this), 1); }
    Distance(object)     
    {
        // get distance between objects accounting for height 
        let p1 = this.pos; let p2 = object.pos;
        return Math.hypot(p1.x - p2.x, p1.y - p2.y, this.height - object.height); 
    }
    CollideLevel(data,pos)
    { 
        if (!data.type)
            return 1;
    
        if (this.height > 1) // allow jumping over objects
            return 0;
    
        return data.object; 
    }
}

///////////////////////////////////////////////////////////////////////////////
// core engine

let savePrefix = "KBAP_"
let cameraScale = 1;
let cameraPos = new Vector2();
let time = 1;
let timeDelta = 1/60;
//let lastUpdate = 0;
//let timeBuffer = 0;
let shadowRenderPass = 0;
let hitRenderPass = 0;
let mainCanvasContext;
let tileMaskCanvas;
let tileMaskCanvasContext;
let hitCanvas;
let hitCanvasContext;
let levelCanvas;
let levelCanvasContext;
let mainCanvasSize = new Vector2();
let tileSize = 16;
let levelSize = 64;
let paused = 0;
let nextFrameMS = 0;

function EngineInit()
{
    mainCanvasContext = mainCanvas.getContext('2d');
    mainCanvasSize.Set(window.innerWidth/2,window.innerHeight/2);
    mainCanvas.width = mainCanvasSize.x;
    mainCanvas.height = mainCanvasSize.y;
    
    // create level canvas to cache level image and groun effects
    levelCanvas = document.createElement('canvas');
    levelCanvasContext = levelCanvas.getContext('2d');
    levelCanvas.display='none';
    levelCanvasContext.imageSmoothingEnabled = 0;

    // crate tile mask used for shadows and hit effects
    tileMaskCanvas = document.createElement('canvas');
    tileMaskCanvasContext = tileMaskCanvas.getContext('2d');
    tileMaskCanvas.display='none';
    tileMaskCanvas.width = tileImage.width*2;
    tileMaskCanvas.height = tileImage.height;
    
    // draw white mask sprites
    tileMaskCanvasContext.fillStyle='#FFF';
    tileMaskCanvasContext.fillRect(0,0,tileMaskCanvas.width,tileMaskCanvas.height);
    tileMaskCanvasContext.globalCompositeOperation = 'destination-atop';
    tileMaskCanvasContext.drawImage(tileImage,0,0);
    
    // draw black mask sprites
    tileMaskCanvasContext.globalCompositeOperation = 'source-over';
    tileMaskCanvasContext.drawImage(tileMaskCanvas,tileImage.width,0);
    tileMaskCanvasContext.globalCompositeOperation = 'difference';
    tileMaskCanvasContext.drawImage(tileMaskCanvas,tileImage.width,0);
}

function EngineUpdate(frameTime=0)
{
    requestAnimationFrame(EngineUpdate);

    if (paused = frameTime > 500 && !document.hasFocus())
    {
        // prevent stuck input if focus is lost
        mouseIsDown = mouseWasDown = 0;
        keyInputData.map(k=>k.wasDown=k.isDown=0);
    }
    
    // limit update rate to FPS
    if (frameTime < nextFrameMS)
        return;  // skip this cycle
    nextFrameMS = nextFrameMS + 1000 / 60;

    // update volume
    const settings = parent.OS13k.Settings();
    zzfx_v = settings.v;

    // fit canvas to window
    mainCanvasSize.Set(window.innerWidth/2,window.innerHeight/2);
    mainCanvas.width = mainCanvasSize.x;
    mainCanvas.height = mainCanvasSize.y;
    mainCanvasContext.imageSmoothingEnabled = 0;
    
    // get mouse world pos
    mousePosWorld.Copy(mousePos).Subtract(mainCanvasSize.Clone(.5)).Multiply(1/cameraScale*tileSize).Add(cameraPos);
    
    // main update
    if (!paused)
    {
        time += timeDelta
        Update();
        UpdateGameObjects();
    }
    
    // main render
    let SortGameObjects = (a,b)=> a.pos.y-b.pos.y;
    gameObjects.sort(SortGameObjects);
    PreRender();
    shadowRenderPass = 1;
    RenderGameObjects();
    shadowRenderPass = 0;
    RenderGameObjects();
    PostRender();
    
    // clear input
    mouseWasDown = mouseIsDown;
    keyInputData.map(k=>k.wasDown=k.isDown);
}

///////////////////////////////////////////////////////////////////////////////
// game object system

let gameObjects = [];
function ClearGameObjects()  { gameObjects = []; }
function UpdateGameObjects() { gameObjects.forEach(o=>o.Update()); }
function RenderGameObjects()
{ 
    gameObjects.forEach(o=>
    {
        o.Render();
        if (!shadowRenderPass)
        {
            // draw the hit flash overlay
            hitRenderPass = o.GetDamageFlashPercent();
            if (hitRenderPass)
            {
                if (o.differenceFlash)
                    mainCanvasContext.globalCompositeOperation = 'difference';

                o.Render();
                
                mainCanvasContext.globalCompositeOperation = 'source-over';
                hitRenderPass = 0;
            }
        }
    });
}

///////////////////////////////////////////////////////////////////////////////
// input

let mouseIsDown = 0;
let mouseWasDown = 0;
let keyInputData = [];
let mousePos = new Vector2();
let mousePosWorld = new Vector2();

oncontextmenu = function(e) { e.preventDefault(); }
onmousedown   = function(e) { mouseIsDown=1; }
onmouseup     = function(e) { mouseIsDown=0; }
onmousemove   = function(e) 
{ 
    let rect = mainCanvas.getBoundingClientRect();
    mousePos.Set
    ( 
        (e.clientX - rect.left) / rect.width,
        (e.clientY - rect.top) / rect.height
    ).Multiply(mainCanvasSize);
}
onkeydown = function(e) 
{ 
    keyInputData[e.keyCode]={isDown:1};
}
onkeyup = function(e) 
{ 
    keyInputData[e.keyCode].isDown=0;
}

function MouseWasPressed()  { return mouseIsDown && !mouseWasDown; }
function KeyIsDown(key)     { return keyInputData[key]? keyInputData[key].isDown : 0; }
function KeyWasPressed(key) { return KeyIsDown(key) && !keyInputData[key].wasDown; }
function ClearInput()       { keyInputData.map(k=>k.wasDown=k.isDown=0);mouseIsDown=mouseWasDown=0; }

///////////////////////////////////////////////////////////////////////////////
// rendering

let shadowAlpha      = .5;
let shadowSkew       = .7;
let shadowScale      = .7;
let renderTileShrink = .25; // shrink size of tile to fix bleeding on edges

function DrawScreenTile(x,y,size,tileX,tileY)
{
    mainCanvasContext.drawImage(tileImage,tileX*tileSize,tileY*tileSize,tileSize,tileSize, x-size, y-size, 2*size, 2*size);
}

function SetCanvasTransform(pos,size,angle=0,height=0)
{
    // create canvas transform from world space to screen space
    mainCanvasContext.save();
    let drawPos = pos.Clone();
    if (shadowRenderPass)
        drawPos.AddXY(-height*shadowSkew/2, -height*shadowScale/2);
    else
        drawPos.y -= height;
    drawPos.Subtract(cameraPos).Multiply(tileSize*cameraScale);
    drawPos.Add(mainCanvasSize.Clone(.5));
    mainCanvasContext.translate(drawPos.x|0, drawPos.y|0);
    
    let s = size.Clone(tileSize);
    if (shadowRenderPass)
        mainCanvasContext.transform(1,0,shadowSkew,shadowScale,-shadowSkew*cameraScale*s.x,cameraScale*(1-shadowScale)*s.y);
    if (angle)
        mainCanvasContext.rotate(angle);
    mainCanvasContext.scale(cameraScale,cameraScale);
}

function DrawTile(pos,size,tileX,tileY,angle=0,mirror=0,height=0)
{
    // render a tile at a world space position
    SetCanvasTransform(pos,size,angle,height);
    
    let image = tileImage;
    if (shadowRenderPass)
    {
        image = tileMaskCanvas;
        mainCanvasContext.globalAlpha *= shadowAlpha;
        tileX+=tileImage.width/tileSize; // shift over to shadow position
    }
    else if (hitRenderPass)
    {
        image = tileMaskCanvas;
        mainCanvasContext.globalAlpha *= hitRenderPass;
    }
    
    let s = size.Clone(2*tileSize);
    mainCanvasContext.scale(mirror?-s.x:s.x,s.y);
    mainCanvasContext.drawImage(image,
        tileX*tileSize+renderTileShrink,
        tileY*tileSize+renderTileShrink,
        tileSize-2*renderTileShrink,
        tileSize-2*renderTileShrink, -.5, -.5, 1, 1);
    mainCanvasContext.restore();
    mainCanvasContext.globalAlpha = 1;   
}

function DrawText(text, x, y, size,textAlign='center',lineWidth=1,color='#000',strokeColor='#FFF',context=mainCanvasContext)
{
    context.fillStyle=color;
    context.font = `900 ${size}px arial`
    context.textAlign=textAlign;
    context.textBaseline='middle';
    context.fillText(text,x,y);
    if (lineWidth)
    {
        context.lineWidth=lineWidth;
        context.strokeStyle=strokeColor;
        context.strokeText(text,x,y);
    }
}

///////////////////////////////////////////////////////////////////////////////
// tile level system

class LevelData
{
    constructor() 
    {
        // type: 0=solid, 1=grass, 2=sand
        // object: 0=none, 1=bush, 2=rock

        this.type = 0;
        this.tile = 0;
        this.rotation = 0;
        this.object = 0;
    }
    
    Clear() { this.type=this.object=0; }
    IsSolid() { return !this.type || this.object; }
}

class Level
{
    constructor()
    {
        levelCanvas.height=levelCanvas.width=levelSize*tileSize;
        this.data = [];
        for(let i = 0; i<levelSize*levelSize; i++)
            this.data[i] = new LevelData();
    }
    
    GetDataFromPos(pos) { return this.GetData(pos.x,pos.y); }

    GetData(x,y)
    {
        if (!IsArrayValid(x,y,levelSize))
            return new LevelData();
        return this.data[(x|0)+(y|0)*levelSize];
    }

    IsAreaClear(pos,size,gameObject=0)
    {
        // check if there is no collision in a given square area
        let y = pos.y;
        let x = pos.x;
        for(let yo = y - size; yo <= y + size; )
        {
            for(let xo = x - size; xo <= x + size;)
            {
                let p = new Vector2(Math.floor(xo)+.5,Math.floor(yo)+.5);
                let data = this.GetDataFromPos(p);
                if (gameObject)
                {
                    if (gameObject.CollideLevel(data,p))
                        return 0;
                }
                else if (data.IsSolid())
                   return 0;

                if (xo==x+size)
                    break;
                ++xo;
                if (xo > x+size)
                    xo = x+size;
            }

            if (yo==y+size)
                break;
            ++yo;
            if (yo > y+size)
                yo = y+size;
        }
        return 1;
    }

    FillCircleObject(pos,r,object) { this.FillCircleCallback(pos,r,d=>d.object=d.type?object:d.object); }
    FillCircleType(pos,r,type)     { this.FillCircleCallback(pos,r,d=>d.type=type); }
    
    FillCircleCallback(pos,r,callback)
    {
        // fill a circle of tiles using the provided callback
        for(let i=-r;i<=r;i++)
        {
            let h = (r**2-(i+.5)**2)**.5;
            for(let j=pos.y-h;j<pos.y+h;j++)
            {
                let x = pos.x+i|0;
                let y = j|0;
                if (!IsArrayValid(x,y,levelSize))
                    continue;
                    
                callback(this.GetData(x,y));
            }
        }           
    }

    ApplyTiling()
    {
        // set up tiles
        for(let y = 0; y<levelSize; y++)
        for(let x = 0; x<levelSize; x++)
        {
            // get neighbors
            let d = this.GetData(x,y);
            let dt = d.type;
            let dr = this.GetData(x+1,y).type==dt
            let dl = this.GetData(x-1,y).type==dt;
            let du = this.GetData(x,y-1).type==dt;
            let dd = this.GetData(x,y+1).type==dt;
            let neighbors = dr + dl + du + dd;
            
            let t = dt*8;
            let r = 0;
            if (dt<2)
            {
                // first 2 rows are tiled based on neighbor count
                t += neighbors;
                if (neighbors>=2)
                    t++;
                if (neighbors==1)
                {
                    if (dl) r = 1;
                    else if (du) r = 2;
                    else if (dr) r = 3;
                }
                else if (neighbors==2)
                {
                    if (dr && dl) t--, r = 1;
                    else if (du && dd) t--;
                    else if (dl && dd) r = 1;
                    else if (dl && du) r = 2;
                    else if (dr && du) r = 3;
                }
                else if (neighbors==3)
                {
                    if (!dr) r = 1;
                    else if (!dd) r = 2;
                    else if (!dl) r = 3;
                }
            }

            d.tile = t;
            d.rotation = r;
        }
        
        // add tile randomization
        for(let y = 0; y<levelSize; y++)
        for(let x = 0; x<levelSize; x++)
        {
            if (Rand() > .05)
                continue;
            
            let d = level.GetData(x,y);
            if (d.tile == 13)
            {
                d.tile++;
                d.rotation=RandInt(4);
            }
            if (d.tile == 16)
            {
                d.tile+=1;
                d.rotation=RandInt(4);
            }
        }
    }

    DrawEllipse(pos,size,color='#FFF',angle=0)
    {
        let s = new Vector2(1,1).Multiply(size).Multiply(tileSize);
        levelCanvasContext.beginPath();
        levelCanvasContext.ellipse(pos.x*tileSize,pos.y*tileSize,s.x,s.y,angle,0,7);
        levelCanvasContext.fillStyle=color;
        levelCanvasContext.fill();
    }

    DrawText(text, pos, size, textAlign='center',lineWidith=0, color='#000', strokeColor='#FFF')
    {
        DrawText(text, pos.x*tileSize, pos.y*tileSize, size,textAlign,lineWidith,color,strokeColor,levelCanvasContext);
    }

    DrawTileData(x,y)
    {
        x|=0;
        y|=0;
        let d = this.GetData(x,y);
        let tx = d.tile%8;
        let ty = (d.tile/8|0);
        let pos = new Vector2(x+.5,y+.5);
        this.DrawTile(pos, .5, tx, ty, d.rotation*PI/2);
        
        if (d.object)
        {
            tx = (d.object-1)%8;
            ty = 3+((d.object-1)/8|0);
            this.DrawTile(pos, .5, tx, ty);
        }
    }
    
    DrawTile(pos,size,tileX,tileY,angle=0)
    {
        let s = size * tileSize;
        levelCanvasContext.save();
        levelCanvasContext.translate(pos.x*tileSize,pos.y*tileSize);
        levelCanvasContext.rotate(angle);
        levelCanvasContext.drawImage(tileImage,tileX*tileSize,tileY*tileSize,tileSize,tileSize,-s,-s,2*s,2*s);
        levelCanvasContext.restore();
    }
    
    ClearBorder()
    {
        // set to solid around outside edge
        let w = levelSize;
        for(let i = 0; i<w; i++)
        {
            this.GetData(i,  0).Clear();
            this.GetData(i,w-1).Clear();
            this.GetData(0,  i).Clear();
            this.GetData(w-1,i).Clear();
        }
    }
    
    Redraw()
    {
        // cache to offscreen cavnas
        levelCanvas.width|=0;
        for(let y = 0; y<levelSize; y++)
        for(let x = 0; x<levelSize; x++)
             this.DrawTileData(x,y);
    }
    
    Render()
    {
        let pos = cameraPos.Clone(-cameraScale*tileSize).Add(mainCanvasSize.Clone(.5));
        mainCanvasContext.drawImage
        (
            levelCanvas, 
            pos.x|0, pos.y|0,
            cameraScale*levelCanvas.width|0, cameraScale*levelCanvas.height|0
        );
    }
}

///////////////////////////////////////////////////////////////////////////////
// particle system
 
class Particle
{
    constructor(emitter,pos,velocity,size,lifeTime,startColor,endColor)
    {
        this.emitter = emitter;
        this.pos = pos;
        this.velocity = velocity;
        this.size = size;
        this.lifeTime = lifeTime;
        this.startColor = startColor;
        this.endColor = endColor;
        this.lifeTimer = new Timer();
        this.lifeTimer.Set();
    }

    Update()
    {
        this.pos.Add(this.velocity.Multiply(.9));
        if (this.lifeTimer.Get() > this.lifeTime)
             this.emitter.particles.splice(this.emitter.particles.indexOf(this),1);
        
    }
    
    Render()
    {
        let p = Percent(this.lifeTimer.Get(), 0, this.lifeTime);
        let c = this.startColor.Clone().Lerp(this.endColor, p);
        c.a *= p<.1? p /.1 : 1; // fade in alpha
        mainCanvasContext.fillStyle=c.RGBA();
                
        let size = this.size * cameraScale * tileSize * Lerp(p,1,.5);
        let pos = this.pos.Clone()
            .Subtract(cameraPos)
            .Multiply(tileSize*cameraScale)
            .Add(mainCanvasSize.Clone(.5))
            .Add(-size);
        mainCanvasContext.fillRect(pos.x, pos.y, 2*size, 2*size);
    }
}

class ParticleEmitter extends GameObject
{
    constructor( pos, emitSize, particleSize, color1, color2 ) 
    {
        super(pos,0,0,emitSize);
        this.particleSize=particleSize;
        this.color1=color1.Clone();
        this.color2=color2.Clone();
        this.particles=[];
        this.emitTimeBuffer=0;
    }
    
    Update()
    {
        this.particles.forEach(particle=>particle.Update());
        
        if (this.GetLifeTime() <= .05)
        {
            let secondsPerEmit = 1/200;
            this.emitTimeBuffer += timeDelta;
            while (this.emitTimeBuffer > secondsPerEmit)
            {
                this.emitTimeBuffer -= secondsPerEmit;
                this.AddParticle();
            }
        }
        else if (!this.particles.length)
            this.Kill();
            
            
        super.Update();
    }
    
    Render() { this.particles.forEach(p=>p.Render()); }
    
    AddParticle()
    {
        this.particles.push
        (
            new Particle
            (
                this,
                this.pos.Clone().Add(RandVector(Rand(this.size.x))),
                RandVector(Rand(.2)),
                RandBetween(this.particleSize,2*this.particleSize),
                RandBetween(.5,1),
                RandColorBetween(this.color1,this.color2),
                RandColorBetween(this.color1,this.color2).SetAlpha(0)
            )
        );
    }
}


///////////////////////////////////////////////////////////////////////////////
// init

let startLevel=0;
let level;
let levelNumber;
let nextLevel;
let warpLevel=0;
let isFinalLevel;
let isStartLevel;
let levelTimer = new Timer();
let endLevelTimer = new Timer();
let levelExit;
let loadNextLevel;
let levelMaze = [];
let levelMazeSize = 4;
let levelColor = new Color();
let levelFrame;

let boss;
let player;
let playerData;
let playerStartPos;
let winTimer = new Timer();
let healthWarning = new Timer();
let buyTimer = new Timer();
let mainCanvas = c1;
let speedRunMode;
let speedRunTime=0;
let speedRunBestTime=0;
let coinSoundTimer = new Timer();

class PlayerData
{
    constructor()
    {
        this.health = 3;
        this.healthMax = 3;
        this.boomerangs = 1;
        this.bigBoomerangs = 0;
        this.coins = 0;
    }
}

function Init()
{
    EngineInit();
    mainCanvasContext.fillRect(0,0,mainCanvasSize.x, mainCanvasSize.y);

    Reset();
    NextLevel();
    EngineUpdate();
}

function Reset()
{
    // load local storage
    playerData = new PlayerData();
    if (localStorage[savePrefix+"coins"])
        playerData.coins = parseInt(localStorage[savePrefix+"coins"], 10);
    if (localStorage[savePrefix+"warp"])
        warpLevel = parseInt(localStorage[savePrefix+"warp"], 10);
    if (localStorage[savePrefix+"best"])
        speedRunBestTime = parseInt(localStorage[savePrefix+"best"], 10);
    nextLevel = startLevel;
}

function NextLevel()
{
    levelFrame = 0;
    levelNumber = nextLevel;
    nextLevel = (nextLevel+1)%11;

    if (levelNumber > OS13k.GetTrophy('Bounce Back','Warp Level'))
        OS13k.Trophy('🌀','Bounce Back', 'Warp Level', levelNumber)

    if (!speedRunMode && levelNumber>warpLevel)
        warpLevel = levelNumber;
    localStorage[savePrefix+"warp"] = warpLevel;
    
    isFinalLevel = levelNumber==10;
    isStartLevel = !levelNumber;
    
    if (isStartLevel)
        speedRunMode = 0; // reset speed run on start level
    
    InitLevel();
}

function InitLevel()
{
    winTimer.UnSet();
    cameraScale=2;
    StartTransiton();
    ClearGameObjects();
    endLevelTimer.UnSet();
    levelTimer.Set();
    levelExit = 0;
    boss = 0;
    if (!playerData.boomerangs && !playerData.bigBoomerangs)
        playerData.boomerangs=1; // prevent 0 boomerangs
    
    GenerateLevel();
    player = new Player(playerStartPos);
    
}

function SpawnPickups(pos, chance = 1, count=1)
{
    if (Rand()>chance)
        return;
     
    for(let i=0;i<count;++i)
    {
        let p = new Pickup(pos.Clone(), 
            RandInt(8)?
            (RandInt(20)?3:4): // is coin
            (RandInt(4)?0:1)  // is heart
        );
        if (count>1)
            p.velocity = RandVector(.1 + Clamp(i,3,30)*.03*Rand());
    }
}

function DestroyLevelObject(pos,bounceRock=1) // returns true if bounced
{
    let data = level.GetDataFromPos(pos);
    if (!data.IsSolid())
        return 0;

    let bounce = 1;
    let type = data.object;
    if (type==1 || type==2)
    {
        level.GetDataFromPos(pos).object = 0;
        level.DrawTileData(pos.x,pos.y);
        SpawnPickups(pos, .05);

        if (type==1)
        {
            // bush
            PlaySound(5);
            level.DrawEllipse(pos,RandBetween(.1,.15),RGBA(0,0,0,RandBetween(.3,.6)));
            bounce=0;
        }
        else
        {
            // rock
            PlaySound(14);
            for(let i=9;i--;)
                level.DrawEllipse(pos.Clone().Add(RandVector(.2)),RandBetween(.1,.2),RGBA(.2,.1,.05,RandBetween(.3,.6)));      
            bounce = bounceRock;
        }

        // particle effects
        new ParticleEmitter
        (
            pos, .5, .1,     // pos, emitter size, particle size
            type==1 ? new Color(.4,.8,.1,1) : new Color(.4,.2,.1,1),
            type==1 ? new Color(0,.1,0,1) : new Color(0,0,0,1)
        );
    }

    return bounce;
}

///////////////////////////////////////////////////////////////////////////////
// update/render

function Update()
{
    // save data
    ++levelFrame;
    if (!speedRunMode)
        localStorage[savePrefix+"coins"] = playerData.coins;
    if (!winTimer.IsSet() && !player.IsDead())
        speedRunTime += timeDelta;
    UpdateAudio();
    
    if ((player.IsDead() || winTimer.IsSet()) && KeyWasPressed(27))
        loadNextLevel = 2;
    if (endLevelTimer.IsSet() && endLevelTimer.Elapsed())
        loadNextLevel = 1;
    if (isFinalLevel)
        cameraScale = Max(cameraScale-.005,1); 
        
    if (isStartLevel)
    {
        // title screen
        let pos = new Vector2(8,3.7);
        let t = levelTimer.Get();
        let p = Percent(t,0,3.3)
        let b = Math.abs(3-4*p)/1.7;
        let c1 =`hsla(${t*99},99%,50%)`;
        level.DrawText('BOUNCE',   pos.Clone().AddXY(0,-b), 33*p,'center',2,'#000',c1);
        level.DrawText('BACK',     pos.Clone().AddXY(0,b+1.2), 33*p,'center',2,'#000',c1);

        if (levelFrame==200)
            level.DrawText('A JS13k 2019 Game',   new Vector2(8,9.5), 14);
        if (levelFrame==260)
            level.DrawText('By Frank Force',   new Vector2(8,10.5), 14);
        /*if (levelFrame==260) 
        {
            pos = new Vector2(8,7);
            level.DrawText('WASD = Move',   pos.AddXY(0, 3.5), 18);
            level.DrawText('Mouse = Aim',   pos.AddXY(0, h), 18);
            level.DrawText('Click = Throw', pos.AddXY(0, h), 18);
            level.DrawText('Space = Dodge', pos.AddXY(0, h), 18);
        }*/
    }
}

function PreRender()
{
    cameraPos.Copy(player.pos);
    mainCanvasContext.fillStyle=levelColor.RGBA();
    mainCanvasContext.fillRect(0,0,mainCanvasSize.x, mainCanvasSize.y);
    
    if (isStartLevel) // stars
    {
        // background starfield in start level
        mainCanvasContext.fillStyle='#999';
        for(let i=300;i--;)
            mainCanvasContext.fillRect((Math.sin(i*i)*1e9-time*(i+1e3)/50)%(mainCanvas.width+9)-9,i*9%mainCanvas.height,i%6+2,i%6+2);
    }
        
    level.Render();
}

function PostRender()
{  
    if (loadNextLevel)
    {
        if (loadNextLevel==2)
            Reset();
        loadNextLevel = 0;
        NextLevel();
    }
    
    UpdateTransiton();

    // hud
    let bigText = '';
    if (paused)
        bigText = '-paused-'
    if (winTimer.IsSet())
        bigText = 'You Win!';
    if (player.IsDead())
    {
        bigText = 'Game Over!'
        DrawText('Press Escape',mainCanvasSize.x/2, mainCanvasSize.y/2+80, 42);
    }  
    DrawText(bigText,mainCanvasSize.x/2, mainCanvasSize.y/2, 72, 'center', 2);
   
    {
        // hud
        let iconSize = 16;
        let y = iconSize;

        for(let i=0;i<player.healthMax;i++)
        {
            let t = 1;
            let s = iconSize;
            if (healthWarning.Get() < .5)
                s *= 1+Math.sin(2*PI*healthWarning.Get()/.5)*.2;
            if (player.health > i)
                t = player.health-i>=1?3:2;
            DrawScreenTile(iconSize+2*iconSize*i,y,s,t,5);
        }
    
        y += 2*iconSize;
        //if (playerData.boomerangs)
        {
            DrawScreenTile(iconSize,y,iconSize,0,5);
            DrawText(playerData.boomerangs, 34, y+2, 32, 'left');
        }
        if (playerData.bigBoomerangs)
        {
            DrawScreenTile(iconSize+60,y,iconSize,7,5);
            DrawText(playerData.bigBoomerangs, 34+60, y+2, 32, 'left');
        }
        //if (playerData.coins)
        {
            y += 2*iconSize;
            DrawScreenTile(iconSize,5*iconSize,iconSize,5,5);
            DrawText(playerData.coins, 34, y+2, 32, 'left');
        }
        
        if (speedRunMode)
        {
            let c = (player.IsDead() || winTimer.IsSet())? '#F00' : '#000';
            DrawText(FormatTime(speedRunTime), mainCanvas.width/2, 28, 40, 'center',1,c);
        }

        RenderMap();
    }
    
    // cursor
    mainCanvas.style.cursor='none'; 
    let mx = mousePos.x|0;
    let my = mousePos.y|0;
    let mw = 2;
    let mh = 15;
    //mainCanvasContext.rotate(time);
    //mainCanvasContext.fillStyle='#000'
    //mainCanvasContext.fillRect(-mw-mg,-mh-mg,mw*2+mg*2,mh*2+mg*2);
    //mainCanvasContext.fillRect(-mh-mg,-mw-mg,mh*2+mg*2,mw*2+mg*2);
    mainCanvasContext.globalCompositeOperation = 'difference';
    mainCanvasContext.fillStyle='#FFF'
    mainCanvasContext.fillRect(mx-mw,my-mh,mw*2,mh*2);
    mainCanvasContext.fillRect(mx-mh,my-mw,mh*2,mw*2);
    mainCanvasContext.globalCompositeOperation = 'source-over';
}

function MazeDataPos(pos)
{
    let cellRatio = levelMazeSize / levelSize;
    pos = pos.Clone(cellRatio);
    return (pos.x|0) + (pos.y|0) * levelMazeSize;
}

function RenderMap()
{
    if ((isStartLevel || isFinalLevel) )
        return;

    let iconSize = 16;
    let y = iconSize;
    let w = 24;
    let o = mainCanvasSize.x-levelMazeSize*w-10;

    y += 2*iconSize;
    if (!isStartLevel)
        DrawText('L-'+ levelNumber, o-10, 24, 32,'right');

    let cellWidth = levelSize / levelMazeSize;

    if (levelMaze[MazeDataPos(player.pos)])
        levelMaze[MazeDataPos(player.pos)] = -1; // mark room as visited

    mainCanvasContext.strokeStyle='#000';
    mainCanvasContext.lineWidth=2;

    // minimap
    mainCanvasContext.strokeRect(o,10,w*levelMazeSize,w*levelMazeSize);
    for(let y=levelMazeSize;y--;)
    for(let x=levelMazeSize;x--;)
    {
        let m = levelMaze[x+y*levelMazeSize];

        let c = '#0004';
        if (m>0)
            c = '#333';
        //if (m==2)
        //    c = '#0FF4';
        if (m==-1) 
            c = '#FFF'; // expo
        if (x == (player.pos.x / cellWidth | 0) && y == (player.pos.y / cellWidth | 0))
            c = '#F00';

        mainCanvasContext.fillStyle=c;
        mainCanvasContext.fillRect(o+x*w,10+y*w,w,w);
        if (m)
            mainCanvasContext.strokeRect(o+x*w,10+y*w,w,w);
    }
    
    //mainCanvasContext.globalCompositeOperation = 'difference';
    gameObjects.forEach(object=>
    {
        let r = object.radarSize;
        if (r && levelMaze[MazeDataPos(object.pos)]<0)
        {
            let p = object.pos.Clone(w/cellWidth).AddXY(o,10).Round();
            mainCanvasContext.fillStyle=object==player?'#FFF':'#000';
            mainCanvasContext.fillRect(p.x-r-1,p.y-r-1,2*r+2,2*r+2);
            mainCanvasContext.fillStyle=object==player?'#000':object.isEnemy?'#F00':'#FFF';
            mainCanvasContext.fillRect(p.x-r,p.y-r,2*r,2*r);
        }
    });
    //mainCanvasContext.globalCompositeOperation = 'source-over';
}

///////////////////////////////////////////////////////////////////////////////
// game objects

class MyGameObject extends GameObject
{
    constructor(pos,tileX=0,tileY=0,size=.5,collisionSize=0,health=1)
    {
        super(pos,tileX,tileY,size,collisionSize,health);
        this.bloodColor = new Color(.8,0,.05,.5);
        this.walkFrame=0;
        this.rotation=1;
        this.radarSize=1;
        this.isInvisible = 0;
        this.bloodAdditive = 0;
    }
    
    UpdateWalk()
    {
        // footprints
        let lastWalkFrame = this.walkFrame;
        this.walkFrame += 1.5*this.velocity.Length();
        if (lastWalkFrame%2 < 1 && this.walkFrame%2 >1 || this.walkFrame%2 < lastWalkFrame%2)
        {
            let isOnSand = this.IsOnSand();
            let angle = this.rotation * PI/2;
            let side = this.walkFrame%2 < lastWalkFrame%2? 1 : -1
            let offset = (new Vector2(0,side/8)).Rotate(angle);
            let footPos = this.pos.Clone().Add(offset);
            let c = isOnSand?'#4215':'#2223';
            let s = new Vector2(.2,isOnSand?.2:.1);
            if (isOnSand)
            {
                s.y*=RandBetween(1,1.5);
                s.x*=RandBetween(1,1.5);
            }
            footPos.y+=.3;
            level.DrawEllipse(footPos,s,c,angle);
        }
    }
    
    BloodSplat(scale=1,particles=1)
    {
        if (this.bloodAdditive)
            levelCanvasContext.globalCompositeOperation='screen';
        for(let i=30;i--;)
        {
            let pos = this.pos.Clone().Add(RandVector(Rand(scale*this.size.x)));
            let size = new Vector2(this.size.x*RandBetween(.2,.5),this.size.y*RandBetween(.2,.5))
            let angle = RandBetween(0,2*PI);
            level.DrawEllipse(pos,size.Multiply(scale),this.bloodColor.RGBA(),angle); 
        }  
        levelCanvasContext.globalCompositeOperation='source-over';
        
        if (particles)
        {
            let s = scale*this.size.x;
            let p = new ParticleEmitter
            (
                this.pos, s*.6, s*.2, // pos, emitter size, particle size
                this.bloodColor.Clone().SetAlpha(1), 
                this.bloodColor.Clone(this.bloodAdditive?3:.5).SetAlpha(1)
            );
        }
    }
    
    Kill()
    {
        this.BloodSplat();
        PlaySound(9);
        super.Kill();
    }
    
    Render()
    {
        if (this.isInvisible && !shadowRenderPass && !hitRenderPass)
            mainCanvasContext.globalAlpha= .1 + this.GetDamageFlashPercent();
        super.Render();
    }
    
    IsOnSand() { return level.GetDataFromPos(this.pos).type == 2; }
}
    
class Player extends MyGameObject
{
    constructor(pos) 
    {
        super(pos,0,4,.5,.4,playerData.healthMax);
        this.health = playerData.health;
        cameraPos.Copy(pos);
        this.boostTimer = new Timer();
        this.throwTimer = new Timer();
        this.inputTimer = new Timer();
        this.playerDamageTimer = new Timer();
        this.inputTimer.Set(-1);
        this.throwRotation = 0;
        this.posBuffer = [];
        this.boostWaitTime = 3;
        this.radarSize=2;
    }
    
    IsBoosting() { return !this.boostTimer.Elapsed(); }
    
    CollideLevel(data, pos)
    {
        if (this.IsBoosting())
            return DestroyLevelObject(pos);
        else
            return super.CollideLevel(data, pos);
    }
    
    IsIntro() { return (levelTimer.Get() < 1.5) }
    
    Update() 
    {
        playerData.health = this.health;
        if (this.IsDead() || endLevelTimer.IsSet() || this.IsIntro())
        {
            this.acceleration.Multiply(0);
            return;
        }
        
        if (this.health <= 1 && healthWarning.Get() > this.health)
        {
            healthWarning.Set();
            PlaySound(11);
        }

        let isOnSand = this.IsOnSand();
    
        // boomerang
        if (MouseWasPressed() && (playerData.boomerangs|| playerData.bigBoomerangs))
        {
            let isBig = 0;
            if (playerData.bigBoomerangs)
            {
                --playerData.bigBoomerangs;
                isBig = 1;
            }
            else
                --playerData.boomerangs;
            let b = new Boomerang(this.pos,isBig);
            this.throwRotation= b.Throw(this, mousePosWorld);
            this.throwTimer.Set(.4);
        }
    
        // movement
        let acceleration = new Vector2();
        if (KeyIsDown(65))
            acceleration.x -= 1,this.rotation=0;
        if (KeyIsDown(68))
            acceleration.x += 1,this.rotation=2;
        if (KeyIsDown(87))
            acceleration.y -= 1,this.rotation=3;
        if (KeyIsDown(83))
            acceleration.y += 1,this.rotation=1;

        if (!this.IsBoosting())
        {
            if (this.boostTimer.IsSet() && this.boostTimer.Get()>this.boostWaitTime)
            {
                this.boostTimer.UnSet();
                PlaySound(16);
            }
        
            this.posBuffer = [];
            if ((KeyWasPressed(32)||KeyWasPressed(16)) && !this.boostTimer.IsSet())
            {
                PlaySound(12);
                this.boostTimer.Set(.5);
            }
        }
        else
        {
            if (!acceleration.x && !acceleration.y)
                acceleration.Set(-1,0).Rotate(-this.rotation*PI/2);
        
            isOnSand = 0;
            this.damageTimer.Set();
            
            if (levelFrame%3==0)
                this.posBuffer.push(this.pos.Clone());
            if (this.posBuffer.length > 20)
                this.posBuffer.shift();
        }
        
        if (acceleration.x || acceleration.y)
        {
            acceleration.Normalize(.016*(isOnSand?.5:1));

            if (this.IsBoosting())
                acceleration.Multiply(2);

            this.Accelerate(acceleration);
            this.inputTimer.Set();
        }
        
        if (this.inputTimer.Get() > 1)
            this.walkFrame = 0;
             
        if (this.throwTimer.Elapsed() && !this.IsBoosting())
           this.UpdateWalk();
        
        super.Update();
    }
    
    Render()
    {
        if (endLevelTimer.IsSet())
            return;
    
        if (this.IsDead() || this.IsIntro() && isStartLevel)
        {
            this.tileX = 7;
            this.tileY = 3;
            super.Render();
            return;
        }   
        
        this.tileY = 4;
        if (this.rotation&1)
        {
            this.tileX = this.rotation==1?2:3;
            this.mirror = this.walkFrame%2|0;
            if (!this.throwTimer.Elapsed()||!this.boostTimer.Elapsed())
                this.tileX += 3;
            else if (this.inputTimer.Get() > 1 && this.rotation==1)
            {
                this.tileX = 7;
                this.mirror = (this.inputTimer.Get()/2|0)&1;
            }
        }
        else
        {
            this.mirror = this.rotation!=2;
            this.tileX = this.walkFrame%2|0;
            if (!this.throwTimer.Elapsed()||!this.boostTimer.Elapsed())
                this.tileX = 4;
        }
           
        let hit = hitRenderPass;
        if (!this.throwTimer.Elapsed())
        {
            this.rotation = this.throwRotation;
            if (this.rotation&1)
                this.mirror = this.rotation==1;
        }
        if (!shadowRenderPass && hit)
        {
            mainCanvasContext.globalCompositeOperation = 'screen';
            for(let i=this.posBuffer.length;i--;)
            {
                hitRenderPass = hit*(i/this.posBuffer.length + .01);
                DrawTile(this.posBuffer[i],this.size,this.tileX,this.tileY,this.angle,this.mirror,this.height);
            }
            hitRenderPass = hit;
            mainCanvasContext.globalCompositeOperation = 'difference';
        }
    
        let b = this.boostTimer.Get();
        if (!shadowRenderPass && b<this.boostWaitTime+.5)
        {
            hitRenderPass = b<this.boostWaitTime?b/this.boostWaitTime:Math.sin((b-this.boostWaitTime)*PI*4);
            DrawTile(this.pos,this.size.Clone(1.1),this.tileX,this.tileY,this.angle,this.mirror,this.height);
            hitRenderPass = hit;
        }
        
        super.Render();
        
        // draw boomerang on back
        if (!shadowRenderPass)
        if (playerData.boomerangs || playerData.bigBoomerangs)
        {
            let x = playerData.bigBoomerangs?7:0;
            if (this.rotation == 3)
                DrawTile(this.pos,this.size,x,5);
            if (this.rotation%2 == 0)
                DrawTile(this.pos.Clone().AddXY(-(this.rotation-1)*.2,0),this.size.Clone(new Vector2(.6,1)),x,5);
        }
    }
    
    Damage(damage) 
    {
        if (!this.playerDamageTimer.Elapsed())
            return 0;
    
        if (endLevelTimer.IsSet() || this.IsIntro() || winTimer.IsSet())
            return 0;
    
        let damageDone = super.Damage(damage);
        if (!damageDone)
            return 0;
            
        this.BloodSplat();
        PlaySound(1);
            
        this.playerDamageTimer.Set(1);
        return damageDone;
    }
    
    Kill()                  
    {  
        this.BloodSplat(2);
        PlaySound(2);
    }
}

///////////////////////////////////////////////////////////////////////////////

class Boomerang  extends MyGameObject
{
    constructor(pos,isBig=0) 
    {
        super(pos,isBig?7:0,5,.5,isBig?.45:.4);
            
        this.damping = .98;
        this.angle = 0;
        this.canDamageLevel = 1;
        this.heldPickup = 0;
        this.throwAccel = 0;
        this.throwFrames = 0;
        this.bounceObject = 0;
        this.isBig = isBig;
    }
    
    Throw(owner, targetPos)
    {
        PlaySound(7)
        this.throwFrames = this.isBig?9:8;
        this.throwAccel = targetPos.Clone().Subtract(owner.pos);
        this.throwAccel.Normalize(.04);
        this.angleVelocity = .5;
        this.height = this.angleVelocity/2;
        this.velocity = owner.velocity.Clone();
        return this.throwAccel.Rotation();
    }
    
    CollideLevel(data, pos)
    {
        if (data.object)
            this.damageTimer.Set();
        return DestroyLevelObject(pos,!this.isBig);
    }
    
    Update() 
    {
        if (this.throwFrames)
            this.throwFrames--;
    
        if (!this.angleVelocity)
        {
            this.radarSize=3;
            this.damageFlashTime = .8;
            this.differenceFlash = 0;
            if (this.heldPickup)
                this.heldPickup.isHeld=0;
            this.heldPickup=0;
            if (Rand() < .005 && this.damageTimer.Get() > 4*this.damageFlashTime)
                this.damageTimer.Set(-this.damageFlashTime/2); // sparkle
        }
        else
        {
            if (endLevelTimer.IsSet())
                endLevelTimer.Set(1); // wait for boomerang
        
            let a = this.GetLifeTime();
            if (!mouseIsDown || !this.throwFrames)
                this.throwAccel=0;
            else if (this.throwAccel)
                this.velocity.Add(this.throwAccel);
        
            this.angleVelocity -= .002;
            if (this.angleVelocity < .1)
            {
                this.angleVelocity -= .005;
                this.velocity.Multiply(.8);
                if (this.angleVelocity < 0)
                    this.angleVelocity = 0;
            }
                
            this.height = this.angleVelocity/2;
            if (!this.throwAccel && this.height > 0)
            {
                // pull to player
                let d = player.pos.Clone();
                d.Subtract(this.pos).Multiply(0.004 * this.angleVelocity);
                this.velocity.Add(d);
            }
            
            gameObjects.forEach(o=>
            {
                if (!this.isBig && o.isSmallPickup && o.GetLifeTime() > .5 && !o.isHeld && !this.heldPickup && o.IsTouching(this))
                {
                    o.isHeld = 1;
                    this.heldPickup = o;
                }
                else if ((o.isEnemy||o.isStore) && o.IsTouching(this))
                {
                    if (this.bounceObject == o || o.ReflectDamage(this.velocity))
                    {
                        if (this.bounceObject != o)
                        {
                            PlaySound(15);
                            this.bounceObject = o;
                            this.velocity.Multiply(-.4);
                            this.angleVelocity*=.4;
                            this.damageTimer.Set();
                            this.throwAccel=0;
                        }
                    }
                    else if (o.Damage(1+this.isBig))
                    {
                        if (!isStartLevel) // hack: dont push in hub
                            o.Accelerate(this.velocity.Clone(.5));
                        this.damageTimer.Set();
                    }
                }
            });
        }
        
        if ((!this.angleVelocity || this.GetLifeTime() > .5) && !player.IsDead() && player.Distance(this) < .6)
            this.Pickup();
        
        super.Update();
        
        if (this.heldPickup)
            this.heldPickup.pos.Copy(this.pos).AddXY(0,-.001);
    }
    
    Pickup()
    {
        PlaySound(6);
        if (this.isBig)
            playerData.bigBoomerangs++;
        else
            playerData.boomerangs++;
        player.throwTimer.Set(.3);
        player.throwRotation=this.pos.Clone().Subtract(player.pos).Rotation();
        this.Destroy();
    }
}

///////////////////////////////////////////////////////////////////////////////

class Pickup extends MyGameObject
{
    // type: 0=half, 1=whole, 2=container, 3=coin, 4=large coin
    // 5 small boomerang, 6 large boomerang
    
    constructor(pos, type=0) 
    { 
        super(pos,2+type,5,.5,.3); 
        this.type = type;
        this.timeOffset = Rand(9);
        this.isSmallPickup = type != 2;
        this.isHeld=0;
        this.differenceFlash = 0;
        this.damageFlashTime = .8;
        this.radarSize = this.isSmallPickup?1:3;
    }
    
    Update() 
    {
        if (Rand() < .005 && this.damageTimer.Get() > 4*this.damageFlashTime)
            this.damageTimer.Set(-this.damageFlashTime/2);  // sparkle
        
        this.height = .1+.1*Math.sin(2*time+this.timeOffset);
        if (!player.IsDead() && player.IsTouching(this))
            this.Pickup();
        else if (boss && boss.IsTouching(this))
        {
            PlaySound(14);
            this.Destroy();
        }
        
        super.Update();
    }
    
    Pickup()
    {
        if (this.type==2) // heart container
        {
            ++playerData.healthMax;
            player.healthMax = playerData.healthMax;
            player.Heal(1);
            PlaySound(4);
        }
        else if (this.type==3) // 1 coin
        {
            PlaySound(10);
            ++playerData.coins;
        }
        else if (this.type==4) // 5 coin
        {
            PlaySound(10);
            playerData.coins+=5;
        }
        else // heart
        {
            player.Heal(.5+ this.type/2)
            PlaySound(3);
        }

        if (playerData.coins >= 100)
            OS13k.Trophy('🤑', 'Bounce Back', '100 Coins')

        this.Destroy();
    }
}

///////////////////////////////////////////////////////////////////////////////

class Enemy extends MyGameObject
{
    constructor(pos,tileX=0,tileY=0,size=.5,collisionSize=0,health=1,big=0)
    { 
        super(pos,tileX,tileY,size,collisionSize,health); 
        this.isEnemy = 1
        this.spawnPickup = 1;
        this.bloodAdditive = 1;
        this.isBig = big;
        this.radarSize=big?2:1;
    }
    
    Damage(damage) 
    {
        let damageDone = super.Damage(damage);
        if (damageDone && !this.IsDead())
        {
            this.BloodSplat(.5);
            PlaySound(8);
        }
        
        return damageDone;
    }
    
    Update()
    {
        if (player.IsTouching(this))
        if (player.Damage(.5))
        {
            let accel = player.pos.Clone();
            accel.Subtract(this.pos).Normalize(.1);
            player.Accelerate(accel);
        }

        super.Update();
    }
    
    Kill()
    {
        super.Kill();
        
        // spawn portal if no enemies left
        if (!levelExit && !isFinalLevel && !player.IsDead())
        {
            if (!gameObjects.some(o=>o.isEnemy))
            {
                levelExit = new LevelExit(this.pos);
                if (!this.isBig)
                    this.spawnPickup = 0;
            }
        }

        {
            // spawn pickups
            let count = 1;
            if (this.isBig)
                count = RandIntBetween(3, 5);
            if (this.isInvisible)
                count = count * 2;
            SpawnPickups(this.pos, this.spawnPickup, count);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////

class SlimeEnemy extends Enemy
{
    constructor(pos,healthLevel,difficulty=1)
    { 
        let size = .25*healthLevel;
        super(pos,5+difficulty,0,size,size*.8,healthLevel*difficulty,healthLevel>3); 
        this.bloodColor = difficulty>1?new Color(1,0,.5,.5):new Color(0,.5,1,.5);
        this.randMoveTimer = new Timer();
        this.randAccel = new Vector2();
        this.spawnPickup = healthLevel == 1? difficulty/2 : 0;
        this.difficulty = difficulty;
        this.healthLevel = healthLevel;
        this.baseSize = size;
        this.damping = .9;
    }
    
    Update()
    {
        let playerDistance = player.pos.Distance(this.pos);
        if (playerDistance > 20)
            return;
        
        // draw additive trail
        levelCanvasContext.globalCompositeOperation='screen';
        let trailColor = this.bloodColor.Clone().SetAlpha(.05).RGBA();
        level.DrawEllipse(this.pos,(new Vector2(.6,.4)).Multiply(this.size),trailColor);
        levelCanvasContext.globalCompositeOperation='source-over';
     
        if (this.randMoveTimer.Elapsed())
        {
            this.randMoveTimer.Set(RandBetween(.5,1));
            this.randAccel = RandVector(1.3);
        }
    
        let accel = new Vector2();
        if (!player.IsDead() && playerDistance < 15)
            accel.Copy(player.pos)
                .Subtract(this.pos)
                .Normalize();
        accel.Add(this.randAccel)
            .Multiply(this.difficulty>1?.004:.003)
            .Multiply(this.IsOnSand()?.5:1);
        this.Accelerate(accel);
    
        // change shape as it moves
        let s = Math.sin(10 * this.GetLifeTime());
        let sx = .9+.1*(1-s);
        let sy = .9+.1*s;
        this.size.Set(this.baseSize*sx,this.baseSize*sy);
        
        super.Update();
    }
       
    Kill() 
    {
        if (this.healthLevel > 1)
        {
            for(let i=2;i--;)
            {
                let s = new SlimeEnemy(this.pos, this.healthLevel-1, this.difficulty);
                s.damageTimer.Set();
                s.isInvisible = this.isInvisible;
                s.velocity = this.velocity.Clone();
            }
        }
        
        super.Kill();
    }
}

///////////////////////////////////////////////////////////////////////////////

class JumpingEnemy extends Enemy
{
    constructor(pos,isBig=0)
    { 
        super(pos,2,2,isBig?1:.5,isBig?.8:.4,isBig?12:4,isBig); 
        this.landTimer = new Timer();
        this.jumpWaitTimer = new Timer();
        this.jumpWaitTimer.Set(RandBetween(1,3));
        this.zVelocity = 0;
        this.randOffset = new Vector2();
        this.bloodColor = new Color(1,.5,0,.1);
        this.speed = isBig?.012:.01;
    }
    
    Update()
    {
        let playerDistance = player.pos.Distance(this.pos);
        if (playerDistance > 20)
            return;
        
        if (this.jumpWaitTimer.Elapsed() && this.height <= 0)
        {
            this.zVelocity = RandBetween(.15,.2);
            if (this.isBig)
                 this.zVelocity *= 1.2;
            this.jumpWaitTimer.Set(RandBetween(1.5,3));
            //for(let i=-1;i<=1;i+=2)
            //    level.DrawEllipse(this.pos.Clone().AddXY(i/5,.2),new Vector2(.4*this.size,.5*this.size),'#1115',RandBetween(-.3,.3));
            this.randOffset = RandVector(RandBetween(0,1));
            this.landTimer.UnSet();
        }
    
        this.height += this.zVelocity;
        this.zVelocity -= .005;
        if (this.height <= 0)
        {
            if (!this.landTimer.IsSet())
            {
                this.landTimer.Set(.3);
                this.BloodSplat(.8,0);
            }
            this.height = this.zVelocity = 0;
        }
        else
        {
            let accel = new Vector2();
            if (!player.IsDead() && playerDistance < 15)
            {
                accel.Copy(player.pos)
                    .Subtract(this.pos)
                    .ClampLength(1)
                    .Add(this.randOffset);
            }
            else
                accel.Copy(this.randOffset);
            this.Accelerate(accel.Multiply(this.speed));
        }
    
        this.tileX = 2;
        if (this.jumpWaitTimer.Get() > -.25 || !this.landTimer.Elapsed())
            ++this.tileX;
            
        super.Update();
    }
}

///////////////////////////////////////////////////////////////////////////////

class ShieldEnemy extends Enemy
{
    constructor(pos, type=0, isBig=0)
    { 
        super(pos,4,2,isBig?1:.5,isBig?.8:.4,type?50:isBig?6:2,isBig); 
        this.moveTimer = new Timer();
        this.boostTimer = new Timer();
        this.damping=.8;
        this.bumped=0;
        this.type = type;
        this.moveReverse = 0;
        this.speed = isBig?.015:.012;
        if (type)
        {
            this.speed = .018;
            boss = this;
        }
        else
            this.bloodColor = new Color(.3,1,0,.5);
            
        this.bossIntro = this.type && !isStartLevel;
    }
    
    ReflectDamage(direction)
    { 
        if (this.damageTimer.Get() < .5)
            return 0;
    
        let d = new Vector2(1,0).Rotate(this.rotation*PI/2);
        let a = direction.Clone().Normalize().DotProduct(d);
        return this.type? (a > .4) : (a < -.4);
    }
    
    CollideLevel(data, pos)
    {
        let small = !this.isBig && !this.type;
        if (data.IsSolid())
        {
            if (small)
            {
                if (this.boostTimer.Elapsed()) // change direction if not boosting
                    this.rotation = (this.rotation+2)%4;
            }
            this.velocity.Multiply(0);
        }
        
        return DestroyLevelObject(pos, !this.type);
    }
    
    Damage(damage) 
    {
        if (this.type && player.IsDead())
            return 0;
    
        return super.Damage(damage);
    }
    
    Update()
    {
        let lifeTime = this.GetLifeTime();
        let isOnSand = !this.type && this.IsOnSand();
        let playerDistance = player.pos.Distance(this.pos);
        
        if (this.type && isStartLevel)
        {
            let d = this.pos.x - levelExit.pos.x;
            this.rotation = Math.abs(d) < .5? 1: 0;

            if (this.Distance(levelExit) < 1)
                this.Destroy();
        }
        else if (this.bossIntro)
        {
            if (this.pos.x>24)
            {
                this.pos.x = 24
                this.rotation = 3;
            }
            else
                this.rotation = 0;
        }
        else
        {
            if (playerDistance > 20 && !this.type)
                return;

            if (this.moveTimer.Elapsed() && this.boostTimer.Elapsed())
            {
                this.moveReverse = 0;
                if (!player.IsDead() && (playerDistance < 15 || this.type))
                {
                    let d = player.pos.Clone().Subtract(this.pos);
                    let r = d.Rotation();
                    if (!(r&1))
                        r=(r+2)%4; // hack: left/right is backwards
                    this.rotation = r;
                    
                    if (this.type)
                        this.moveReverse = Rand()<.5;
                    if (this.moveReverse)
                        this.rotation = (this.rotation+2)%4

                    if (Rand()<.2)
                    {
                        //this.damageTimer.Set();
                        this.boostTimer.Set(2);
                    }
                }
                else
                    this.rotation = RandInt(4);
                this.moveTimer.Set(RandBetween(.8,2));
            }
        }

        let moveAccel = new Vector2(this.speed*(isOnSand?.5:1),0).Rotate(this.rotation*PI/2);
        if (!this.boostTimer.Elapsed())
            moveAccel.Multiply((this.boostTimer.Get() < -1)?0:2);
        
        if (this.type && isStartLevel)
        {
            if (playerDistance > 10.5)
                moveAccel.Multiply(0);
        }
        else if (this.type)
        {
            // boss fight
            if (lifeTime > 10 && this.health < this.healthMax || lifeTime > 20 && playerDistance < 10 )
                this.bossIntro = 0;
        
            if (this.bossIntro)
            {
                if (playerDistance > 14)
                    moveAccel.Multiply(0);
                if (this.pos.y < 21)
                {
                    moveAccel.Multiply(0); // wait to get hit
                    this.rotation = 1;
                    this.walkFrame += .021;
                }
            }
            else
            {
                this.bossIntro = 0;
                if (this.size.x<2)
                {
                    this.size.AddXY(.005,.005);
                    this.collisionSize = this.size.x*.8;
                    moveAccel.Multiply(0);
                    this.walkFrame += .1;
                    if (levelFrame%10==0)
                        this.rotation = (this.rotation+1)%4;
                    moveAccel.Multiply(0);
                }
                else
                    this.size.Set(2,2);
            }
        }
        
        this.velocity.Add(moveAccel.Multiply(this.moveReverse?-1:1));
    
        if (this.rotation&1)
        {
            this.tileX = (this.rotation==1)?6:7;
            this.mirror = this.walkFrame%2|0;
        }
        else
        {
            this.mirror = this.rotation;
            this.tileX = 4 + (this.walkFrame%2|0);
        }
        
        if (this.type)
        {
            this.tileY=3;
            this.tileX-=2;
        }
        
        this.UpdateWalk();
        super.Update();
    }
    
    Kill()
    {
        super.Kill();
        
        if (this.type)
        {
            boss = 0;
            if  (isFinalLevel)
            {
                new Pickup(this.pos, 2);
                SpawnPickups(this.pos,1,40);
                winTimer.Set();
                localStorage[savePrefix+"warp"]=0;
                localStorage[savePrefix+"won"]=1;
                speedRunTime=speedRunTime|0;

                OS13k.Trophy('🏆', 'Bounce Back', 'You Win!');

                if (speedRunMode && (!speedRunBestTime || speedRunTime < speedRunBestTime))
                {
                    OS13k.Trophy('🏃‍♂️', 'Bounce Back', 'Speed Run Complete');

                    const trophyTime = OS13k.GetTrophy('Bounce Back','Speed Run Time');
                    if (!trophyTime || speedRunTime < trophyTime)
                        OS13k.Trophy('⏲️','Bounce Back','Speed Run Time', speedRunTime);

                    speedRunBestTime = speedRunTime;
                    localStorage[savePrefix+"best"]=speedRunBestTime;
                }
                PlaySound(2);
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////

class Store extends MyGameObject
{
    constructor(pos) 
    {
        super(pos,7,1,.5,.5);
        this.count = isStartLevel||isFinalLevel?3:2 + RandInt(2);
        let o = 1-this.count;
        for(let i=this.count;i--;)
        {
            let item = RandInt(4);
            if (isStartLevel || isFinalLevel)
                item = i+1;
            else
            {
                if (i==0)
                    item = RandIntBetween(0,1);
                else if (i==1)
                    item = RandIntBetween(2,3);
            }
            new StoreItem(pos.Clone().AddXY(i*2+o,0),item,this);
        }
            
        this.pos.y-=2;
        this.isStore = 1;
        level.FillCircleType(pos,3,1); // clear area
        level.FillCircleObject(pos,5,0); // clear area
    }
    
    Kill()
    {
        SpawnPickups(this.pos);
        super.Kill();
    }
    
    Update()
    {        
        // hack: draw carpet after being spawned
        if (this.GetLifeTime()<.1)
        {
            let p = this.pos.Clone().AddXY(0,2).Multiply(tileSize);
            let w = this.count*16;
            levelCanvasContext.fillStyle='#CCC';
            levelCanvasContext.fillRect(p.x-w-2,p.y-30-2,w*2+4,40+4);
            levelCanvasContext.fillStyle='#329';
            levelCanvasContext.fillRect(p.x-w,p.y-30,w*2,40);
        }
    
        this.mirror = player.pos.x<this.pos.x; // face player
        if (!buyTimer.Elapsed()) // jump on buy
        {
            let b = buyTimer.Get();
            this.height = -b*(.5-.5*Math.cos(6*PI*b))/2;
        }
        
        // check enemy hits
        gameObjects.forEach(o=>{if (o.isEnemy && o.IsTouching(this))this.Kill();}); 
        
        super.Update();
    }
}

class StoreItem extends MyGameObject
{
    constructor(pos,type,owner) 
    { 
        // 0 = whole heart
        // 1 = heart container
        // 2 = boomerang
        // 3 = big boomerang
        
        super(pos,type+3,5,.5,.2); 
        this.owner = owner;
        this.type = type;
        this.cost = 5;
        this.wasTouching=0;
        if (this.type == 1)
            this.cost = 50;
        if (this.type == 2)
        {
            this.cost = 40;
            this.tileX = 0;
        }
        if (this.type == 3)
        {
            this.cost = 90;
            this.tileX = 7;
        }
            
        if (!isStartLevel)
            this.cost *= RandBetween(.5,1.5);
        this.cost = Clamp(this.cost, 1, 99);
        this.cost |= 0;
    }
    
    Update()
    {
        if (!player.IsDead() && player.IsTouching(this))
        {
            if (!this.wasTouching)
                this.Pickup();
            this.wasTouching = 1;
        }
        else
            this.wasTouching = 0;
            
        if (this.owner && this.owner.IsDead())
            this.Destroy();
            
        super.Update();
    }
    
    Pickup()
    {
        if (this.cost>playerData.coins)
        {
            PlaySound(15);
            this.damageTimer.Set();
            return;
        }
        
        if (this.type < 2)
            (new Pickup(this.pos,this.type+1)).Pickup();
        else 
            (new Boomerang(this.pos,this.type == 3)).Pickup();
            
        buyTimer.Set(1);
        playerData.coins-=this.cost;
        this.Destroy();
    }
    
    Render()
    {
        if (!shadowRenderPass && !hitRenderPass)
        {
            SetCanvasTransform(this.pos.Clone().AddXY(0,-1), this.size);

            DrawText(this.cost,-6,0,14,'left',.5,this.GetDamageTime()<.5?"#F00":"#000");
            DrawScreenTile(-10,-1,4,5,5);

            mainCanvasContext.restore();
        }
        
        super.Render(); 
    } 
}

///////////////////////////////////////////////////////////////////////////////

class LevelExit extends MyGameObject
{
    constructor(pos,type=0) 
    { 
        super(pos,0,0,0,.5); 
        this.type=type; 
        this.radarSize=2;
        this.closeTimer = new Timer();
        this.pos.y+=.01;
    }
       
    Update() 
    {
        this.height =.1+.1*Math.sin(5*time);
        this.angleVelocity =.05/(this.size+.1); 
        
        let radius = this.size.x;
        if (this.type==1) // is opening rather then closing
        {
            if (levelFrame==60)
                PlaySound(13);
        
            radius = Max(0,1 - levelTimer.Get()/2);
            if (radius <= 0)
                this.Destroy();
        }
        else if (this.closeTimer.IsSet())
            radius = -this.closeTimer.Get();
        else if (this.GetLifeTime() < 1)
        {
            let t = this.GetLifeTime();
            radius = Min(t*2,1);
        }
        else if (!player.IsDead() && player.Distance(this) < 3 && player.boostTimer.Elapsed())
        {
            let a = this.pos.Clone().Subtract(player.pos);
            let l = a.Length();
            if (l < .5)
            {
                if (isStartLevel && this.type == 3)
                {
                    speedRunMode = 1; // start speed run mode
                    speedRunTime = 0;
                    playerData = new PlayerData();
                }
                PlaySound(13);
                endLevelTimer.Set(1);
                this.closeTimer.Set(1);
                if (this.type == 2)
                    nextLevel = warpLevel;
            }
            else
                player.velocity.Add(a.Normalize(.005/l));
        }
        
        radius = Max(0,radius);
        this.size.Set(radius,radius);
        
        super.Update();
    }
       
    Render() 
    {
        SetCanvasTransform(this.pos,this.size,this.angle,this.height);
        
        // draw wrap portal effect
        let color;
        for(let i=0;i<9;mainCanvasContext.stroke(),++i)
        {
            mainCanvasContext.beginPath();
            color=`hsla(${i*19+time*99},99%,${shadowRenderPass||i==8?0:50}%,${shadowRenderPass?.5:1})`;
            mainCanvasContext.lineWidth=i==8?1:2;
        
            mainCanvasContext.strokeStyle=color;
            for(let j=8;j--;)
            {
                let a=time-j*PI/3+5*Math.sin((i==8?i-1:i)+time*2)/19;
                mainCanvasContext.arc(0,0,2*i*this.size.x,a,a)
            }
        } 
        mainCanvasContext.lineWidth=1;  
        
        color=`hsla(${time*99},99%,${shadowRenderPass?0:50}%,${shadowRenderPass?.5:1})`;
        mainCanvasContext.strokeStyle=color;

        if (this.type > 1 && !shadowRenderPass  && !this.closeTimer.IsSet())
        {
            let text = (this.type == 2)? 'Warp '+warpLevel : 'Speed Run';
            DrawText(text,0,-24,14,'center',1,color,'#000');
            if (this.type == 3 && speedRunBestTime)
                DrawText('Best '+FormatTime(speedRunBestTime),0,-36,12,'center',1,color,'#000');
            
        }
        mainCanvasContext.restore();
    }
}

///////////////////////////////////////////////////////////////////////////////
// level builder
    
function GenerateMaze(cellCount)
{
    let size = levelMazeSize;
    let cells = [];
    cells.length = size*size;
    cells.fill(0);
    let GetCell=(x,y)=>cells[x+y*size];
    let SetCell=(x,y,v=1)=>cells[x+y*size]=v;
    let IsOpen=(x,y)=>(IsArrayValid(x,y,size)? cells[x+y*size] : 0);
    
    let IsEnd=(xo,yo)=>
    {
        let n = 0;
        n += IsOpen(xo+1,yo);
        n += IsOpen(xo-1,yo);
        n += IsOpen(xo,yo+1);
        n += IsOpen(xo,yo-1);
        return n<=1;
    }
    
    let CheckMove=(xo,yo,xd,yd)=>
    !(
        !IsArrayValid(xo+xd,yo+yd,size) || // must be valid cell
        IsOpen(xo+xd,yo+yd) ||             // must be solid

        // surrounding cells in that direction must be solid
        IsOpen(xo+xd*2,yo+yd*2) ||
        IsOpen(xo+xd*2+yd,yo+yd*2+xd) ||
        IsOpen(xo+xd*2-yd,yo+yd*2-xd) ||
        IsOpen(xo+xd+yd,yo+yd+xd) ||
        IsOpen(xo+xd-yd,yo+yd-xd)
    );
    
    // set start pos (it may change when generating the level)
    let xStart=RandInt(4);
    let yStart=RandInt(4);
    
    if (isStartLevel) // hub level
    {
        xStart=yStart=0;
        SetCell(0,0);
        SetCell(1,0);
    }
    if (isFinalLevel) // boss level
    {
        xStart=0;
        yStart=3;
        SetCell(0,3);
        SetCell(1,3);
        SetCell(2,3);
        SetCell(1,2);
        for(let i=4;i--;)
        for(let j=2;j--;)
            SetCell(i,j);
    }
    
    playerStartPos = new Vector2(xStart, yStart);
    if (isStartLevel || isFinalLevel)
        return cells;
    
    let x=xStart;
    let y=yStart;
    SetCell(x,y);
        
    // generate a maze
    let stack = [];
    let endCount = 0;
    for(let i=0; i<cellCount*1.5; ++i)
    {
        // check which neighbors are valid moves
        let neighbors = 0;
        if (CheckMove(x,y,-1,0))
            ++neighbors;
        if (CheckMove(x,y,1,0))
            ++neighbors;
        if (CheckMove(x,y,0,-1))
            ++neighbors;
        if (CheckMove(x,y,0,1))
            ++neighbors;
            
        if (neighbors && i!=cellCount && (i<cellCount || Rand() < .5))
        {  
            // pick a random neighbor to open
            let xd = 0;
            let yd = 0;
            let r=RandInt(neighbors);
            if (CheckMove(x,y,-1,0) && !r--)
                xd=-1,yd=0;
            else if (CheckMove(x,y,1,0) && !r--)
                xd=1,yd=0;
            else if (CheckMove(x,y,0,-1) && !r--)
                xd=0,yd=-1;
            else
                xd=0,yd=1;
                
            stack.push({x:x,y:y});
            SetCell(x+=xd,y+=yd);
        }
        else if (stack.length)
        {
            // track dead ends
            if (IsEnd(x,y))
                SetCell(x,y,2+endCount++);
            else if (Rand() < .5) // change up start pos
                playerStartPos.Set(x,y);
            
            // pop cell from stack and make current
            let c = stack.pop();
            x = c.x;
            y = c.y;
        }
        else
            break;
    }
    
    return cells;
}

function GenerateLevel()
{
    // randomize background color
    levelColor=new Color(Rand(.1),Rand(.1),Rand(.1));
    if (isStartLevel)
        levelColor=new Color(.1,0,.2);
    
    // loop incase level generation fails
    while(!GenerateLevelInternal()){}
}

function GenerateLevelInternal()
{
    level = new Level();
    ClearGameObjects();
    
    // generate maze and draw to level data
    levelMaze = GenerateMaze(levelNumber);
    for(let x=levelMazeSize;x--;)
    for(let y=levelMazeSize;y--;)
    {
        if (!levelMaze[x+y*levelMazeSize])
            continue;

        let pos = (new Vector2(x+.5,y+.5)).Multiply(levelSize/levelMazeSize);
        let radius = isFinalLevel?12:9;
        level.FillCircleType(pos,radius,1);
        for(let i=RandInt(4);i--;) // add extra randomness
            level.FillCircleType(pos.Clone().Add(RandVector(Rand(8))),RandBetween(2,6),1+RandInt(2));
    }
    
    // convert player pos to world pos
    playerStartPos.Add(.5).Multiply(levelSize/levelMazeSize);
    
    if (isFinalLevel)
    {
        // place a ton of objects everywhere
        let r = levelSize/levelMazeSize;
        for(let i=30;i--;)
            level.FillCircleObject(new Vector2(RandIntBetween(0,64),RandIntBetween(0,50)),RandIntBetween(4,14),1+RandInt(2));  
        level.FillCircleObject(playerStartPos,12,0);  
        level.FillCircleType(playerStartPos.Clone().AddXY(16,-20),12,1);
        level.FillCircleType(playerStartPos.Clone().AddXY(16,-14),12,1);

        // draw a heart
        let centerPos = new Vector2(24,18);
        level.FillCircleType(centerPos,9,2);
        level.FillCircleObject(centerPos,10,0);
        levelCanvasContext.fillStyle='#F00'
        levelCanvasContext.fillRect(0,0,mainCanvasSize.x,mainCanvasSize.y)
        levelCanvasContext.drawImage(tileImage,0,0);
        for(let x=16;x--;)
        for(let y=16;y--;)
        {
            let d = levelCanvasContext.getImageData(x+64, y+80, 1, 1).data;
            level.GetDataFromPos(centerPos.Clone().AddXY(x-8,y-7)).object=d[1]?2:d[0]?0:1;
        }
    }
    else if (isStartLevel)
    {
        // set up start level area
        level.FillCircleType(playerStartPos,8,1); // start on grass
        level.FillCircleType(playerStartPos.Clone().AddXY(16,0),7,1);
        level.FillCircleObject(playerStartPos.Clone().AddXY(8,-2),3,1); 
        level.FillCircleObject(playerStartPos.Clone().AddXY(8,2),3,1); 
    }
    else
    {
        // place random objects
        for(let i=levelMazeSize*levelMazeSize*4;i--;)
            level.FillCircleObject(new Vector2(RandIntBetween(0,64),RandIntBetween(0,64)),RandIntBetween(1,10),RandInt(3));  
        
        // clear player start
        level.FillCircleObject(playerStartPos,RandBetween(2,5),0);

        // spawn enemies
        let totalEnemyPower = levelNumber*5;
        let tries = 0;
        while(totalEnemyPower>0)
        {
            if (++tries>1e4)
                return 0;

            // pick random pos
            let pos = new Vector2(RandBetween(0,levelSize),RandBetween(0,levelSize));

            let m = levelMaze[MazeDataPos(pos)]
            if (!m || (m==2 && levelNumber>1))
                continue;

            // must not be near player
            if (pos.Distance(playerStartPos) < 15)
                continue;

            // must be clear
            if (tries > 500)
                level.FillCircleObject(pos,2,0); // clear area if necessary
            if (!level.IsAreaClear(pos,2))
                continue;

            let enemyPower = 0;
            let e;
            if (Rand() < .33 || levelNumber<=1) // slime
            {
                let healthLevel = RandIntBetween(1,3);
                if (Rand() < .1 && levelNumber > 5)
                    healthLevel = 4;
                
                let difficulty = levelNumber<5||Rand()<.5?1:2;
                if (difficulty == 2 && level < 8)   
                    healthLevel = Math.min(healthLevel, 3);

                e = new SlimeEnemy(pos,healthLevel,difficulty);
                enemyPower = difficulty*healthLevel;
            }
            else if (levelNumber != 3 && (Rand() < .5 || levelNumber<=2)) // jumper
            {
                let isBig = Rand() < .1 && levelNumber > 3;
                e = new JumpingEnemy(pos,isBig);
                enemyPower = isBig?6:2;
            }
            else // shielder
            {
                let isBig = Rand() < .1 && levelNumber > 4;
                e = new ShieldEnemy(pos,0,isBig);
                enemyPower = isBig?9:3;
            }
            if (levelNumber > 4 && Rand()<.1)
            {
                e.isInvisible = 1; // random invisible enemy
                enemyPower *= 2;
            }
                
            totalEnemyPower -= enemyPower;
        }
    }
    
    // spawn stores and other special objects
    if (isFinalLevel)
    {
        new Store(new Vector2(43,47));
        new ShieldEnemy(playerStartPos.Clone().Add(new Vector2(.5,0)), 1);
        new Pickup(new Vector2(24,19.5), 2);
    }
    else if (isStartLevel)
    {
        new Store(new Vector2(24,3.5));
        new ShieldEnemy(playerStartPos.Clone(), 1);
        new Pickup(playerStartPos.Clone().Add(new Vector2(16,0)), 2);
        levelExit = new LevelExit(new Vector2(24,13));
        
        if (warpLevel>1)
            new LevelExit(new Vector2(29.5,8),2); // warp
        if (localStorage[savePrefix+"won"])
            new LevelExit(new Vector2(29.5,13),3); // speed run
    }
    else
    {
        for(let x=levelMazeSize;x--;)
        for(let y=levelMazeSize;y--;)
        {
            let m = levelMaze[x+y*levelMazeSize];
            if (m==2 && levelNumber > 1)
            {
                let p = new Vector2(x+.5,y+.5).Multiply(levelSize/levelMazeSize);
                let d = p.Distance(playerStartPos);
                if (d>30&&Rand()<.3) // random powerup spawn
                {
                    if (Rand()>.5)
                        new Pickup(p, 2);
                    else
                        new Boomerang(p);  
                         
                    level.FillCircleType(p,RandIntBetween(2,4),1);
                    level.FillCircleObject(p,RandIntBetween(3,5),0); 
                }
                else
                    new Store(p);
            }
        }

        new LevelExit(playerStartPos,1);
    }
    
    // draw the level
    level.ClearBorder();
    level.ApplyTiling();
    level.Redraw();
    
    return 1;
}

///////////////////////////////////////////////////////////////////////////////
// level transition system

let transitionTimer = new Timer();
let transitionCanvas = c2;
let transitionCanvasContext = transitionCanvas.getContext('2d');
function StartTransiton()
{
    // copy main canvas to transition canvas
    transitionTimer.Set();
    transitionCanvas.width = mainCanvasSize.x;
    transitionCanvas.height = mainCanvasSize.y;
    transitionCanvasContext.drawImage(mainCanvas,0,0);
}

function UpdateTransiton()
{
    let transitionTime = transitionTimer.Get();
    if (transitionTime > 2)
        return;
        
    // render stored main canvas with circle transition effect
    mainCanvasContext.save();
    mainCanvasContext.beginPath();
    let r = transitionTime*mainCanvasSize.x/2;
    mainCanvasContext.arc(mainCanvasSize.x/2,mainCanvasSize.y/2,r,0,7);
    mainCanvasContext.lineWidth=8;
    mainCanvasContext.stroke();
    mainCanvasContext.beginPath();
    mainCanvasContext.rect(0,0,mainCanvasSize.x,mainCanvasSize.y);
    mainCanvasContext.arc(mainCanvasSize.x/2,mainCanvasSize.y/2,r,0,7);
    mainCanvasContext.clip('evenodd');
    mainCanvasContext.drawImage(transitionCanvas,0,0);
    mainCanvasContext.restore();
}

///////////////////////////////////////////////////////////////////////////////
// ZzFXmicro - Zuper Zmall Zound Zynth - MIT License - Copyright 2019 Frank Force
let zzfx_v=0;
let zzfx_x=0;
let zzfx=(e,f,a,b=1,d=.1,g=0,h=0,k=0,l=0)=>{if(!zzfx_x)return;let S=44100;a*=2*PI/S;a*=1+RandBetween(-f,f);g*=1E3*PI/(S**2);b=S*b|0;d=d*b|0;k*=2*PI/S;l*=PI;f=[];for(let m=0,n=0,c=0;c<b;++c)f[c]=e*zzfx_v*Math.cos(m*a*Math.cos(n*k+l))*(c<d?c/d:1-(c-d)/(b-d)),m+=1+RandBetween(-h,h),n+=1+RandBetween(-h,h),a+=g;e=zzfx_x.createBuffer(1,b,S);a=zzfx_x.createBufferSource();e.getChannelData(0).set(f);a.buffer=e;a.connect(zzfx_x.destination);a.start();return a}

let beatTimer = new Timer();
let beatCount = 0;
let lastNote;
function UpdateAudio()
{
    if (!zzfx_x || zzfx_x.state != 'running')
        return

    if (coinSoundTimer.IsSet() && coinSoundTimer.Elapsed())
    {
        PlaySound(10, 800)
        coinSoundTimer.UnSet();
    }

    if (!(isStartLevel || winTimer.IsSet()))
        return;
        
    // play music
    let scale = [-5,0,2,4,7,12,-5,-8];
    if (beatTimer.Elapsed())
    {
        ++beatCount;
        beatTimer.Set(.5);
        
        if (beatCount>15 && (!(beatCount&1) || RandInt(2)))
        {
            if (beatCount%8==0)
                lastNote = 1; // return to root note
            zzfx(.4,0,220*2**(scale[lastNote]/12), (RandInt(2)+1)/2, .05, 0, .4);
            lastNote = (lastNote + (RandInt(6)-2)+scale.length)%scale.length;
        }
        
        if (beatCount%2==0||beatCount&18||!RandInt(20))
        {
            if (beatCount%4==0)
                zzfx(.3,.2,1e3,.08,.05,.8,21,51); // ZzFX  highhat
            else
                zzfx(.7,.2,150,.04,.005,.1,1,.5,.15); // ZzFX 17553 kick
        }
    }
}

function PlaySound(sound, p=0)
{
    if (!zzfx_x)
    {
        // fix compatibility issues with old web audio
        const audioContext = new (window.AudioContext || webkitAudioContext);
        audioContext.Z = audioContext.createBufferSource;
        audioContext.createBufferSource =
        (s = audioContext.Z())=>
        (
            s.start = s.start || (t => audioContext.noteOn (t)),
            s.stop  = s.stop  || (t => audioContext.noteOff(t)),
            s
        );
    
        zzfx_x = audioContext;
    }  

    switch(sound)
    {
        case 1: // player hit
        zzfx(1,.1,4504,.3,.1,-30,.5,.5,.33); // ZzFX 36695
        break;
        
        case 2: // player die
        zzfx(.7,0,500,4,.01,-0.2,3,3,0); // ZzFX 23250
        break;
        
        case 3: // get heart
        zzfx(1,0,1504,.3,.17,1.7,.5,.4,.33); // ZzFX 36695
        break;
        
        case 4: // get heart container
        zzfx(1,0,805,1.1,.71,.5,1.5,.5);  // ZzFX 16886
        break;
        
        case 5: // boomerang cut
        zzfx(.3,.2,370,.2,.1,3.9,13,27,.12); // ZzFX 23473
        break;
        
        case 6: // boomerang catch
        zzfx(1,.1,0,.2,.23,2,.4,.6,.9); // ZzFX 20183
        break;
        
        case 7: // boomerang throw
        zzfx(1,.1,53,.2,.26,0,.1,7.5,.58); // ZzFX 24904
        break;
        
        case 8: // enemy hit
        zzfx(1,.2,370,.1,.23,4.5,2.8,27.4,.12); // ZzFX 23473
        break;

        case 9: // enemy kill
        zzfx(1,.2,1138,.2,.02,0,4,1.2,.1); // ZzFX 10015
        break;

        case 10: // coin
        if (!coinSoundTimer.IsSet())
            coinSoundTimer.Set(.05);
        zzfx(1,.01,800+p,.2,.05); // ZzFX 98600
        break;
        
        case 11: // low health
        zzfx(.4,.1,418,.1,.79,5,0,1.9,.74); // ZzFX 7364
        break;

        case 12: // boost
        zzfx(1,.1,319,.4,.08,6.6,3.2,2.6,.59); // ZzFX 79527
        break;

        case 13: // teleport
        zzfx(1,.1,7,1,.97,0,.6,21.7,.5); // ZzFX 60532
        break;

        case 14: // boomerang hit solid
        zzfx(.8,.1,70,.1,.23,4.5,2.8,27,.12); // ZzFX 23473
        break;

        case 15: // boomerang reflect
        zzfx(1,.1,800,.2,.02,-0.3); // ZzFX 14772
        break;

        case 16: // dodge recharge
        zzfx(1,.1,0,.1,.1,1,.1,100); // ZzFX 88949
        break;
    }
}

// load texture and kick off init
let tileImage = new Image();
tileImage.onload=_=>Init();
tileImage.src = 'bounceBack.png?1';

</script></body></html>