<head>
<title>OS13k - A tiny pseudo operating system for JS13k</title>
<meta charset=utf-8>
<style>
*    
{ 
    font-family:arial; 
    user-select:none;
}
body 
{ 
    margin:0;
    overflow:hidden;
    background:linear-gradient(#223,#322);
}
.taskbar
{
    position:absolute;
    display:flex;
    align-items:center;
    width:100%;
    height:44;
    background:linear-gradient(#777,#222);
    border:2px solid;
}
.icon
{
    margin:2;
    width:44;
    height:35;
    font-size:22;
    border:2px solid;
    display:flex;
    align-items:center;
    justify-content:center;
    text-shadow:1px 1px 2px #000;
    border-radius:9px;
    box-shadow:0px 0px 3px;
    background:linear-gradient(#eee,#444);
}
.title
{
    font-size:300;
    font-family:impact;
    color:#0002;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
}
.iconSelected { background:linear-gradient(#ff8,#fff); }
</style>
<template id=templateIcon>
<style>
:host
{
    position:absolute;
    display:flex;
    align-items:center;
    flex-direction:column;
    pointer-events:auto;
}
.icon
{
    width:64;
    height:64;
    font-size:42;
    background:linear-gradient(#fff,#777);
    border-radius:9px;
    box-shadow:4px 4px 5px;
    overflow:hidden;
    white-space:nowrap;
    pointer-events:none;
    display:flex;
    align-items:center;
    justify-content:center;
    text-shadow:2px 2px 4px #000;
}
.name
{
    position:absolute;
    top:70;
    text-align:center;
    font-size:17;
    color:#fff;
    text-shadow:2px 2px 5px #000;
}
.iconSelected { background:linear-gradient(#99f,#fff); }
</style>
</template>
<template id=templateWindow>
<style>
:host
{
    position:absolute;
    display:flex;
    flex-direction:column;
    box-shadow:9px 9px 9px;
    background:#000;
    border:2px solid;
    overflow:hidden;
    display:block;
}
.titleBar
{
    height:44;
    font-size:30;
    display:flex;
    align-items:center;
    justify-content:center;
    white-space:nowrap;
    overflow:hidden;
    background:linear-gradient(#999,#444);
}
.frame
{
    position:relative;
    width:100%;
    height:100%;
    border:none;
    background:#fff;
    overflow:hidden;
}
.name         
{
    width:100%; 
    cursor:grab; 
    display:flex; 
    align-items:center; 
    overflow:hidden;
}
.titleBarSelected { background:linear-gradient(#eee,#88f); }
.folder       { background:#222; }
#full,#reload { width:40; }
.close        { width:28; }
.full:hover   { background:#fff; }
.reload:hover { background:#ff0; }
.close:hover  { background:#f00; }
div svg       { width:100%; pointer-events:none; }
</style>    
<svg width=0 height=0>
    <symbol id=iconFull viewBox='0 0 10 10'>
        <rect stroke=#000 stroke-width=.7 fill=none x=1 y=2 width=8 height=6 />
    </symbol>
    <symbol id=iconReload viewBox='0 0 10 10'>
        <circle stroke=#000 stroke-width=.7 fill=none cx=5 cy=5 r=3 />
    </symbol>
    <symbol id=iconClose viewBox='0 0 10 10'>
        <path stroke=#000 d='M1 1L9 9M9 1L1 9' />
    </symbol>
</svg>
</template>
</head>
<body>
<div id=taskbar class=taskbar></div>
<div id=desktop></div>
<div class=title>OS13k</div>
<script src=desktop.js?3></script>
<script>

// Startup Program - uncomment and change to your file to open on start
//desktopLayout.unshift({src:'system/test.html'});

'use strict';

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs OS13k, OS13kIcon, OS13kWindow, OS13kTaskbarIcon, zzfx, zzfxV
// @js_externs _OS13k.Medal, _OS13k.KeyDirection, _OS13k.Speak
// @js_externs _OS13k.CreateShader, _OS13k.RenderShader, _OS13k.CreateCanvas
// @js_externs _OS13k.PlaySamples, _OS13k.PlaySeedSound, _OS13k.GetSeedSound
// @js_externs _OS13k.Random, _OS13k.randomSeed 
// @js_externs _OS13k.Clamp, _OS13k.Percent, _OS13k.Lerp
// @js_externs iframeContent.OS13k, iframeContent.OS13kStart, iframeContent.zzfx
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==

/////////////////////////////////////////////////////////////////////////////
// OS13k System

class _OS13k
{
    constructor()
    {
        // startup os13k
        this.randomSeed = Date.now();
        this.InitDesktop();
        setInterval(this.Update, 16);
    }
    
    InitDesktop()
    {
        const icon = {icon:'❌', name:'Close All'};
        taskbar.appendChild(this.taskbarIcon = new OS13kTaskbarIcon(desktop, icon));
        
        // add icons to desktop
        let x = 30;
        let y = 80;
        let open = 1;
        for (const icon of desktopLayout)
        {
            // set icon position
            icon.x = x;
            icon.y = y;
            x += iconGridSizeX;
            
            // create icon
            const os13kicon = new OS13kIcon(icon);
            desktop.appendChild(os13kicon);
            open && os13kicon.Open(open = 0);
        }
    }
    
    Update()
    {
        // listen for change in active element
        // this happens when clicking on an iframe
        const activeElement = document.activeElement;
        if (this.lastActiveElement != activeElement)
        {
            // set focus to new active element
            activeElement.Focus && activeElement.Focus();
            this.lastActiveElement = activeElement;
        }
    }
    
    KeyDirection(keyCode)
    {
        // get direction from wasd or arrow keys
        let x = 0;
        let y = 0;
        if (keyCode == 87 || keyCode == 38) y += 1; // up
        if (keyCode == 83 || keyCode == 40) y -= 1; // down
        if (keyCode == 68 || keyCode == 39) x += 1; // right
        if (keyCode == 65 || keyCode == 37) x -= 1; // left
        return {x, y}
    }
    
    Medal(gameName, medalName='', difficulty=0)
    {
        // todo: show popup and unlock medal
    }
    
    PlaySeedSound(seed, lengthScale=1, volume=1, randomness=.05)
    {
        // set random seed
        this.randomSeed = seed;
        const R=()=> this.Random();
        
        // randomize sound length
        lengthScale /= 2;
        const attack  = R()**3*lengthScale;
        const sustain = R()**3*lengthScale;
        const release = R()**3*lengthScale;
        const length  = attack + sustain + release;
        
        // create random sound
        return zzfx(...
        [
           volume,                              // volume
           randomness,                          // randomness
           R()**2*2e3,                          // frequency
           attack,                              // attack
           sustain,                             // sustain
           release,                             // release
           R()*5|0,                             // shape
           R()**2*3,                            // shapeCurve
           (R()<.5) * R()**3*99*(R()<.5?-1:1),  // slide
           (R()<.5) * R()**3*99*(R()<.5?-1:1),  // deltaSlide
           (R()<.5) * R()**2*1e3*(R()<.5?-1:1), // pitchJump
           R()**2 * length,                     // pitchJumpTime
           (R()<.5) * R() * length,             // repeatTime
           (R()<.5) * R()**4,                   // noise
           (R()<.5) * R()**3*9*(R()<.5?-1:1),   // modulation
           (R()<.5) * R()**4,                   // bitCrush
           (R()<.5) * R()**3/2,                 // delay
        ]);
    }
    
    PlaySamples(samples, sampleRate=44100)
    {
        // init web audio
        if (!this.audioContext)
        {
            this.audioContext = new (AudioContext || webkitAudioContext);
            this.audioContext.Z = this.audioContext.createBufferSource;
            this.audioContext.createBufferSource =
            (s = this.audioContext.Z())=>
            (
                s.start = s.start || s.noteOn,
                s.stop  = s.stop  || s.noteOff,
                s
            );
        }
    
        // play raw audio sample data
        const buffer = this.audioContext.createBuffer(1, samples.length, sampleRate);
        const source = this.audioContext.createBufferSource();
        buffer.getChannelData(0).set(samples);
        source.buffer = buffer;
        source.connect(this.audioContext.destination);
        source.start();
        return source;
    }
    
    Speak(text) { speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }
    
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');

        // create a simple pass through vertex shader
        const vertexShader = x.createShader(x.VERTEX_SHADER);
        x.shaderSource(vertexShader,
            '#version 300 es\n' +
            'in vec4 p;' +
            'void main()' +
            '{gl_Position=p;}');
        x.compileShader(vertexShader);
        
        // create vertex buffer that is a big triangle
        const vertexBuffer = x.ARRAY_BUFFER;
        x.bindBuffer(vertexBuffer,x.createBuffer());
        x.bufferData(vertexBuffer,new Int8Array([-3,1,1,-3,1,1]),x.STATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0,2,x.BYTE,0,0,0); // 2D vertex
        
        // check vertex shader for errors
        //if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
        //    throw x.getShaderInfoLog(vertexShader);
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(x.FRAGMENT_SHADER)
        const shaderProgramCode = 
            '#version 300 es\n' +
            'precision mediump float;' +
            'uniform float iTime;' +
            'uniform vec4 iMouse;' +
            'uniform vec3 iResolution;' +
            'uniform sampler2D iChannel0;' +
            'const float pi=' + Math.PI + ';' +
            'const float e='  + Math.E  + ';' +
            'out vec4 outColor;\n' +
            code +
            '\nvoid main()' +
            '{mainImage(outColor,gl_FragCoord.xy);' +
            'outColor.a=1.;}';
        x.shaderSource(pixelShader, shaderProgramCode)
        x.compileShader(pixelShader);

        // check pixel shader for errors
        if (!x.getShaderParameter(pixelShader, x.COMPILE_STATUS))
            throw x.getShaderInfoLog(pixelShader);

        // create texture
        x.bindTexture(x.TEXTURE_2D, x.createTexture());
        x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.LINEAR);
        x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL, 1); 
        
        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    RenderShader(canvas, shaderProgram, time=0)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // set uniforms
        const uniformLocation=name=>x.getUniformLocation(shaderProgram, name);
        x.uniform3f(uniformLocation('iResolution'), canvas.width, canvas.height, 1);
        x.uniform1f(uniformLocation('iTime'), time);
        x.uniform1i(uniformLocation('iChannel0'), 0);
        
        // render shader
        x.viewport(0, 0, canvas.width, canvas.height);
        x.drawArrays(x.TRIANGLE_FAN, 0, 3);
        
        // set texture to previous frame
        x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, x.RGBA, x.UNSIGNED_BYTE, canvas);
    }
    
    // math functions
    Clamp(a, min=0, max=1) { return Math.min(Math.max(a, min),max); }
    Percent(v, a, b)       { return b-a? this.Clamp((v-a)/(b-a), 0, 1) : 0; }
    Lerp(p, a, b)          { return a + this.Clamp(p, 0, 1) * (b-a); }
    Random(max=1, min=0)
    {
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= this.randomSeed << 13;
        this.randomSeed ^= this.randomSeed >> 17;
        this.randomSeed ^= this.randomSeed << 5;
        return this.Percent(Math.abs(this.randomSeed) % 1e9 / 1e9, min, max);
    }
}; // _OS13k

/////////////////////////////////////////////////////////////////////////////
// OS13k Desktop

desktop.Focus=()=>
{
    // deavtivate window and icons
    activeWindow && activeWindow.SetActive(activeWindow = 0);
    selectedIcon && selectedIcon.SetActive(selectedIcon = 0);
    selectedTaskbarIcon && selectedTaskbarIcon.SetActive(selectedTaskbarIcon = 0);
    this.focus();
}

desktop.MouseDown=()=>desktop.Focus();

/////////////////////////////////////////////////////////////////////////////
// OS13kTaskbarIcon

let selectedTaskbarIcon;

class OS13kTaskbarIcon extends HTMLElement
{
	constructor(window, icon)
    {
		super();
        
        // create icon
        this.window = window;
        this.className = 'icon';
        this.innerHTML = '<div style=pointer-events:none>' + icon.icon;
        this.title = icon.name + (icon.title ? '\n' + icon.title : '');
    }
    
    MouseDown()
    {
        // focus on window
        this.window.Focus();
        if (this.window == desktop)
        {
            // close all windows
            const closeWindows = [];
            for( const c of desktop.children)
                c.Close && closeWindows.push(c);
            for( const w of closeWindows)
                w.Close();
                
            // reset window open position
            windowOpenPositionX = 99;
            windowOpenPositionY = 200;
        }
    }
    
    SetActive(active=1)
    {
        // unselect old icon and set style
        selectedTaskbarIcon && selectedTaskbarIcon.SetActive(selectedTaskbarIcon = 0);
        selectedTaskbarIcon = this;
        this.className = 'icon' + (active ? ' iconSelected' : '');
    }
} // OS13kTaskbarIcon

customElements.define('os13k-taskbar-icon', OS13kTaskbarIcon);

/////////////////////////////////////////////////////////////////////////////
// OS13kIcon

let selectedIcon;
const iconGridSizeX = 99;
const iconGridSizeY = 130;

class OS13kIcon extends HTMLElement
{
	constructor({x, y, name, icon, src, width=720, height=405, author, folder, allowMultiple, showReload})
    {
		super();
        
        // set icon defaults
        src = src || '';
        name = name || src.split('.')[0];
        icon = icon || (name[0] ? name[0].toUpperCase() : '' );
        
        // set icon data
        this.name = name;
        this.icon = icon;
        this.src = src;
        this.style.left = x;
        this.style.top = y;
        this.windowWidth = width;
        this.windowHeight = height;
        this.author = author;
        this.folder = folder;
        this.allowMultiple = allowMultiple;
        this.showReload = showReload;
        author && (this.title = 'By ' + author);
        
        // check for special extensions
        const extension = src? src.split('.')[1] : '';
        this.isDweet = extension == 'dweet';
        this.isShader = extension == 'shader';
        (this.isDweet || this.isShader) && (this.showReload = 1);
        
        // create shadow root
		this.shadow = this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = templateIcon.innerHTML;
        
        // create icon
        const iconElement = this.iconElement = document.createElement('div');
        iconElement.className = 'icon';
        iconElement.innerHTML = icon;
        this.shadowRoot.appendChild(iconElement);
        
        // create name
        const nameElement = document.createElement('div');
        nameElement.className = 'name';
        nameElement.innerHTML = name;
        this.shadowRoot.appendChild(nameElement);
    }
    
    Open()
    {
        if (!this.window)
        {
            // create the window
            const window = new OS13kWindow(this);
            if (!this.allowMultiple)
                this.window = window;
            desktop.appendChild(window);
        }
        
        // set focus to window
        this.window.Focus();
    }
    
    MouseDown()
    {
        // focus on icon window if it exists
        const parent = this.parentElement && this.parentElement.offsetParent;
        parent.Focus ? parent.Focus() : desktop.Focus();
        
        // set active
        this.SetActive();
    }
    
    SetActive(active=1)
    {
        // unselect old icon and set style
        selectedIcon && selectedIcon.SetActive(selectedIcon = 0);
        selectedIcon = this;
        this.iconElement.className = 'icon' + (active ? ' iconSelected' : '');
    }
} // OS13kIcon

customElements.define('os13k-icon', OS13kIcon);

/////////////////////////////////////////////////////////////////////////////
// OS13kWindow

let activeWindow;
let activeWindowZ = 0;
let windowOpenPositionX = 99;
let windowOpenPositionY = 200;

class OS13kWindow extends HTMLElement
{
	constructor(icon)
    {
		super();
        
        // set icon data
        this.icon = icon;
        
        // create taskbar icon
        this.taskbarIcon = new OS13kTaskbarIcon(this, icon);
        taskbar.appendChild(this.taskbarIcon);
        
        // set window position
        this.style.left = windowOpenPositionX;
        this.style.top = windowOpenPositionY;
        ((windowOpenPositionY += 46) > 400) && (windowOpenPositionY = 200);
        ((windowOpenPositionX += 46) > 1e3) && (windowOpenPositionX = 99);
        
        // create shadow root
		this.shadow = this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = templateWindow.innerHTML;
        
        // create title bar
        const titleBar = this.titleBar = document.createElement('div');
        titleBar.className = 'titleBar';
        titleBar.style.maxWidth = icon.windowWidth;
        this.shadowRoot.appendChild(titleBar);
        
        // create title bar name
        const titleBarName = document.createElement('div');
        titleBarName.className = titleBarName.id = 'name';
        titleBarName.innerHTML = 
            '<div style=pointer-events:none>' +
            '&nbsp;<span style="text-shadow:2px 2px 3px #000">' + 
            icon.icon + '</span>&nbsp;' +
            icon.name +
            (icon.author ? ' - ' + icon.author : '');
        titleBar.appendChild(titleBarName);
        
        if (!icon.folder)
        {
            // full screen icon
            const titleBarIconFull = document.createElement('div');
            titleBarIconFull.className = titleBarIconFull.id = 'full';
            titleBarIconFull.title = 'Full Screen';
            titleBarIconFull.innerHTML = '<svg><use href=#iconFull>';
            titleBar.appendChild(titleBarIconFull);
        }
        if (icon.showReload)
        {
            // reload icon
            const titleBarIconReload = document.createElement('div');
            titleBarIconReload.className = titleBarIconReload.id = 'reload';
            titleBarIconReload.title = 'Reload';
            titleBarIconReload.innerHTML = '<svg><use href=#iconReload>';
            titleBar.appendChild(titleBarIconReload);
        }
        
        // close icon
        const titleBarIconClose = document.createElement('div');
        titleBarIconClose.className = titleBarIconClose.id = 'close';
        titleBarIconClose.title = 'Close';
        titleBarIconClose.innerHTML = '<svg><use href=#iconClose>';
        titleBar.appendChild(titleBarIconClose);
        
        // create thin black line below title bar
        const titleBarGap = document.createElement('div');
        titleBarGap.style.height = 2;
        this.shadowRoot.appendChild(titleBarGap);

        // create content wrapper
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'frame folder';
        contentWrapper.style.width = icon.windowWidth;
        contentWrapper.style.height = icon.windowHeight;
        this.contentWrapper = contentWrapper;
        this.shadowRoot.appendChild(contentWrapper);
        
        // open the icon
        this.icon = icon;
        if (icon.folder)
        {
            // add icons to folder
            let x = 30;
            let y = 30;
            for (const folderIcon of icon.folder)
            {
                folderIcon.x = x;
                folderIcon.y = y;
                if ((x += iconGridSizeX) > icon.windowWidth-90)
                {
                    // wrap icons
                    x = iconGridSizeX/4;
                    y += iconGridSizeY;
                }
                contentWrapper.appendChild(new OS13kIcon(folderIcon));
            }
            
            // set focus
            this.Focus();
        }
        else if (icon.src)
        {
            // create iframe
            const iframe = this.iframe = document.createElement('iframe');
            iframe.className = 'frame';
            iframe.style.display = 'none';
            iframe.src = icon.src;
            contentWrapper.style.background = '#000';
            contentWrapper.appendChild(iframe);
        
            // load frame
            iframe.onload=e=>
            {
                // set up iframe          
                const iframeContent = this.iframeContent = e.target.contentWindow;

                // try to pass OS13k to iframe
                iframeContent.OS13k = OS13k;
                iframeContent.zzfx = zzfx;
                const fullscreen = document.fullscreenElement;
                iframeContent.innerWidth = fullscreen? innerWidth : icon.windowWidth;
                iframeContent.innerHeight = fullscreen? innerHeight : icon.windowHeight;
                iframeContent.oncontextmenu=e=>e.preventDefault();
                iframeContent.OS13kStart && iframeContent.OS13kStart();

                // check for extensions
                if (this.icon.isDweet || this.icon.isShader)
                {
                    // create full body canvas
                    const iframeDocument = iframeContent.document;
                    const iframeText = iframeDocument.body.innerText;
                    iframeDocument.body.innerHTML = 
                        '<canvas id=c width=1920 height=1080 style=' +
                        'width:100%;background:#' +
                        (this.icon.isDweet ? 'fff' : '000') +'>';
                    iframeDocument.body.style = 
                        'background:#000;' +
                        'overflow:hidden;' +
                        'margin:0;' +
                        'display:flex;' +
                        'align-items:center';

                    // create dweet
                    this.icon.isDweet && iframeContent.eval(
                        'u=t=>{' + iframeText + '};' +
                        'x=c.getContext`2d`;' +
                        'S=Math.sin;' +
                        'C=Math.cos;' +
                        'T=Math.tan;' +
                        'R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;' +
                        'loop=t=>requestAnimationFrame(loop,' +
                            'document.hasFocus()&&' +
                            'u((60*(frame++/60)-frame-1|0?frame-1:frame)/60));' +
                        'loop(frame=0)');

                    // create shader
                    this.icon.isShader && iframeContent.eval(
                        'g=c.getContext`webgl2`;' +
                        'x=y=z=w=0;' +
                        'onmousemove=e=>e.buttons&&(x=e.x,y=c.height-e.y);' +
                        'onmousedown=e=>(z=e.x,w=c.height-e.y);' +
                        'onmouseup=e=>z=w=0;' +
                        'loop=t=>requestAnimationFrame(loop,' +
                            'document.hasFocus()&&(' +
                            'c.width=innerWidth,' + 
                            'c.height=innerHeight,' + 
                            'g.uniform4f(g.getUniformLocation(s,"iMouse"),x,y,z,w),' +
                            'OS13k.RenderShader(c,s,t/1e3)));' + 
                        'loop(s=OS13k.CreateShader(c,`' + iframeText + '`))');
                }
                
                // show iframe and set focus
                iframe.style.display = '';
                this.Focus();
            }
        }
    }
    
    MouseDown(id)
    {
        // check for title bar buttons
        (id == 'name')   && (selected = this);
        (id == 'full')   && this.FullScreen();
        (id == 'reload') && this.Reload();
        (id == 'close')  && this.Close();
        this.Focus();
    }
    
    Close()
    {
        // destroy window
        this.icon.window = 0;
        this.taskbarIcon.remove();
        this.remove();
    }
    
    Reload()
    {
        // hide iframe and reload it
        this.iframe.style.display = 'none';
        this.iframeContent.location.reload();
    }
    
    Focus()
    {
        // set focus
        this.iframeContent ? this.iframeContent.focus() : desktop.Focus();
        this.SetActive();
    }
    
    SetActive(active=1)
    {
        if (active)
        {
            // deactivate old window
            if (activeWindow && activeWindow != this)
                activeWindow.SetActive(0);
                
            // move z to top and display
            this.style.zIndex = ++activeWindowZ;
            this.style.display = '';
        }
        
        // set titlebar style
        this.titleBar.className = 'titleBar' + (active ? ' titleBarSelected' : '');
        
        // set active
        activeWindow = active && this;
        
        // deactivate icon
        selectedIcon && selectedIcon.SetActive(selectedIcon = 0);
        this.taskbarIcon.SetActive(1);
    }
    
    FullScreen()
    {
        // set fullscreen
        const fullScreenElement = this.contentWrapper;
        if (fullScreenElement.webkitRequestFullScreen)
            fullScreenElement.webkitRequestFullScreen();
        else if (fullScreenElement.mozRequestFullScreen)
            fullScreenElement.mozRequestFullScreen();
    }
} // OS13kWindow

customElements.define('os13k-window', OS13kWindow);

/////////////////////////////////////////////////////////////////////////////
// Input

let selected;
let seletOffsetX;
let seletOffsetY;

onmousedown=e=>
{
    // prevent getting stuck
    if (selected)
        return onmouseup(e);
    e.preventDefault();
    
    // save selected offset
    const rect = e.target.getBoundingClientRect();
    seletOffsetX = e.x - rect.left;
    seletOffsetY = e.y - rect.top;
    
    // mouse down event
    if (e.target.MouseDown)
    {
        const originalTarget = e.originalTarget || e.path[0];
        e.target.MouseDown(originalTarget.id)
        if (originalTarget != e.target && originalTarget.MouseDown)
            originalTarget.MouseDown();
    }
    else
        desktop.MouseDown();
    
    if (selected)
    {
        // set grabbing mode
        document.body.style.cursor = 'grabbing';
        desktop.style.pointerEvents = 'none';
    }
}

onmouseup=e=>
{
    // allow pointer events and reset cursor
    desktop.style.pointerEvents = '';
    document.body.style.cursor = '';
        
    // release selected
    selected = 0;
}

onmousemove=e=>
{
    if (selected)
    {
        // clamp to window
        const rect = selected.getBoundingClientRect();
        const x = OS13k.Clamp(e.x - seletOffsetX, 130-rect.width, innerWidth-99);
        const y = OS13k.Clamp(e.y - seletOffsetY, 46, innerHeight-48);
        
        // update selected position
        selected.style.left = x;
        selected.style.top = y;
    }
}

ondblclick=e=>
{
    // open icon
    const target = e.originalTarget || e.path[0];
    target.Open && target.Open();
}

// disable context menu
oncontextmenu=e=>e.preventDefault();

/////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth 

let zzfxV  = .3; // volume
const zzfx =     // play zzfx sound
(
    volume        = 1, 
    randomness    = .05,
    frequency     = 220,
    attack        = 0,
    sustain       = 0,
    release       = .1,
    shape         = 0,
    shapeCurve    = 1,
    slide         = 0, 
    deltaSlide    = 0, 
    pitchJump     = 0, 
    pitchJumpTime = 0, 
    repeatTime    = 0, 
    noise         = 0,
    modulation    = 0,
    bitCrush      = 0,
    delay         = 0,

    // locals
    PI2 = Math.PI*2,
    sampleRate = 44100,
    random = r => r*2*Math.random()-r,
    sign = v => v>0?1:-1,
    startSlide = slide *= 500 * PI2 / sampleRate**2,
    startFrequency = frequency *= (1 + random(randomness)) * PI2 / sampleRate,
    modPhase = sign(modulation) * PI2/4,
    b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, d=.5,
    length, buffer
) =>
{
    // init parameters
    attack = 99 + attack * sampleRate | 0;
    sustain = sustain * sampleRate | 0;
    release = release * sampleRate | 0;
    delay = delay * sampleRate | 0;
    deltaSlide *= 500 * PI2 / sampleRate**3;
    length = attack + sustain + release + delay;
    modulation *= PI2 / sampleRate;
    pitchJump *= PI2 / sampleRate;
    pitchJumpTime = pitchJumpTime * sampleRate;
    repeatTime = repeatTime * sampleRate;

    // generate waveform
    for(; i < length;b[i++] = s)
    {
        if (++c>bitCrush*100)                            // bit crush
        {
            c = 0;
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation - modPhase);    // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
                Math.sin((s%PI2)**3) :                   // 4 noise
                Math.max(Math.min(Math.tan(s),1),-1):    // 3 tan
                1-(2*s/PI2%2+2)%2:                       // 2 saw
                1-4*Math.abs(Math.round(s/PI2)-s/PI2):   // 1 triangle
                Math.sin(s);                             // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * zzfxV * (                      // envelope
                i < attack ? i/attack :                  // attack
                i < attack + sustain ? 1 :               // sustain
                i < length - delay ?                     // post release
                1 - (i - attack - sustain)/release : 0); // release
                
            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i-delay]/2) : s;
        }

        t += 1 + random(noise);             // noise
        tm += 1 + random(noise);            // modulation noise
        frequency += slide += deltaSlide;   // frequency slide

        if (j && ++j > pitchJumpTime)       // pitch jump
        {
            frequency += pitchJump;         // apply pitch jump
            startFrequency += pitchJump;    // also apply to start
            j = 0;                          // reset pitch jump time
        };

        if (repeatTime && ++r > repeatTime) // repeat
        {
            frequency = startFrequency;     // reset frequency
            slide = startSlide;             // reset slide
            r = 1;                          // reset repeat time
            j = j || 1;                     // reset pitch jump time
        }
    }
    
    return OS13k.PlaySamples(b);
}

/////////////////////////////////////////////////////////////////////////////
// Start OS13k!

const OS13k = new _OS13k;

</script>