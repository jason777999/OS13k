<title>OS13k - A tiny pseudo operating system for JS13k</title>
<link rel=icon type=image/x-icon href='favicon.png?1'/>
<meta charset=utf-8>
<meta name=viewport content='width=device-width,initial-scale=1,user-scalable=0'>
<style>
*
{
    user-select:none;
    font-family:arial;
}
body
{
    margin:0;
    background:linear-gradient(#223,#322);
    overflow:hidden;
    touch-action:none;
}
.taskbar
{
    position:absolute;
    width:100%;
    z-index:10000;
    background:linear-gradient(#999,#444);
    border:2px solid;
    display:flex;
}
.taskbarIcon
{
    margin:5;
    width:44;
    height:35;
    font-size:22;
    border-radius:9px;
    box-shadow:0px 0px 3px;
    text-shadow:1px 1px 2px #000;
    background:linear-gradient(#fff,#333);
    border:2px solid;
    display:flex;
    align-items:center;
    justify-content:center;
}
.folder
{
    z-index:20000;
    box-shadow:5px 5px 9px;
    border:2px solid;
    background:linear-gradient(#fff,#777);
    position:absolute;
}
.icon
{
    color:'red';
    pointer-events:auto;
    height:18;
    padding:4;
    white-space:nowrap;
    display:flex;
    align-items:center;
}
.menu
{
    position:absolute;
    z-index:20000;
    border:2px solid;
    visibility:hidden;
    display:flex;
    flex-direction:column;
    background:#000;
}
.iconActive                { background:linear-gradient(#fff,#44f); }
.taskbarIconActive         { background:linear-gradient(#ff8,#fff); }
.taskbarIcon:hover         { background:linear-gradient(#fff,#44f); }
.taskbarIconActive:hover   { background:linear-gradient(#ff8,#44f); }
.title
{
    height:100%;
    color:#0002;
    font-family:impact;
    font-weight:900;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:20vw;
}
</style>
<template id=template>
<style>
:host
{
    box-shadow:5px 5px 9px;
    border:2px solid;
    background:#000;
    display:flex;
    flex-direction:column;
    overflow:hidden;
    position:absolute;
}
.titleBar
{
    height:44;
    font-size:26;
    background:linear-gradient(#eee,#888);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    white-space:nowrap;
}
.titleBarActive
{
    background:linear-gradient(#eee,#88f);
}
.frame
{
    width:100%;
    height:100%;
    border:none;
    background:#000;
    overflow:hidden;
    background:#fff;
}
.name
{
    width:100%;
    cursor:grab;
    overflow:hidden;
}
.codeDisplay
{
    height:99;
    resize:none;
    background:#000;
    color:#fff;
    display:none;
    border:1px solid #fff;
}
.reload,
.full,
.code         { width:40; }
.close        { width:28; }
.help:hover   { background:#0ff; }
.code:hover   { background:#0f0; }
.full:hover   { background:#fff; }
.reload:hover { background:#ff0; }
.close:hover  { background:#f00; }
div svg       { width:100%; pointer-events:none; }
</style>
<svg width=0 height=0>
<symbol id=icon-code viewBox='0 0 10 10'>
    <path stroke=#000 stroke-width=.7 fill=none d='M5 2L8 8L2 8L5 2L8 8'/>
<symbol id=icon-full viewBox='0 0 10 10'>
    <rect stroke=#000 stroke-width=.7 fill=none x=1 y=2 width=8 height=6 />
<symbol id=icon-reload viewBox='0 0 10 10'>
    <circle stroke=#000 stroke-width=.7 fill=none cx=5 cy=5 r=3 />
<symbol id=icon-close viewBox='0 0 10 10'>
    <path stroke=#000 d='M1 1L9 9M9 1L1 9'/>
</template>
<div id=desktop>
<div id=programsFolder style=position:absolute></div>
<div id=taskbar class=taskbar></div>
<div id=menu class=menu></div>
<div class=title>OS13k
<script src=programs.js?7></script>
<script>

// load test programs if there are none found
if (typeof programs == 'undefined')
    programs = [{src:'system/test.html'},{src:'dweets/underwaterCavern.dweet.js'}];

'use strict';

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs OS13k, OS13kFolder, OS13kIcon, OS13kWindow, OS13kTaskbarIcon
// @js_externs zzfx, zzfxV
// @js_externs _OS13k.Medal, _OS13k.KeyDirection, _OS13k.Speak
// @js_externs _OS13k.CreateShader, _OS13k.RenderShader, _OS13k.CreateCanvas
// @js_externs _OS13k.PlaySamples, _OS13k.PlaySeed, _OS13k.GetSeedSound
// @js_externs _OS13k.Random, _OS13k.randomSeed 
// @js_externs _OS13k.Clamp, _OS13k.Percent, _OS13k.Lerp
// @js_externs iframeContent.OS13k, iframeContent.OS13kStart, iframeContent.zzfx
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==

/////////////////////////////////////////////////////////////////////////////
// OS13k System

class _OS13k
{
	constructor(icon, element = 0)
    {
        // init web audio
        this.audioContext = new (AudioContext || webkitAudioContext);
        this.audioContext.Z = this.audioContext.createBufferSource;
        this.audioContext.createBufferSource =
        (s = this.audioContext.Z())=>
        (
            s.start = s.start || s.noteOn,
            s.stop  = s.stop  || s.noteOff,
            s
        );
        
        this.randomSeed = Date.now();
    }
    
    KeyDirection(keyCode)
    {
        // get direction from wasd or arrow keys
        let x = 0, y = 0;
        (keyCode == 87 || keyCode == 38) && ++y; // up
        (keyCode == 83 || keyCode == 40) && --y; // down
        (keyCode == 68 || keyCode == 39) && ++x; // right
        (keyCode == 65 || keyCode == 37) && --x; // left
        return {x, y}
    }
    
    Medal(gameName, medalName='', difficulty=0)
    {
        // todo: show popup and unlock medal
    }
    
    PlaySeed(seed, lengthScale=1, volume=1, randomness=.05)
    {
        // set random seed
        this.randomSeed = seed;
        const R=()=> this.Random();
        
        // warm up random generator
        R(R(R()));
        
        // randomize sound length
        lengthScale /= 2;
        const attack  = R()**3*lengthScale;
        const sustain = R()**3*lengthScale;
        const release = R()**3*lengthScale;
        const length  = attack + sustain + release;
        
        // create random sound
        return zzfx(...
        [
           volume,                              // volume
           randomness,                          // randomness
           R()**2*2e3,                          // frequency
           attack,                              // attack
           sustain,                             // sustain
           release,                             // release
           R()*5|0,                             // shape
           R()**2*3,                            // shapeCurve
           (R()<.5) * R()**3*99*(R()<.5?-1:1),  // slide
           (R()<.5) * R()**3*99*(R()<.5?-1:1),  // deltaSlide
           (R()<.5) * R()**2*1e3*(R()<.5?-1:1), // pitchJump
           R()**2 * length,                     // pitchJumpTime
           (R()<.5) * R() * length,             // repeatTime
           (R()<.5) * R()**4,                   // noise
           (R()<.5) * R()**3*9*(R()<.5?-1:1),   // modulation
           (R()<.5) * R()**4,                   // bitCrush
           (R()<.5) * R()**3/2,                 // delay
        ]);
    }
    
    PlaySamples(samples, sampleRate=44100)
    {
        // play raw audio sample data
        const buffer = this.audioContext.createBuffer(1, samples.length, sampleRate);
        const source = this.audioContext.createBufferSource();
        buffer.getChannelData(0).set(samples);
        source.buffer = buffer;
        source.connect(this.audioContext.destination);
        source.start();
        return source;
    }
    
    Speak(text) { speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }
    
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');

        // create a simple pass through vertex shader
        const vertexShader = x.createShader(x.VERTEX_SHADER);
        x.shaderSource(vertexShader,
            '#version 300 es\n' +
            'in vec4 p;' +
            'void main()' +
            '{gl_Position=p;}');
        x.compileShader(vertexShader);
        
        // create vertex buffer that is a big triangle
        const vertexBuffer = x.ARRAY_BUFFER;
        x.bindBuffer(vertexBuffer,x.createBuffer());
        x.bufferData(vertexBuffer,new Int8Array([-3,1,1,-3,1,1]),x.STATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0,2,x.BYTE,0,0,0); // 2D vertex
        
        // check vertex shader for errors
        //if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
        //    throw x.getShaderInfoLog(vertexShader);
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(x.FRAGMENT_SHADER)
        const shaderProgramCode = 
            '#version 300 es\n' +
            'precision mediump float;' +
            'uniform float iTime;' +
            'uniform vec4 iMouse;' +
            'uniform vec3 iResolution;' +
            'uniform sampler2D iChannel0;' +
            'out vec4 outColor;\n' +
            code +
            '\nvoid main()' +
            '{mainImage(outColor,gl_FragCoord.xy);' +
            'outColor.a=1.;}';
        x.shaderSource(pixelShader, shaderProgramCode)
        x.compileShader(pixelShader);

        // check pixel shader for errors
        if (!x.getShaderParameter(pixelShader, x.COMPILE_STATUS))
            throw x.getShaderInfoLog(pixelShader);

        // create texture
        x.bindTexture(x.TEXTURE_2D, x.createTexture());
        x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.LINEAR);
        x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL, 1); 
        
        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    RenderShader(canvas, shaderProgram, time=0)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // set uniforms
        const uniformLocation=name=>x.getUniformLocation(shaderProgram, name);
        x.uniform3f(uniformLocation('iResolution'), canvas.width, canvas.height, 1);
        x.uniform1f(uniformLocation('iTime'), time);
        x.uniform1i(uniformLocation('iChannel0'), 0);
        
        // render shader
        x.viewport(0, 0, canvas.width, canvas.height);
        x.drawArrays(x.TRIANGLE_FAN, 0, 3);
        
        // set texture to previous frame
        x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, x.RGBA, x.UNSIGNED_BYTE, canvas);
    }
    
    // math functions
    Clamp(a, min=0, max=1) { return Math.min(Math.max(a, min),max); }
    Percent(v, a, b)       { return b-a? this.Clamp((v-a)/(b-a), 0, 1) : 0; }
    Lerp(p, a, b)          { return a + this.Clamp(p, 0, 1) * (b-a); }
    Random(max=1, min=0)
    {
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= (this.randomSeed||-1) << 13;
        this.randomSeed ^= this.randomSeed >> 17;
        this.randomSeed ^= this.randomSeed << 5;
        return this.Percent(Math.abs(this.randomSeed) % 1e9 / 1e9, min, max);
    }
}; // _OS13k

/////////////////////////////////////////////////////////////////////////////
// OS13k Desktop

let selected, seletOffsetX, seletOffsetY;
let folderIcon, contextWindow, lastActiveElement, activeWindow, activeIcon, activeTaskbarIcon;
let firstIcon, topZ = 0, windowOpenX = 50, windowOpenY = 99;

desktop.Init=()=>
{
    // system icons
    const taskbarIcon = 
        folderIcon = new OS13kTaskbarIcon( {icon:'📁', name:'Apps'}, 
            new OS13kFolder(programs, 0, 0));

    // open first icon in list
    firstIcon && firstIcon.MouseClick();
}

desktop.Update=()=>
{
    // listen for iframe becomming new active element
    const activeElement = document.activeElement;
    if (lastActiveElement != activeElement)
    {
        // set focus to new active element
        activeElement.Focus && activeElement.Focus();
        lastActiveElement = activeElement;
    }
}

desktop.Focus=()=>
{
    // deavtivate window and icons
    document.activeElement.blur();
    activeWindow && activeWindow.SetActive(activeWindow = 0);
    activeTaskbarIcon && activeTaskbarIcon.SetActive(activeTaskbarIcon = 0);
}

desktop.CloseFolders=()=>
{
    // hide all drop down folders
    for (const c of programsFolder.children)
        c.localName == 'os13k-folder' && (c.style.visibility = 'hidden');
        
    menu.style.visibility = '';
}

desktop.CloseWindows=()=>
{
    // loop until all windows are closed
    for(let finished;!finished;)
    {
        finished = 1;
        for (const c of desktop.children)
            c.Close && c.Close(finished=0);
    }

    // reset window open position
    windowOpenX = 50;
    windowOpenY = 99;
}

desktop.FocusTopWindow=()=>
{
    // find the top window and focus on it
    let topWindow;
    for (const c of desktop.children)
    {
        c.localName == 'os13k-window' &&
        (!topWindow || topWindow.style.zIndex < c.style.zIndex) &&
            (topWindow = c);
    }
    topWindow && topWindow.Focus();
}

/////////////////////////////////////////////////////////////////////////////
// OS13kTaskbarIcon

class OS13kTaskbarIcon extends HTMLElement
{
	constructor(icon, element = 0)
    {
		super();
        
        // create icon
        this.className = 'taskbarIcon';
        this.innerHTML = '<span style=pointer-events:none>' + icon.icon;
        this.element = element;
        this.title = icon.name + (icon.author ? '\nBy ' + icon.author : '');
        
        // add to taskbar
        taskbar.appendChild(this);
    }
    
    MouseClick()
    {
        // focus on window or drop down folder
        document.activeElement.blur();
        this.element.Focus(1);
    }
    
    SetActive(active=1)
    {
        // unselect old icon and set style
        activeTaskbarIcon && activeTaskbarIcon.SetActive(activeTaskbarIcon = 0);
        activeTaskbarIcon = this;
        this.className = 'taskbarIcon' + (active ? ' taskbarIconActive' : '');
    }
} // OS13kTaskbarIcon

customElements.define('os13k-taskbar-icon', OS13kTaskbarIcon);

/////////////////////////////////////////////////////////////////////////////
// OS13kFolder

class OS13kFolder extends HTMLElement
{
	constructor(icons, x, y, parentFolder)
    {
		super();
        
        // add to desktop
        this.className = 'folder';
        this.style.left = x;
        this.style.top = y;
        this.parentFolder = parentFolder;
        programsFolder.appendChild(this);
        
        // add icons to folder
        for (const icon of icons)
            this.appendChild(icon.os13kicon = new OS13kIcon(icon));
        
        // get width offset and add new folders recursively
        const rect = this.getBoundingClientRect();
        for (const icon of icons)
        {
            // create the folder and hook up to icon
            icon.folder && (icon.os13kicon.folder = new OS13kFolder(icon.folder, rect.right - 2, y, this));
            y += 26;
        }
    }

    Focus(fromTaskbar)
    {
        const wasVisible = this.style.visibility == '';
            
        desktop.CloseFolders();
        if (!fromTaskbar || !wasVisible)
        { 
            // make visible
            this.parentFolder && this.parentFolder.Focus();
            this.style.visibility = '';
        }
        else
            activeWindow && activeWindow.Focus();
        
        if (fromTaskbar && this.parentNode == programsFolder)
        {
            programsFolder.style.left = 0;
            programsFolder.style.top = 51;
        }
    }
} // OS13kFolder

customElements.define('os13k-folder', OS13kFolder);

/////////////////////////////////////////////////////////////////////////////
// OS13kIcon

class OS13kIcon extends HTMLElement
{
	constructor({x, y, name, icon, src, width=720, height=405, author, folder, multiple, reload, code})
    {
		super();
        
        // set icon defaults
        src = src || '';
        name = name || src.split('.')[0];
        icon = icon || (name[0] ? name[0].toUpperCase() : '' );     
        
        // check for special extensions
        const extension = src? src.split('.')[1] : '';
        this.isDweet = extension == 'dweet';
        this.isShader = extension == 'shader';
        this.hasExtension = this.isDweet || this.isShader
        this.hasExtension && (reload = 1);
        firstIcon || src && (firstIcon = this);

        // set icon data
        this.name = name;
        this.icon = icon;
        this.src = src;
        this.width = width;
        this.height = height;
        this.author = author;
        this.multiple = multiple;
        this.reload = reload;
        this.code = code || this.hasExtension;
        this.className = 'icon';
        
        // set html
        this.innerHTML = 
            '<span style=pointer-events:none;display:flex;width:100%>&nbsp;' +
            '<span style="width:28;text-shadow:1px 1px 2px #000;text-align:center">' + 
            icon + '</span>&nbsp;<span style=flex:1>' +
            name + '</span><span style=width:20;text-align:right>' +
            (folder? '▶' : '');
    }
    
    MouseDown()
    {
        // focus on parent
        const parent = this.parentElement && this.parentElement.offsetParent;
        (parent.Focus? parent : desktop).Focus();
    }
    
    MouseMove()
    {
        // set active
        activeIcon = this;
        this.className = 'icon iconActive';
        (this.folder? this.folder : this.offsetParent).Focus();
    }
    
    MouseClick() 
    {
        if (this.src)
        {
            // open the window
            (!this.window || this.multiple) && (this.window = new OS13kWindow(this));

            // set focus to window
            this.window.Focus(1);
        }
        else if (!this.folder)
        {
            // close all
            desktop.CloseFolders();
            desktop.CloseWindows();
        }
    }
} // OS13kIcon

customElements.define('os13k-icon', OS13kIcon);

/////////////////////////////////////////////////////////////////////////////
// OS13kWindow

class OS13kWindow extends HTMLElement
{
	constructor(icon)
    {
		super();
        
        // add to desktop
        desktop.appendChild(this);
        
        // create taskbar icon
        this.icon = icon;
        this.taskbarIcon = new OS13kTaskbarIcon(icon, this);
        
        // set window position
        this.style.left = windowOpenX;
        this.style.top = windowOpenY;
        (windowOpenY += 46) > 400 && (windowOpenY = 99);
        (windowOpenX += 46) > 1e3 && (windowOpenX = 50);
        
        // create shadow root
		this.shadow = this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = template.innerHTML;
        
        // create title bar
        const titleBar = this.titleBar = document.createElement('div');
        titleBar.className = 'titleBar';
        this.shadowRoot.appendChild(titleBar);
        
        // create title bar name
        const titleBarName = document.createElement('div');
        titleBarName.className = 'name';
        titleBarName.innerHTML = 
            '<div style=pointer-events:none>' +
            '&nbsp;<span style="text-shadow:2px 2px 3px #000">' + 
            icon.icon + '</span>&nbsp;' +
            icon.name +
            (icon.author ? ' - ' + icon.author : '');
        titleBar.appendChild(titleBarName);
        
        // create title bar icons
        const AddTitleBarIcon=(id, title)=>
        {
            const icon = document.createElement('div');
            icon.innerHTML = `<svg><use href=#icon-${icon.className = id}>`;
            icon.title = title;
            titleBar.appendChild(icon);
        }
        AddTitleBarIcon('full', 'Full Screen');
        icon.code && AddTitleBarIcon('code', 'Show Code');
        icon.reload && AddTitleBarIcon('reload', 'Reload');
        AddTitleBarIcon('close', 'Close');
        
        // create thin black line below title bar
        const titleBarGap = document.createElement('div');
        titleBarGap.style.height = 2;
        this.shadowRoot.appendChild(titleBarGap);

        // create content wrapper
        const contentWrapper = this.contentWrapper = document.createElement('div');
        contentWrapper.style.background = '#000'
        this.shadowRoot.appendChild(contentWrapper);
        
        // limit window size to inner size
        this.contentWrapper.style.width  = Math.min(this.icon.width,  innerWidth);
        this.contentWrapper.style.height = Math.min(this.icon.height, innerHeight);
        this.style.width = Math.min(this.icon.width, innerWidth);

        // create iframe
        const iframe = this.iframe = document.createElement('iframe'); 
        iframe.className = 'frame';
        iframe.style.visibility = 'hidden';
        iframe.src = icon.src;
        contentWrapper.appendChild(iframe);
                
        // load frame
        iframe.onload=e=>
        {
            // set up iframe          
            const iframeContent = this.iframeContent = e.target.contentWindow;
            const iframeDocument = iframeContent.document;
            const iframeText = this.icon.hasExtension ?
                iframeDocument.body.innerText : iframeDocument.body.innerHTML;

            // create code display
            if (!this.codeDisplay)
            {
                this.codeDisplay = document.createElement('textarea');
                this.codeDisplay.className = 'codeDisplay'; 
                this.codeDisplay.setAttribute('readOnly', 1);
                this.codeDisplay.value = iframeText;
                this.shadowRoot.appendChild(this.codeDisplay);
            }

            // try to pass OS13k to iframe
            iframeContent.OS13k = OS13k;
            iframeContent.zzfx = zzfx;
            iframeContent.OS13kStart && iframeContent.OS13kStart();

            // check for extensions
            if (this.icon.hasExtension)
            {
                iframeDocument.body.innerHTML = 
                    '<canvas id=c width=1920 height=1080 style=' +
                    'width:100%;background:#' +
                    (this.icon.isDweet ? 'fff' : '000') +'>';
                iframeDocument.body.style = 
                    'background:#111;' +
                    'overflow:hidden;' +
                    'margin:0;' +
                    'display:flex;' +
                    'align-items:center';

                // create dweet
                this.icon.isDweet && iframeContent.eval(
                    'u=t=>{' + iframeText + '};' +
                    'x=c.getContext`2d`;' +
                    'S=Math.sin;' +
                    'C=Math.cos;' +
                    'T=Math.tan;' +
                    'R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;' +
                    'loop=t=>requestAnimationFrame(loop,' +
                        'document.hasFocus()&&' +
                        'u((60*(frame++/60)-frame-1|0?frame-1:frame)/60));' +
                    'loop(frame=0)');

                // create shader
                this.icon.isShader && iframeContent.eval(
                    'g=c.getContext`webgl2`;' +
                    'x=y=z=w=0;' +
                    'onmousemove=e=>e.buttons&&(x=e.x,y=c.height-e.y);' +
                    'onmousedown=e=>(x=z=e.x,y=w=c.height-e.y);' +
                    'onmouseup=e=>z=w=0;' +
                    'loop=t=>requestAnimationFrame(loop,' +
                        'document.hasFocus()&&(' +
                        'c.width=innerWidth,' + 
                        'c.height=innerHeight,' + 
                        'g.uniform4f(g.getUniformLocation(s,"iMouse"),x,y,z,w),' +
                        'OS13k.RenderShader(c,s,t/1e3)));' + 
                    'loop(s=OS13k.CreateShader(c,`' + iframeText + '`))');
            }

            // show iframe and set focus
            iframe.style.visibility = '';
            this.Focus();
        }
    }
    
    MouseDown(e, originalTarget)
    {
        // set selected if name is clicked on
        originalTarget.className == 'name' && (selected = this);
            
        // set focus
        this.Focus();
    }
    
    MouseClick(e)
    {
        // check for title bar buttons
        e.className == 'full'        && this.FullScreen();
        e.className == 'code'        && this.ShowCode();
        e.className == 'reload'      && this.Reload();
        e.className == 'close'       && this.Close();
        e.className != 'codeDisplay' && this.Focus();
    }
    
    Focus(fromTaskbar)
    {
        // set focus
        desktop.CloseFolders();
        this.iframeContent && this.iframeContent.focus();
        this.SetActive();
        
        if (fromTaskbar)
        {
            // clamp window to screen
            const rect = this.getBoundingClientRect();
            this.style.left = OS13k.Clamp(rect.x, 0, innerWidth - rect.width);
            this.style.top = OS13k.Clamp(rect.y, 46, 
                Math.max(46, innerHeight - rect.height));
        }
    }
    
    SetActive(active=1)
    {
        if (active && activeWindow != this)
        {
            // deactivate old window
            activeWindow && activeWindow.SetActive(0);
            
            // move z to top
            this.style.zIndex = ++topZ;
            
            // set conext menu buttons
            let menuHTML = '<button onclick=contextWindow.FullScreen()>Fullscreen';
            this.icon.code && (menuHTML += '<button onclick=contextWindow.ShowCode()>Show Code');
            this.icon.reload && (menuHTML += '<button onclick=contextWindow.Reload()>Reload');
            menuHTML += '<button onclick=contextWindow.Close()>Close';
            menu.innerHTML = menuHTML;
        }
        
        // set active
        activeWindow = active && this;
        this.style.filter = active ? '' : 'grayscale(.7)brightness(.7';
        this.titleBar.className = 'titleBar' + (active? ' titleBarActive' : '')
        this.taskbarIcon.SetActive();
    }
    
    FullScreen()
    {
        // set fullscreen
        this.Focus();
        const fullScreenElement = this.contentWrapper;
        if (fullScreenElement.webkitRequestFullScreen)
            fullScreenElement.webkitRequestFullScreen();
        else if (fullScreenElement.mozRequestFullScreen)
            fullScreenElement.mozRequestFullScreen();
    }
    
    ShowCode()
    {
        // toggle showing code
        this.Focus();
        this.codeDisplay.style.display = 
            (this.showCode = !this.showCode) ? 'block' : '';
    }
    
    Reload()
    {
        // hide iframe and reload it
        this.iframe.style.visibility = 'hidden';
        this.iframeContent.location.reload();
    }
    
    Close()
    {
        // destroy window
        this.icon.window = 0;
        this.taskbarIcon.remove();
        this.remove();
        
        // try to focus on top window
        desktop.FocusTopWindow();
    }
} // OS13kWindow

customElements.define('os13k-window', OS13kWindow);

/////////////////////////////////////////////////////////////////////////////
// Mouse Input

onmousedown=e=>
{
    // prevent getting stuck
    if (selected) return onmouseup(e);
    
    // ignore menu buttons
    if (e.target.localName == 'button')
        return;
        
    // prevent desktop from stealing focus
    const originalTarget = e.originalTarget || e.path[0];
    
    // prevent default except for text areas (allow copy/paste)
    (originalTarget.localName != 'textarea') && e.preventDefault();
    
    // hide menu if it wasnt clicked on
    e.target.offsetParent.className != 'menu' && (menu.style.visibility = '');
    
    // hide folders if not clicked on
    e.target.offsetParent.className != 'folder' && e.target != folderIcon && desktop.CloseFolders();
    
    // only look for left mouse button
    if (e.button) return;
    
    // handle mouse down
    e.target.MouseDown && e.target.MouseDown(e, originalTarget);
    
    // save selected offset
    const rect = e.target.getBoundingClientRect();
    seletOffsetX = e.x - rect.x;
    seletOffsetY = e.y - rect.y;
    
    // set grabbing mode
    if (selected)
    {  
        document.body.style.cursor = 'grabbing';
        desktop.style.pointerEvents = 'none';
    }
}

onmouseup=e=>
{
    // allow pointer events and reset cursor
    document.body.style.cursor = desktop.style.pointerEvents = '';
        
    // release selected
    selected && selected.Focus(selected = 0);
        
    // focus on active window
    e.target != folderIcon && activeWindow && activeWindow.Focus();
}

onmousemove=e=>
{
    if (selected)
    {
        // update selected position
        selected.style.left = e.x - seletOffsetX;
        selected.style.top = e.y - seletOffsetY;
    }
    
    // unselect active icon
    activeIcon && (activeIcon.className = 'icon');
    
    // handle mouse move
    e.target.MouseMove && e.target.MouseMove(e);
}

onclick=e=>
{
    // hide menu
    menu.style.visibility = '';
    
    // prevent desktop from stealing focus
    e.preventDefault();
    
    // handle click
    e.target.MouseClick ? e.target.MouseClick(e.originalTarget || e.path[0]) :
        desktop.CloseFolders();
}

oncontextmenu=e=>
{
    // prevent default context menu
    e.preventDefault();
    
    // ignore menu buttons
    if (e.target.localName == 'button')
        return;
        
    // hide menu
    menu.style.visibility = '';
    
    // ignore events except from windows and taskbar icons
    let menuElement = menu;
    if (!e.target.SetActive || e.target == folderIcon)
    {
        menuElement = programsFolder;
        folderIcon.MouseClick();
    }
    if (e.target.element)
    {
        // ignore if it is a folder
        if (e.target.element.className && e.target != folderIcon)
            return;
            
        // focus on target frame
        e.target.element.Focus();
    }
    else
        e.target.Focus && e.target.Focus();
    
    // show menu
    menuElement.style.left = e.x;
    menuElement.style.top = e.y;
    menuElement.style.visibility = 'visible';
    contextWindow = activeWindow;
    document.activeElement.blur();
}

/////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth 

let zzfxV  = .3; // volume
const zzfx =     // play zzfx sound
(
    volume        = 1, 
    randomness    = .05,
    frequency     = 220,
    attack        = 0,
    sustain       = 0,
    release       = .1,
    shape         = 0,
    shapeCurve    = 1,
    slide         = 0, 
    deltaSlide    = 0, 
    pitchJump     = 0, 
    pitchJumpTime = 0, 
    repeatTime    = 0, 
    noise         = 0,
    modulation    = 0,
    bitCrush      = 0,
    delay         = 0,

    // locals
    PI2 = Math.PI*2,
    sampleRate = 44100,
    random = r => r*2*Math.random()-r,
    sign = v => v>0?1:-1,
    startSlide = slide *= 500 * PI2 / sampleRate**2,
    startFrequency = frequency *= (1 + random(randomness)) * PI2 / sampleRate,
    modPhase = sign(modulation) * PI2/4,
    b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, d=.5,
    length, buffer
) =>
{
    // init parameters
    attack = 99 + attack * sampleRate | 0;
    sustain = sustain * sampleRate | 0;
    release = release * sampleRate | 0;
    delay = delay * sampleRate | 0;
    deltaSlide *= 500 * PI2 / sampleRate**3;
    length = attack + sustain + release + delay;
    modulation *= PI2 / sampleRate;
    pitchJump *= PI2 / sampleRate;
    pitchJumpTime = pitchJumpTime * sampleRate;
    repeatTime = repeatTime * sampleRate;

    // generate waveform
    for(; i < length;b[i++] = s)
    {
        if (++c > bitCrush*100)                          // bit crush
        {
            c = 0;                                       // reset bit crush
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation - modPhase);    // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
                Math.sin((s%PI2)**3) :                   // 4 noise
                Math.max(Math.min(Math.tan(s),1),-1):    // 3 tan
                1-(2*s/PI2%2+2)%2:                       // 2 saw
                1-4*Math.abs(Math.round(s/PI2)-s/PI2):   // 1 triangle
                Math.sin(s);                             // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * zzfxV * (                      // envelope
                i < attack ? i/attack :                  // attack
                i < attack + sustain ? 1 :               // sustain
                i < length - delay ?                     // post release
                1 - (i - attack - sustain)/release : 0); // release
                
            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i-delay]/2) : s;
        }

        t += 1 + random(noise);             // noise
        tm += 1 + random(noise);            // modulation noise
        frequency += slide += deltaSlide;   // frequency slide

        if (j && ++j > pitchJumpTime)       // pitch jump
        {
            frequency += pitchJump;         // apply pitch jump
            startFrequency += pitchJump;    // also apply to start frequency
            j = 0;                          // reset pitch jump time
        };

        if (repeatTime && ++r > repeatTime) // repeat
        {
            frequency = startFrequency;     // reset frequency
            slide = startSlide;             // reset slide
            r = 1;                          // reset repeat time
            j = j || 1;                     // reset pitch jump time
        }
    }
    
    return OS13k.PlaySamples(b);
}

/////////////////////////////////////////////////////////////////////////////
// Start OS13k!

const OS13k = new _OS13k;
desktop.Init();
setInterval(desktop.Update, 16);

/////////////////////////////////////////////////////////////////////////////////////
// Touch Input

try
{
    let wasTouching, lastTouchTime;
    const ProcessTouch=e=>
    {
        const touching = e.touches.length;
        if (touching)
        {
            // set event pos
            e.x = e.touches[0].clientX;
            e.y = e.touches[0].clientY;
            
            // pass event on to mouse input
            !wasTouching && onmousedown(e);
            onmousemove(e);
            lastTouchTime = Date.now();
        }
        else
            wasTouching && (onmouseup(e), onclick(e));
        wasTouching = touching;
    }

    // set all touch events
    ontouchstart = ontouchmove = ontouchend = ontouchcancel = ProcessTouch;
}
catch (e) {}

</script>