<!--

OS13k is a tiny operating system designed for a JS13k community project. It has native support for Shadertoys, Dweets, ZzFX, trophies, and much more.

Your mission, if you choose to accept it, is to help us fill it up with as much cool stuff as we can fit.

Please keep this project confidential!

‚úåÔ∏èüòÑ ‚ù§Ô∏è OS13k Team

// Minification Steps
// 1. Remove touch support
// 2. Paste programs to top
// 3. Google Closure
// 4. Terser
// 5. HTML Compressor

-->

<title>OS13k - A tiny OS for JS13k</title>
<link rel=icon type=image/x-icon href='favicon.ico'/>
<meta name=viewport content='width=device-width,initial-scale=1,user-scalable=0'>

<!-- HTML above is optional -->

<meta charset=utf-8>
<style>
body
{
    opacity:0;
    margin:0;
    overflow:hidden;
    font-family:arial;
    font-size:22;
    user-select:none;
    white-space:nowrap;
    background:#000;
}
#menu
{
    display:flex;
    flex-direction:column;
    background:#000;
}
.folder { background:linear-gradient(#fff,#777); }
#menu, .folder
{
    visibility:hidden;
    position:absolute;
    z-index:20000;
    box-shadow:5px 5px 9px;
    border:2px solid;
}
.program
{
    font-size:18;
    height:18;
    padding:4;
}
.activeWindow { border:3px solid #aaa; }
#taskbar
{
    position:absolute;
    z-index:10000;
    width:100%;
    background:linear-gradient(#888,#333);
    box-shadow:0px 1px 9px;
    border-bottom:2px solid;
}
.taskbarIcon { width:50; height:40; text-shadow:1px 1px 3px; }
.programActive,
.taskbarIconActive         { background:linear-gradient(#ff8,#fff); }
.taskbarIcon:hover         { background:linear-gradient(#fff,#44f); }
#tray
{
    margin:2;
    padding:2;
    padding-left:9;
    padding-right:9;
    color:#fff;
    background:linear-gradient(#000,#333);
    border:1px solid;
    border-radius:6px;
}
.trayIcon       { padding:6; }
.trayIcon:hover { background:#fff3; }
.popup
{
    position:relative;
    z-index:10000;
    width:200;
    padding:8;
    pointer-events:none;
    overflow:hidden;
    text-align:center;
    background:linear-gradient(#eee,#888);
    box-shadow:9px 9px 19px;
    border:2px solid;
    border-radius:9px;
}
.trophyIcon
{
    padding:9;
    font-size:40;
    text-shadow:2px 2px 4px;
    white-space:nowrap;
}
#title
{
    position:absolute;
    width:100%;
    height:100%;
    color:#0002;
    font-family:impact;
    font-size:20vw;
    font-weight:900;
    background:linear-gradient(#223,#322);
}
.program, #taskbar, .taskbarIcon, #title
{
    display:flex;
    align-items:center;
    justify-content:center;
}
@keyframes hue 
{
  0%, 100% { filter: hue-rotate(); }
  50%      { filter: hue-rotate(180deg); }
}
</style>
<template id=templateWindow>
<style>
:host
{
    visibility:hidden;
    overflow:hidden;
    position:absolute;
    background:#000;
    box-shadow:5px 5px 9px;
    border:3px solid #222;
    border-radius:6px;
}
.titlebar
{
    height:34;
    font-size:24;
    display:flex;
    align-items:center;
    overflow:hidden;
    white-space:nowrap;
    background:linear-gradient(#ccc,#444);
    border-bottom:3px solid;
}
.titlebarActive { background:linear-gradient(#eee,#88f); }
.titlebarSticky { background:linear-gradient(#ccc,#844); }
#nameWrapper    { width:100%; overflow:hidden; cursor:grab; }
#icon           { text-shadow:1px 1px 3px; margin-left:9; margin-right:9; }
#name, #icon    { pointer-events:none; display:inline; }
#frame
{
    width:100%;
    height:100%;
    background:#fff;
    border:none;
    visibility:hidden;
}
textarea
{
    width:100%;
    height:99;
    resize:none;
    display:none;
    background:#000;
    color:#fff;
}
#full:hover   { background:#fff; }
#help:hover   { background:#0ff; }
#code:hover   { background:#f0f; }
#shrink:hover,
#grow:hover   { background:#0f0; }
#reload:hover { background:#ff0; }
#close:hover  { background:#f00; }
div svg       { width:28;pointer-events:none; }
</style>
<svg height=0 width=0>
<symbol id=icon-full viewBox='0 0 10 10'>
    <rect stroke=#000 fill=none x=1 y=2 width=8 height=6 />
<symbol id=icon-help viewBox='0 0 10 10'>
    <path stroke=#000 fill=none d='M5 8L8 2L2 2L5 8L8 2'/>
<symbol id=icon-code viewBox='0 0 10 10'>
    <path stroke=#000 fill=none d='M5 2L8 8L2 8L5 2L8 8'/>
<symbol id=icon-shrink viewBox='0 0 10 10'>
    <path stroke=#000 d='M2 5L8 5'/>
<symbol id=icon-grow viewBox='0 0 10 10'>
    <path stroke=#000 d='M2 5L8 5M5 8L5 2'/>
<symbol id=icon-reload viewBox='0 0 10 10'>
    <circle stroke=#000 fill=none cx=5 cy=5 r=3 />
<symbol id=icon-close viewBox='0 0 10 10'>
    <path stroke=#000 d='M2 2L8 8M8 2L2 8'/>
</template>
<div id=taskbar>
<div id=taskbarSpace style=flex:1></div>
<div id=tray></div>
</div>
<div id=popups style=float:right></div>
<div id=title>OS13k</div>
<div id=desktop>
<div id=programsMenu style=position:absolute></div>
<div id=menu>
<button id=buttonFullScreen>Fullscreen
<button id=buttonShowHelp>Help
<button id=buttonShowCode>Code
<button id=buttonResetSize>Reset Size
<button id=buttonReload>Reload
<button id=buttonClose>Close
<script src=programs.js?45></script>
<script>

'use strict';

///////////////////////////////////////////////////////////////////////////////
// OS13k Debug (remove from minified)

const OS13kVersion = 49;
{
    // version check, clear local storage if older
    if (localStorage.OS13kVersion && localStorage.OS13kVersion != OS13kVersion)
    {
        alert('OS13k version out of date! System reset in 3, 2, 1...');
        localStorage.clear();
    }

    localStorage.OS13kVersion = OS13kVersion;

    // load default programs if none found
    if (typeof programs == 'undefined')
    {
        alert('No programs found, using defaults!')
        programs = 
        [
            {src:'system/test.html'},
            {src:'system/wordList.html', icon:'üìï', sticky:1},
            {src:'system/trophyCase.html', icon:'üèÜ', sticky:1},
            {src:'system/clock.dweet.js', icon:'üï∞Ô∏è', width:200, height:200, sleep:0, full:0, reload:0, sticky:1}
        ];
    }
} // debug stuff

///////////////////////////////////////////////////////////////////////////////
// Google Closure Config

{
// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs OS13kFolder, OS13kProgram, OS13kWindow, OS13kTaskbarIcon
// @js_externs OS13k, zzfx, iframeContent.zzfx
// @js_externs OS13k.Trophy, OS13k.GetTrophy, OS13k.Trophies
// @js_externs OS13k.KeyDirection, OS13k.Speak
// @js_externs OS13k.CreateShader, OS13k.RenderShader, OS13k.CreateCanvas
// @js_externs OS13k.PlaySamples, OS13k.PlaySeed, OS13k.GetNote
// @js_externs OS13k.KillHTML, OS13k.Glitch
// @js_externs OS13k.Random, OS13k.randomSeed 
// @js_externs OS13k.Clamp, OS13k.Percent, OS13k.Lerp
// @js_externs localStorage.OS13kTrophies, localStorage.OS13kVersion
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==
} // Google Closure Config

///////////////////////////////////////////////////////////////////////////////
// OS13k System

class _OS13k
{

/////////////////////////////////////////////////////////////////////////////
// OS13k Math

    Clamp   (a, min=0, max=1) { return Math.min(Math.max(a, min), max); }
    Percent (v, a, b)         { return b-a? this.Clamp((v-a)/(b-a), 0, 1) : 0; }
    Lerp    (p, a, b)         { return a + this.Clamp(p, 0, 1) * (b-a); }
    Random(max=1, min=0)
    {
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= (this.randomSeed||-1) << 13;
        this.randomSeed ^= this.randomSeed >> 17;
        this.randomSeed ^= this.randomSeed << 5;
        return this.Percent(Math.abs(this.randomSeed) % 1e9 / 1e9, min, max);
    }

/////////////////////////////////////////////////////////////////////////////
// OS13k Trophies

    // award player with trophy, returns falsey if already owned
    Trophy(game='', name='', icon='', message='', language='ja')
    {
        // replace commas and quotes in a string
        const Clean=string=>(string+'').replace(/'/g, '"').replace(/,/g, '');

        // remove commas
        game = Clean(game);
        name = Clean(name);
        icon = Clean(icon);
        
        // build key
        const key = game + `,${ name },` + icon;
        const storageKey = 'OS13kTrophy,' + key;
        
        // remove html tags
        icon    = this.KillHTML(icon,    maxWordLength, 1);
        name    = this.KillHTML(name,    maxWordLength, 1);
        game    = this.KillHTML(game,    maxWordLength, 1);
        message = this.KillHTML(message, maxWordLength, 1);
        
        // find in trophy list
        const index = trophies.findIndex(e=>e[4]==key)
        
        // skip if same message
        if (index >=0 && trophies[index][3] == message) return 0;
        
        // add or update trophy list
        const trophyData = [game, name, icon, message, key];
        index < 0 ? trophies.unshift( trophyData ) :
            trophies[index] = trophyData;

        // save trophy
        localStorage[storageKey] = message;
            
        // save local storage only after trophies were first checked
        !preventTrophySave && (localStorage.OS13kTrophies = JSON.stringify(trophies));
        
        // refresh trophy window
        trophyTrayIcon.program && trophyTrayIcon.program.Refresh();
        
        // use game or icon as name if there is no name
        name || game && (name = game, game = '');

        // add trophy popup
        this.Popup(
            `<div class=trophyIcon>${ 
                icon||'üèÜ' }</div><div><b>${   // icon
                name }</b><br><i>${            // name
                game }</i></div>` +            // game
                message,                       // message
            name || game,                      // speak
            language);                         // language
            
        // add trophy words to list
        this.AddWords(name, 0);
        this.AddWords(game, name);
        this.AddWords(message);
        
        // return trophy data
        return trophyData;
    }
    
    // get message, 0 if no trophy
    GetTrophy(game, name)
    {
        // find in trophy list
        const i = trophies.findIndex( e=>e[0]==game && e[1]==name );
        
        // return trophy message
        return i < 0 ? 0 : trophies[i][3];
    }
    
    // get the trophy list
    Trophies() { return [...trophies]; }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Words
    
    // add every word in a string to the word list
    AddWords(string, speak=1)
    {
        // convert to lowercase and split into words
        const matchs = (string?string+'':'').toLowerCase().match(/\b[^\s]+\b/g);
        
        let newWords = [];
        matchs && matchs.map(word=>
        {
            // dont use it if it has anything but letters
            /[^a-z]/.test(word) ||

                // limit word length
                word.length > 1 && word.length < maxWordLength &&

                // check if already in list
                words.indexOf(word) < 0 &&

                // add it to the list of new words
                newWords.push(word);
        });
        
        for(const word of newWords)
        {
            // add it to the word list
            words.unshift(word);
            
            // update new words message
            newWordsMessage += (newWordsMessage.length? ', ' : ' ') + word;
            speak && (newWordsSpeak += word + ' ');
        }
        
        // save words
        localStorage.OS13kWords = JSON.stringify(words);
    }

    // get the word list
    GetWords() { return [...words]; }

    // get a random matching word
    GetWord(regex = /./, minLength = 0, maxLength = maxWordLength)
    {
        // search for matches
        const matches = words.filter( o=>
            o.length >= minLength && o.length <= maxLength && 
            regex.test(o));
            
        // get random match
        return matches.length > 0 ? matches[Math.random()*matches.length|0] : '';
    }
    
    // remove a word from the list
    RemoveWord(word)
    {
        // remove word if it exists
        words = words.filter(e => e != word);

        // trigger refresh of dictionary window
        wordsTrayIcon.program && wordsTrayIcon.program.Refresh();
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Audio

    // play zzfx sound from seed
    PlaySeed(seed, lengthScale=1, volume=1, randomness=.05)
    {
        // set random seed
        const R=()=>this.Random(), C=()=>R()<.5?R():0, S=()=>C()?1:-1;
        this.randomSeed = seed;
        
        // randomize sound length
        lengthScale /= 2;
        const attack  = R()**3*lengthScale;
        const decay   = R()**3*lengthScale;
        const sustain = R()**3*lengthScale;
        const release = R()**3*lengthScale;
        const length  = attack + decay + sustain + release;
        
        // generate random sound
        return zzfx
        (
           volume,           // volume
           randomness,       // randomness
           R()**2*2e3,       // frequency
           attack,           // attack
           sustain,          // sustain
           release,          // release
           R()*5|0,          // shape
           R()**2*3,         // shapeCurve
           C()**3*99*S(),    // slide
           C()**3*99*S(),    // deltaSlide
           C()**2*1e3*S(),   // pitchJump
           R()**2 * length,  // pitchJumpTime
           C() * length,     // repeatTime
           C()**4,           // noise
           C()**3*9*S(),     // modulation
           C()**4,           // bitCrush
           C()**3/2,         // delay
           1 - C(),          // sustain volume
           decay             // decay
        );
    }
    
    // play raw audio sample data
    PlaySamples(samples, sampleRate=44100)
    {
        const buffer = audioContext.createBuffer(1, samples.length, sampleRate);
        const source = audioContext.createBufferSource();
        buffer.getChannelData(0).set(samples);
        source.buffer = buffer;
        source.connect(gain);
        source.start();
        return source;
    }
    
    // get frequency of a musical note on a diatonic scale
    GetNote(semitoneOffset=0, rootNoteFrequency=440)
        { return rootNoteFrequency * 2**(semitoneOffset/12); }

    // speak the text
    Speak(text, rate=1, pitch=1, volume=1, language='en', stopSpeech)
    {
        // common languages (not supported in all browsers)
        // it - italian, fr - french,  de - german,   es - spanish, pl - polish
        // hi - hindi,   ru - russian, ja - japanese, zh - chinese, ko - korean
    
        // must have speech and not be muted
        if (speechSynthesis && gain.gain.value)
        {
            // stop speech if set
            stopSpeech && this.StopSpeech();
        
            // speak with utterance parameters
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.volume = volume;
            utterance.pitch = pitch;
            utterance.rate = rate;
            utterance.lang = language;
            speechSynthesis.speak(utterance);
        }
    }
    
    // stop any current or queued speech
    StopSpeech() { return speechSynthesis && speechSynthesis.cancel(); }
        
/////////////////////////////////////////////////////////////////////////////
// OS13k Shaders

    // create pixel shader
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');

        // create a simple pass through vertex shader
        const vertexShader = x.createShader(x.VERTEX_SHADER);
        x.shaderSource(vertexShader,
            '#version 300 es\n' +
            'in vec4 p;' +
            'void main()' +
            '{gl_Position=p;}');
        x.compileShader(vertexShader);
        
        // create vertex buffer that is a big triangle
        const vertexBuffer = x.ARRAY_BUFFER;
        x.bindBuffer(vertexBuffer,x.createBuffer());
        x.bufferData(vertexBuffer,new Int8Array([-3,1,1,-3,1,1]),x.STATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0,2,x.BYTE,0,0,0); // 2D vertex
        
        // check vertex shader for errors
        //if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
        //    throw x.getShaderInfoLog(vertexShader);
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(x.FRAGMENT_SHADER)
        const shaderProgramCode = 
            '#version 300 es\n' +
            'precision mediump float;' +
            'uniform float iTime;' +
            'uniform int iFrame;' +
            'uniform vec4 iMouse;' +
            'uniform vec3 iResolution;' +
            'uniform sampler2D iChannel0;' +
            'out vec4 outColor;\n' +
            code +
            '\nvoid main()' +
            '{mainImage(outColor,gl_FragCoord.xy);' +
            'outColor.a=1.;}';
        x.shaderSource(pixelShader, shaderProgramCode)
        x.compileShader(pixelShader);

        // check pixel shader for errors
        if (!x.getShaderParameter(pixelShader, x.COMPILE_STATUS))
            throw x.getShaderInfoLog(pixelShader);

        // create texture
        x.bindTexture(x.TEXTURE_2D, x.createTexture());
        x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.LINEAR);
        x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL, 1); 
        
        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    // render a pixel shader
    RenderShader(canvas, shaderProgram, time=0, frame=0)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // set uniforms
        const uniformLocation=name=>x.getUniformLocation(shaderProgram, name);
        x.uniform3f(uniformLocation('iResolution'), canvas.width, canvas.height, 1);
        x.uniform1f(uniformLocation('iTime'), time);
        x.uniform1f(uniformLocation('iFrame'), frame);
        x.uniform1i(uniformLocation('iChannel0'), 0);
        
        // render shader
        x.viewport(0, 0, canvas.width, canvas.height);
        x.drawArrays(x.TRIANGLE_FAN, 0, 3);
        
        // set texture to the newly renderd canvas
        x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, x.RGBA, x.UNSIGNED_BYTE, canvas);
    }

/////////////////////////////////////////////////////////////////////////////
// OS13k Input

    // get direction from wasd or arrow keys
    KeyDirection(keyCode)
    {
        let x = 0, y = 0;
        (keyCode == 87 || keyCode == 38) && ++y; // up
        (keyCode == 83 || keyCode == 40) && --y; // down
        (keyCode == 68 || keyCode == 39) && ++x; // right
        (keyCode == 65 || keyCode == 37) && --x; // left
        return {x, y};
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Text
    
    // replace html tags in a string
    KillHTML(string, maxLength)
    {
        // convert to string
        return (string+'')
        
            // clamp max length
            .substring(0, maxLength? maxLength: string.length)
            
            // replace < with &lt;
            .replace(/</g,'&lt;');
    }
    
    // add unicode glitches to a string
    Glitch(string, count)
    {
        // based on dweet by f8f82804 www.dwitter.net/d/11808
        let r;
        for(count; count-->0; )
            string = string
                .slice(0, r = Math.random()*(string+='').length+1)
                + String.fromCharCode( 768 + Math.random()*99 )
                + string.slice(r)
        
        // return result and remove html
        return this.KillHTML(string);
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k System Calls
    
    Popup(html, speak, language)
    {
        // create the popup
        const popup = document.createElement('div');
        popup.className = 'popup';
        popup.innerHTML = html;
        popup.style.top = innerHeight;
        popup.speak = speak;
        popup.speakLanguage = language;
        popups.appendChild(popup);
    }
    
}; // _OS13k
var OS13k = new _OS13k;

///////////////////////////////////////////////////////////////////////////////
// OS13k Variables

const taskbarHeight = 42, programHeight = 26, titlebarHeight = 37,
      startWindowOpenX = 9, startWindowOpenY = 51, 
      popupTime = 3, defaultVolume = .3, maxWordLength = 32;
      
let grabWindow, grabOffsetX, grabOffsetY, finishedStartup, preventTrophySave,
    activeWindow, activeProgram, helpProgram, activeTaskbarIcon, loadIcon,
    lastActiveElement, topZ = 0, loading = 0, hadInput = 0,
    windowOpenX = startWindowOpenX, windowOpenY = startWindowOpenY,
    startProgram, trophyTrayIcon, wordsTrayIcon, muteTrayIcon, clockTrayIcon,
    newWordsMessage = '', newWordsSpeak = '',

    // parse trophy list
    trophies = localStorage.OS13kTrophies ? 
        JSON.parse(localStorage.OS13kTrophies) : [],

    // parse word list
    words = localStorage.OS13kWords ? 
        JSON.parse(localStorage.OS13kWords) : [];

///////////////////////////////////////////////////////////////////////////////
// OS13k Manager - handles non client facing features of OS13k
    
class _OS13kManager
{
    // start up OS13k
    Start()
    {
        // listen for trophies from other windows
        window.onstorage =e=> OS13kManager.GiveTrophy(e.key);

        // create tray icons
        trophyTrayIcon = new OS13kTrayIcon();
        wordsTrayIcon  = new OS13kTrayIcon();
        muteTrayIcon = new OS13kTrayIcon(
            OS13kManager.ToggleMute, 'Toggle Mute', 'üîä');
        clockTrayIcon  = new OS13kTrayIcon();
        
        // check settings
        localStorage.OS13kMute == 'true' && OS13kManager.ToggleMute()
        
        // set button functions
        buttonFullScreen.onmousedown =()=> activeWindow.FullScreen();
        buttonShowCode.onmousedown   =
        buttonShowHelp.onmousedown   =()=> activeWindow.ShowCode();
        buttonResetSize.onmousedown  =()=> activeWindow.Resize(1);
        buttonReload.onmousedown     =()=> activeWindow.Reload();
        buttonClose.onmousedown      =()=> activeWindow.Close();

        // create the load program taskbar icon and add folders/programs
        loadIcon = new OS13kTaskbarIcon( {icon:'üíæ', name:'Load Program'} );
        loadIcon.windowOrFolder = new OS13kFolder(programs);

        // close all the menus that were just opened
        OS13kManager.CloseMenus();
        
        OS13k.Trophy('','Welcome to OS13k!','üëã');
        if (localStorage.OS13kFrozen)
        {
            OS13k.Trophy('OS13k','Frozen','üßä',`Froze The Browser\n${localStorage.OS13kFrozen}`);
        }

        // search local storage for trophies, saving is prevented until the end
        for (let i = localStorage.length; i--;)
            OS13kManager.GiveTrophy(localStorage.key(i));
        
        // save trophies
        localStorage.OS13kTrophies = JSON.stringify(trophies);
        preventTrophySave = 0;
        
        // try to handle startup now in case no programs are loading
        OS13kManager.HandleStartup();
        
        // kick off update
        OS13kManager.Update();
        
        // stop spech if page is unloaded
        document.body.onunload = OS13k.StopSpeech();
    }

    // wait for startup to finish to open first program
    HandleStartup()
    {
        // skip until not loading and finished startup
        if (loading || finishedStartup) return;

        // open start active program
        self == top ?
            (startProgram = startProgram || helpProgram) && startProgram.Open() :
            (title.innerText += ' Meta');

        // finish startup after opening startup programs
        finishedStartup = 1;
    }

    // main update loop
    Update()
    {
        requestAnimationFrame(OS13kManager.Update);

        // listen for iframe becomming new active element
        const activeElement = document.activeElement;
        if (lastActiveElement != activeElement)
        {
            // set focus to new active element
            activeElement.SetActive && activeElement.SetActive(1,0);
            lastActiveElement = activeElement;
            
            // set that we had input if user selected window
            activeWindow == activeElement && (hadInput = 1);
        }
        
        // add queued up new words
        newWordsMessage && OS13k.Popup(
            '<b>New Words!</b><br>' + newWordsMessage, newWordsSpeak,
            wordsTrayIcon.program.Refresh());
        newWordsMessage = newWordsSpeak = '';
        
        // update popups if finished startup
        if (hadInput && finishedStartup)
        {
            let offsetHeight = 0, i = 0;

            // use copy of popups to prevent skipping if removed
            for(const popup of [...popups.children])
            {
                // speak popup
                popup.speak && 
                    OS13k.Speak(popup.speak, 1, 1, 1, popup.speakLanguage, popup.speak=0);
            
                if (!document.fullscreenElement)
                { 
                    // move popup up
                    let y = parseFloat(popup.style.top) + offsetHeight - 9;
                    if (y < taskbarHeight)
                    {
                        // stop popup below taskbar
                        y = taskbarHeight;

                        // fade out popup if at top
                        if (!i++ && !(popup.style.opacity = (popup.style.opacity || popupTime) - .01))
                        {
                            // remove when invisible and adjust for height
                            const rect = popup.getBoundingClientRect();
                            offsetHeight += rect.height;
                            popups.removeChild(popup);
                        }
                    }

                    // set popup position
                    popup.style.top = y;
                }
            }
        }

        // update trophy count
        trophyTrayIcon.innerHTML = trophies.length + ' üèÜ';

        // update word count
        wordsTrayIcon.innerHTML = words.length + ' üìï';

        // update time
        clockTrayIcon.title = new Date();
        const time = clockTrayIcon.title.slice(16,24).split(':')
        clockTrayIcon.innerHTML = (time[0]%12?time[0]%12:12) + ':' + time[1];

        // fade in desktop, convert opacity to number
        loading || (document.body.style.opacity = Math.min(1,.02 + document.body.style.opacity*1));
    }

    // close all menus
    CloseMenus()
    {
        // hide all drop down menus
        for (const c of programsMenu.children)
            c.style.visibility = '';

        // hide menu
        menu.style.visibility = '';
    }

    // give trophy for local storage key
    GiveTrophy(key)
    {
        const keyParts = (key+'').split(',');
        keyParts.length = 4;
        if (keyParts.shift() == 'OS13kTrophy') 
            OS13k.Trophy(...keyParts, localStorage[key])
    }

    // toggle audio
    ToggleMute()
    {
        OS13k.StopSpeech();
        gain.gain.value = gain.gain.value ? 0 : defaultVolume;
        muteTrayIcon.innerHTML = gain.gain.value ? 'üîä' : 'üîá';
        localStorage.OS13kMute = !gain.gain.value;

        OS13k.Trophy('OS13k','Shut Up','üîá','Muted');
    }
} // OS13kManager
let OS13kManager = new _OS13kManager;

///////////////////////////////////////////////////////////////////////////////
// OS13kFolder - holds a list of programs

class OS13kFolder extends HTMLElement
{
	constructor(infos, x=0, y=0, parentFolder)
    {
		super();
        
        // add to desktop
        this.className    = 'folder';
        this.style.left   = x;
        this.style.top    = y;
        this.parentFolder = parentFolder;
        programsMenu.appendChild(this);
        
        // add programs to folder
        for (const info of infos)
            this.appendChild(info.program = new OS13kProgram(info));
        
        // get width offset and add new folders recursively
        for (const info of infos)
        {
            // create the folder and hook up to programs
            info.folder && (info.program.folder = new OS13kFolder(info.folder, this.getBoundingClientRect().right - 2, y, this));
            y += programHeight;
        }
    }

    SetActive()
    {
        // close menus so they can reopen with this active
        OS13kManager.CloseMenus();
        
        // set parent active
        this.parentFolder && this.parentFolder.SetActive();
        
        // make visible
        this.style.visibility = 'visible';
    }
} // OS13kFolder
customElements.define('o-f', OS13kFolder);

///////////////////////////////////////////////////////////////////////////////
// OS13kProgram - stores program info and handles loading from folders
    
class OS13kProgram extends HTMLElement
{
	constructor({x, y, name, icon='üí†', src='', width=720, height=405, author, folder, full=1, reload=1, sleep=1, resize=1, sticky, help, code})
    {
		super();
        
        // split up source by . to get extension
        const srcParts = src.split('.');
        
        // infer name from camel case src
        if (!name)
        {
            // split up source by / to get filename
            let srcCleanName = srcParts[0].split('/');
            
            // add spaces between lower case and capitals
            srcCleanName = srcCleanName[srcCleanName.length-1].replace(/([a-z](?=[A-Z]))/g, '$1 ');
            
            // make first letter uppercase
            name = srcCleanName.charAt(0).toUpperCase() + srcCleanName.slice(1);
        }
        
        // check for special extensions
        const extension = src? srcParts[1] : '';
        this.isDweet = extension == 'dweet';
        this.isShader = extension == 'shader';

        // set icon data
        this.className = 'program';
        this.name   = name;
        this.icon   = icon;
        this.src    = src;
        this.width  = width;
        this.height = height;
        this.author = author;
        this.sleep  = sleep;
        this.full   = full;
        this.reload = reload;
        this.code   = code || ((this.isDweet || this.isShader) && code == undefined);
        this.sticky = sticky;
        this.help   = help;
        this.resize = resize;
        this.key    = 'OS13kProgram' + this.src;
        
        // load saved program data
        this.LoadInfo();
        
        // set title if not folder
        folder || (this.title = name +
                ( this.isDweet ? ' - Dweet' :  this.isShader ? ' - Shader' : '') +
                (author ? '\nBy ' + author : ''));
            
        // icon
        const iconDisplay = document.createElement('div');
        iconDisplay.style = 'pointer-events:none;width:45;text-shadow:1px 1px 3px;text-align:center';
        iconDisplay.innerHTML = icon;
        this.appendChild(iconDisplay);
        
        // name
        const nameDisplay = document.createElement('div');
        nameDisplay.style = 'pointer-events:none;flex:1'
        nameDisplay.innerHTML = name;
        this.appendChild(nameDisplay);
        
        if (folder)
        {
            // folder arrow
            const folderDisplay = document.createElement('div');
            folderDisplay.style = 'pointer-events:none'
            folderDisplay.innerHTML = '&nbsp;&nbsp;‚ñ∂';
            this.appendChild(folderDisplay);
        }
        
        // save special programs
        name == 'Trophy Case' && trophyTrayIcon.SetProgram(this);
        name == 'Word List'   && wordsTrayIcon.SetProgram(this);
        name == 'Clock'       && clockTrayIcon.SetProgram(this);
        name == 'Help'        && this.saveInfo.open == undefined 
            && (helpProgram = this);

        // check if start active program or sticky open
        self == top && (this.src == localStorage.OS13kStartProgram ?
            startProgram = this :
            sticky && this.saveInfo.open && this.Open());
    }
    
    Move()
    {
        // unselect active program
        activeProgram && (activeProgram.className = 'program');

        // set active
        activeProgram = this;
        this.className = 'program programActive';
        
        // set call parent active 
        this.folder && this.folder.SetActive();
    }
    
    Open()
    {
        if (this.window)
        {
            // set window to be active if it exists
            this.window.SetActive();
            
            // prevent main document focus
            return false;
        }
        if (this.src)
        {
            // load save info
            this.LoadInfo();

            // get saved window position
            let x, y;
            if (this.saveInfo.x != undefined)
            {
                x = this.saveInfo.x;
                y = this.saveInfo.y;
            }
            else
            {
                // update window open positions
                x = windowOpenX;
                y = windowOpenY;
                (windowOpenX += titlebarHeight) > 400 && (windowOpenX = startWindowOpenX);
                (windowOpenY += titlebarHeight) > 200 && (windowOpenY = startWindowOpenY);
            }

            // open the window
            this.window || (this.window = new OS13kWindow(this, x, y));

            // update info
            finishedStartup && (this.wasOpened = 1);

            // save program info on open
            this.SaveInfo();
        }
        else if (!this.folder)
        {
            // close all windows if no src or folder
            for (const c of [...desktop.children])
                c.Close && c.Close()

            // reset window open position
            windowOpenX = startWindowOpenX;
            windowOpenY = startWindowOpenY;

            OS13k.Trophy('OS13k','Coffee Is For Closers','‚òï','Closed All');
        }
    }
    
    SetActive() { this.Open(); }
    
    Refresh()
    {
        // call refresh function in iframe if it exists
        this.window && this.window.iframeContent &&
            this.window.iframeContent.OS13kRefresh &&
            this.window.iframeContent.OS13kRefresh()
    }
    
    Toggle()
    {
        // toggle the program open or closed
        activeWindow && activeWindow == this.window ?
            this.window.Close() : this.Open();
    }
    
    LoadInfo()
    {
        // load saved program info from local storage
        const saveProgramJSON = localStorage[this.key];
        this.saveInfo = saveProgramJSON ? JSON.parse(saveProgramJSON) : {scale:1};
    }
    
    SaveInfo(open = 1)
    {
        // save program info to local storage
        localStorage[this.key] = JSON.stringify({
            open,
            x: this.window.style.left,
            y: this.window.style.top,
            scale: this.window.scale});
    }
    
    Close()
    {
        // remove start program if closed
        this.src == localStorage.OS13kStartProgram && 
            (localStorage.OS13kStartProgram = 0);
        this.SaveInfo(0);
        this.window = 0;
    }
} // OS13kProgram
customElements.define('o-p', OS13kProgram);

///////////////////////////////////////////////////////////////////////////////
// OS13kWindow - window to a running program, handles program loading

class OS13kWindow extends HTMLElement
{
	constructor(program, x, y)
    {
		super();

        // add to desktop
        desktop.appendChild(this);
        
        // save settings
        this.program = program;
        this.style.left = x;
        this.style.top = y;
        this.menu = menu;
        
        // shadow root
		this.shadow = this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = templateWindow.innerHTML;
        
        // title bar
        this.shadowRoot.appendChild(this.titlebar = document.createElement('div'));
        this.titlebar.id = 'titlebar';
        this.titlebar.title = program.title;
        
        // title bar wrapper
        this.titlebar.appendChild(this.nameWrapper = document.createElement('div'));
        this.nameWrapper.id = 'nameWrapper';

        // icon
        const iconDisplay = document.createElement('div');
        this.nameWrapper.appendChild(iconDisplay);
        iconDisplay.id = 'icon';
        iconDisplay.innerHTML = program.icon;
        
        // name
        const nameDisplay = document.createElement('div');
        this.nameWrapper.appendChild(nameDisplay);
        nameDisplay.id = 'name';
        nameDisplay.innerHTML = program.name;
        
        // create title bar icons
        const AddTitlebarIcon=(id, title)=>
        {
            const icon = document.createElement('div');
            icon.innerHTML = `<svg><use href=#icon-${icon.id = id}>`;
            icon.title = title;
            this.titlebar.appendChild(icon);
        }
        program.resize && 
            AddTitlebarIcon('grow', 'Grow', AddTitlebarIcon('shrink', 'Shrink'));
        program.full && AddTitlebarIcon('full', 'Full Screen');
        program.help ? 
            AddTitlebarIcon('help', 'Help') :
            program.code && AddTitlebarIcon('code', 'Code');
        program.reload && AddTitlebarIcon('reload', 'Reload');
        AddTitlebarIcon('close', 'Close');

        // create content wrapper
        const frameWrapper = this.frameWrapper = document.createElement('div');
        frameWrapper.style.background = '#000';
        this.shadowRoot.appendChild(frameWrapper);

        // create code/help display
        this.shadowRoot.appendChild( 
            this.codeDisplay = document.createElement('textarea'));
        this.codeDisplay.setAttribute('readOnly', 1);
        
        // resize window size to fit inner width while preserving aspect
        const width = program.resize ? 
            Math.min(program.width * this.program.saveInfo.scale, innerWidth-6) :
            program.width;
            
        // set width and height and clamp titlebar width
        this.titlebar.style.width      = 
        this.frameWrapper.style.width  = width;
        this.frameWrapper.style.height = width * program.height / program.width;
        this.scale = width / program.width;

        // create iframe
        frameWrapper.appendChild(this.iframe = document.createElement('iframe')); 
        this.iframe.id = 'frame';
        
        // announce game when first opened
        if (!program.wasOpened)
            OS13k.Speak(this.program.name, 1, 1, 1, 'ja');
        
        // add program name to words and dont speak
        OS13k.AddWords(this.program.name, 0); 
        
        // track if programs are loading
        ++loading;
        
        // wait for frame to load and set that it is not loading
        this.iframe.onload =e=> { try {

            // set up iframe          
            const iframeContent = this.iframeContent = e.target.contentWindow;

            // get the document and text, will fail if cross site
            const iframeDocument = iframeContent.document;
            
            // check for special extensions
            const hasExtension = program.isDweet || program.isShader
            
            // get the document text
            const iframeText = hasExtension ?
                iframeDocument.body.innerText : iframeDocument.body.innerHTML;

            // set help/code display
            this.codeDisplay.value = program.help || iframeText;

            // pass zzfx to iframe
            iframeContent.OS13k || (iframeContent.OS13k = OS13k);
            iframeContent.zzfx = zzfx;

            // prevent iframes context menu
            iframeContent.oncontextmenu =()=> false;

            // check for extensions
            if (hasExtension) 
            {
                // create full size canvas
                iframeDocument.body.innerHTML = 
                    `<canvas id=c width=1920 height=1080 style=` +
                    'width:100%;background:#' +
                    (program.isDweet ? 'fff' : '000') +'>';
                iframeDocument.body.style = 
                    'background:#111;' +
                    'overflow:hidden;' +
                    'margin:0;' +
                    'display:flex;' +
                    'align-items:center';

                // create dweet
                program.isDweet && iframeContent.eval(
                    'u=t=>{' + iframeText + '};' +
                    'x=c.getContext`2d`;' +
                    'S=Math.sin;' +
                    'C=Math.cos;' +
                    'T=Math.tan;' +
                    'R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;' +
                    'loop=t=>requestAnimationFrame(loop,' +
                        ( program.sleep? '(frame<9|document.hasFocus())&&' : '' ) +
                        'u((60*(frame++/60)-frame-1|0?frame-1:frame)/60));' +
                    'loop(frame=0)');

                // create shader
                program.isShader && iframeContent.eval(
                    'g=c.getContext`webgl2`;' +
                    'x=y=z=w=f=0;' +
                    'onmousemove=e=>e.buttons&&(x=e.x,y=c.height-e.y);' +
                    'onmousedown=e=>(x=z=e.x,y=w=c.height-e.y);' +
                    'onmouseup=e=>z=w=0;' +
                    's=parent.OS13k.CreateShader(c,`' + iframeText + '`);' +
                    'loop=t=>requestAnimationFrame(loop,' +
                        ( program.sleep? '(!t|document.hasFocus())&&' : '' ) +
                        '(c.width=innerWidth,' + 
                        'c.height=innerHeight,' + 
                        'g.uniform4f(g.getUniformLocation(s,"iMouse"),x,y,z,w),' +
                        'parent.OS13k.RenderShader(c,s,t/1e3,f++)));' + 
                    'loop(0)');
            }}
            catch (e) {} // could not load frame, possible cross site error

            // add taskbar icon if it doesnt exist (from being reloaded)
            this.taskbarIcon ||
                (this.taskbarIcon = new OS13kTaskbarIcon(program, this));

            // make visible
            this.style.visibility = this.iframe.style.visibility = 'visible';
            
            // only set active if not grabbing and not reloaded
            grabWindow || this.reloaded || this.SetActive();
    
            // update startup routine
            OS13kManager.HandleStartup(--loading);
        }
        
        // load the iframe
        this.iframe.src = program.src;
    }
    
    Open(e, target)
    {
        // set active but prevent clamping
        this.SetActive(1,0);
        
        // set grab window if name is clicked on
        if (target == this.nameWrapper)
        {
            // set this to be the grab window
            grabWindow = this
            
            // use grabbing cursor
            title.style.cursor = taskbar.style.cursor = 'grabbing';
            
            // prevent windows from getting focus
            desktop.style.pointerEvents = 'none';

            // save grab offset
            const rect = e.target.getBoundingClientRect();
            grabOffsetX = e.x - rect.left;
            grabOffsetY = e.y - rect.top;
            
            // allow main document focus
            return;
        }
        
        // check for title bar buttons
        target.id == 'full'        && this.FullScreen();
        target.id == 'reload'      && this.Reload();
        target.id == 'close'       && this.Close();
        target.id == 'shrink'      && this.Resize(this.scale - .2);
        target.id == 'grow'        && this.Resize(this.scale + .2);
        (target.id == 'help' || target.id == 'code') && this.ShowCode();
        
        // allow main document focus if code or grabbing
        return target == this.codeDisplay || grabWindow == this;
    }
    
    Resize(scale)
    {
        // change size of window
        const wNew = OS13k.Clamp(this.program.width * scale, 300, 2e3);
        const hNew = this.program.height * (this.scale = wNew / this.program.width);
        
        // set new size
        const w = parseFloat(this.frameWrapper.style.width);
        this.titlebar.style.width = this.frameWrapper.style.width = wNew;
        this.frameWrapper.style.height = hNew;
    
        // adjust window position for offset
        this.style.left = parseFloat(this.style.left) + w - wNew;
        
        // update program info
        this.program.SaveInfo();
    }
    
    SetActive(active=1, clamp=1)
    {
        OS13kManager.CloseMenus();
        
        // set style
        this.className = active? 'activeWindow' : '';
        this.titlebar.className = 'titlebar titlebar' 
            + (active && !loading? 'Active' : this.program.sticky ? 'Sticky' : '');
        (this.program.sleep ? this : this.titlebar).style.filter = 
            active? '' : 'saturate(.7)brightness(.7';

        // check if active
        if (!active)
            return;
        
        // save active program if finished startup and not sticky
        finishedStartup && !this.program.sticky && 
            (localStorage.OS13kStartProgram = this.program.src);

        // set focus to iframe
        !loading && this.iframeContent && this.iframeContent.focus();

        if (clamp)
        {
            // clamp window to screen
            const rect = this.getBoundingClientRect();
            this.style.left = OS13k.Clamp(rect.x, 0, innerWidth - rect.width);
            this.style.top = OS13k.Clamp(rect.y, taskbarHeight, 
                Math.max(taskbarHeight, innerHeight - rect.height));
        }

        if (activeWindow != this)
        {
            // deactivate old window
            activeWindow && activeWindow.SetActive(0);
            
            // set this to be active window
            activeWindow = this;

            // move z to top
            this.style.zIndex = ++topZ;

            // show menu buttons
            buttonFullScreen.style.display = this.program.full?   '' : 'none';
            buttonShowHelp.style.display   = this.program.help?   '' : 'none';
            buttonShowCode.style.display   = this.program.code?   '' : 'none';
            buttonReload.style.display     = this.program.reload? '' : 'none';
            buttonResetSize.style.display  = this.program.resize? '' : 'none';

            // set taskbar icon active if it exists
            // it may not exist yet if frame hasn't finished loading
            this.taskbarIcon && this.taskbarIcon.SetActive();
        }
        
        return false;
    }
    
    FullScreen()
    {
        // check if full screen allowed
        if (!this.program.full)
            return;
        
        // set full screen
        if (this.frameWrapper.webkitRequestFullScreen)
            this.frameWrapper.webkitRequestFullScreen();
        if (this.frameWrapper.mozRequestFullScreen)
            this.frameWrapper.mozRequestFullScreen();
            
        OS13k.Trophy('OS13k','Pro Gamer','üïπÔ∏è','Went Fullscreen');
    }
    
    ShowCode()
    {
        // toggle showing code
        this.codeDisplay.style.display = 
            (this.showCode = !this.showCode) ? 'block' : '';
        
        // add help to words
        OS13k.AddWords(this.program.help);
        
        this.program.help || OS13k.Trophy('OS13k','Hacker','üë®‚Äçüíª','Viewed Code');
    }
    
    Reload()
    {
        // clear if sticky note
        this.program.icon == '‚úçÔ∏è' && (localStorage.OS13kSn = '');
    
        // hide iframe and reload it
        this.iframe.style.visibility = '';
        this.iframeContent.location.reload();
        
        // set that it was reloaded
        this.reloaded = 1;
    }
    
    Close()
    {
        // close it up
        this.program.Close()
        this.taskbarIcon.remove();
        this.remove();
    }
} // OS13kWindow
customElements.define('o-w', OS13kWindow);

///////////////////////////////////////////////////////////////////////////////
// OS13kTaskbarIcon - icon on taskbar that can be used as shortcut

class OS13kTaskbarIcon extends HTMLElement
{
	constructor(program, windowOrFolder)
    {
		super();
        
        // create icon
        this.className = 'taskbarIcon';
        this.innerHTML = '<div style=pointer-events:none>' + program.icon;
        this.title = program.title || program.name;
        this.menu = windowOrFolder ? menu : programsMenu;
        
        // save window, only a folder if its the load icon
        this.windowOrFolder = windowOrFolder;
        
        // add to taskbar
        taskbarSpace.before(this);
    }
    
    Open()
    {
        // set active and allow window to be set active, dont clamp
        this.SetActive(1, 0);
        
        // allow main document focus if its the load icon
        return this == loadIcon;
    }
    
    SetActive(active=1)
    {
        // set window active
        active && this.windowOrFolder.SetActive();
    
        // load icon cant be the active taskbar item
        if (this == loadIcon) return;
        
        // set active style
        this.className = 'taskbarIcon' + (active ? ' taskbarIconActive' : '');
        
        // check if active
        if (!active) return;
            
        // unselect old taskbar icon if active
        activeTaskbarIcon && activeTaskbarIcon != this &&
            activeTaskbarIcon.SetActive(0);

        // set this to be active taskbar icon
        activeTaskbarIcon = this;
    }
    
} // OS13kTaskbarIcon
customElements.define('o-i', OS13kTaskbarIcon);

///////////////////////////////////////////////////////////////////////////////
// OS13kTrayIcon - icon on taskbar tray for OS shortcuts

class OS13kTrayIcon extends HTMLElement
{
	constructor(functionCall, title, icon)
    {
		super();
        
        // create icon
        this.className = 'trayIcon';
        this.functionCall = functionCall;
        this.title = title;
        this.innerHTML = icon;
        this.menu = 0;
        
        // add to tray
        tray.appendChild(this);
    }
    
    SetProgram(program)
    {
        this.program = program;
        this.title = program.title;
    }
    
    SetActive()  { this.Open();  }
    Open()       { this.program ? this.program.Toggle() : this.functionCall(); }
} // OS13kTrayIcon
customElements.define('o-t', OS13kTrayIcon);

///////////////////////////////////////////////////////////////////////////////
// Mouse Input

{
onmousedown =e=>
{
    // set there has been user input
    hadInput = 1;
    
    // check if clicked on load icon while programs menu was visible
    if (e.target == loadIcon && e.target.windowOrFolder.style.visibility)
    {
        // close menus
        OS13kManager.CloseMenus();
        
        // reactivate active window
        activeWindow && activeWindow.SetActive();
        
        // prevent main document from taking focus
        return false;
    }
    
    // close menus on mouse down
    OS13kManager.CloseMenus();

    // prevent stuck grab
    if (grabWindow) return onmouseup(e);
    
    // get orignal target
    const originalTarget = e.originalTarget || e.path[0];
    
    // check for non left click
    if (e.button)
    {
        // check for right click
        if (e.button == 2)
        {
            const target = (e.target.window || e.target);

            // don't do anything if code or button clicked on
            if (originalTarget.id != 'codeDisplay' && e.target.localName != 'button')
            {
                // set target active no clamp, use load icon if no valid target
                (target.SetActive ? target : loadIcon).SetActive(1, 0);

                // get which menu to open
                const contextMenu = e.target.menu ? e.target.menu : programsMenu;

                // show context menu
                contextMenu.style.left = e.x;
                contextMenu.style.top  = e.y;
                contextMenu.style.visibility = 'visible';
            }
        }
    
        // allow main document to take focus
        return;
    }

    // reset program menu position
    programsMenu.style.left = 0;
    programsMenu.style.top = taskbarHeight;

    // open on left click, reactivate window if no valid target
    return e.target.Open ? e.target.Open(e, originalTarget) :
        activeWindow && activeWindow.SetActive(1,0);
}

onmousemove =e=>
{
    if (grabWindow)
    {
        // update grab position
        grabWindow.style.left = e.x - grabOffsetX;
        grabWindow.style.top = e.y - grabOffsetY;
        
        // save info
        grabWindow.program.SaveInfo();
    }
    
    // handle mouse move
    e.target.Move && e.target.Move();
}

onmouseup =e=>
{       
    // set grab window active no clamp and set cursor to back to 
    grabWindow && grabWindow.SetActive(1, 0,
        title.style.cursor = taskbar.style.cursor
        = desktop.style.pointerEvents = '');
        
    // unset grab window, must happen after grab window is set active
    grabWindow = 0;
}

// prevent default right click context menu
oncontextmenu =e=> false

} // mouse input

///////////////////////////////////////////////////////////////////////////////
// Audio Setup

// init web audio
const audioContext = new (AudioContext || webkitAudioContext);
const gain = audioContext.createGain();
{
    // create buffer source and handle different browser audio calls
    audioContext.Z = audioContext.createBufferSource;
    audioContext.createBufferSource = (s = audioContext.Z())=>
    (
        s.start = s.start || s.noteOn,
        s.stop  = s.stop  || s.noteOff,
        s
    );

    // create gain node
    gain.connect(audioContext.destination);
    gain.gain.value = defaultVolume;
} // setup audio

///////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth 

const zzfx =      // play a sound
(
    // parameters
    volume = 1, randomness = .05, frequency = 220, attackIn = 0, sustainIn = 0, releaseIn = .1, shape = 0, shapeCurve = 1, slide = 0, deltaSlideIn = 0, pitchJumpIn = 0, pitchJumpTimeIn = 0, repeatTimeIn = 0, noise = 0, modulationIn = 0, bitCrush = 0, delayIn = 0, sustainVolume = 1, decayIn = 0,
    
    // init parameters
    PI2 = Math.PI*2,
    sampleRate = 44100,
    random = r => r*2*Math.random()-r,
    sign = v => v>0?1:-1,
    startSlide = slide *= 500 * PI2 / sampleRate**2,
    modPhase = sign(modulationIn) * PI2/4,
    startFrequency = frequency *= (1 + random(randomness)) * PI2 / sampleRate,
    attack = 99 + attackIn * sampleRate | 0,
    decay = decayIn * sampleRate | 0,
    sustain = sustainIn * sampleRate | 0,
    release = releaseIn * sampleRate | 0,
    delay = delayIn * sampleRate | 0,
    deltaSlide = deltaSlideIn * 500 * PI2 / sampleRate**3,
    modulation = modulationIn * PI2 / sampleRate,
    pitchJump = pitchJumpIn * PI2 / sampleRate,
    pitchJumpTime = pitchJumpTimeIn * sampleRate,
    repeatTime = repeatTimeIn * sampleRate,
    length = attack + decay + sustain + release + delay,
    b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, d=.5
)=>
{
    // generate waveform
    for(; i < length;b[i++] = s)
    {
        if (++c>bitCrush*100)                            // bit crush
        {
            c = 0;                                       // reset bit crush
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation - modPhase);    // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
                Math.sin((s%PI2)**3) :                   // 4 noise
                Math.max(Math.min(Math.tan(s),1),-1):    // 3 tan
                1-(2*s/PI2%2+2)%2:                       // 2 saw
                1-4*Math.abs(Math.round(s/PI2)-s/PI2):   // 1 triangle
                Math.sin(s);                             // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * (                              // envelope
                i < attack ? i/attack :                  // attack
                i < attack + decay ?                     // decay
                1-((i-attack)/decay)*(1-sustainVolume) : // decay falloff
                i < attack  + decay + sustain ?          // sustain
                sustainVolume :                          // sustain volume
                i < length - delay ?                     // release
                (length - i - delay)/release *           // release falloff
                sustainVolume :                          // release volume
                0)                                       // post release

            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i-delay]/2) : s;
        }

        t += 1 + random(noise);                      // noise
        tm += 1 + random(noise);                     // modulation noise
        frequency += slide += deltaSlide;            // frequency slide

        if (j && ++j > pitchJumpTime)                // pitch jump
        {
            frequency += pitchJump;                  // apply pitch jump
            startFrequency += pitchJump;             // also apply to start
            j = 0;                                   // reset pitch jump time
        }

        if (repeatTime && ++r > repeatTime)           // repeat
        {
            frequency = startFrequency;               // reset frequency
            slide = startSlide;                       // reset slide
            r = 1;                                    // reset repeat time
            j = j || 1;                               // reset pitch jump time
        }
    }

    return OS13k.PlaySamples(b);
} // zzfx

///////////////////////////////////////////////////////////////////////////////
// Start OS13k!

OS13kManager.Start();

///////////////////////////////////////////////////////////////////////////////
// Mobile Support (optional)

// save is touching and original mouse functions
let wasTouching, 
    onmouseupTouch   = onmouseup,
    onmousedownTouch = onmousedown,
    onmousemoveTouch = onmousemove;

(typeof ontouchstart != 'undefined') && (ontouchstart=()=>
{
    // prevent touch triggering mouse events
    onmouseup = onmousedown = onmousemove = 0;
    
    const RemoveHovers=element=>
    {
        // remove all hover effects
        for (let styleSheet of element.styleSheets)
        for (let i = styleSheet.rules.length; i--; )
            styleSheet.rules[i].selectorText &&
            styleSheet.rules[i].selectorText.match('hover') &&
            styleSheet.deleteRule(i);
    }
    
    // remove hovers from document
    RemoveHovers(document);
                
    // handle touch event
    const ProcessTouch=e=>
    {
        // check if touching
        const touching = e.touches.length;
        if (touching)
        {
            // set event pos
            e.x = e.touches[0].clientX;
            e.y = e.touches[0].clientY;

            // pass event to mousemove
            onmousemoveTouch(e);
            
            // give focus to main window
            window.focus();
        }

        // pass even to mouse down
        touching && !wasTouching && !e.target.folder && onmousedownTouch(e);

        // pass event to mouse up
        !touching && wasTouching && onmouseupTouch(e);

        // set was touching
        wasTouching = touching;
        
        // remove hovers from active window
        activeWindow && RemoveHovers(activeWindow.shadow);
        
        // prevent default
        return !e.cancelable;
    }
    
    // set touch events
    ontouchstart = ontouchmove = ontouchend = ontouchcancel = ProcessTouch;
});

</script>