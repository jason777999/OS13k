<!--

OS13k is a tiny operating system designed for a JS13k community project. It has native support for Shadertoys, Dweets, ZzFX, trophies, and much more.

Your mission, if you choose to accept it, is to help us fill it up with as much cool stuff as we can fit.

Please keep this project confidential!

‚úåÔ∏èüòÑ ‚ù§Ô∏è OS13k Team

-->

<title>OS13k - A tiny OS for JS13k</title>
<link rel=icon type=image/x-icon href='favicon.ico'/>
<meta name=viewport content='width=device-width,initial-scale=1,user-scalable=0'>
<script src=programs.js?94></script>

<!-- HTML above is OPTIONAL -->

<meta charset=utf-8>
<style>
body
{
    opacity:0;
    margin:0;
    overflow:hidden;
    font-family:arial;
    font-size:22;
    user-select:none;
    white-space:nowrap;
    background:#000;
}
#menu
{
    display:flex;
    flex-direction:column;
    background:#000;
}
.programMenu { background:linear-gradient(#fff,#777); }
#menu, .programMenu
{
    visibility:hidden;
    position:absolute;
    z-index:20000;
    box-shadow:5px 5px 9px;
    border:2px solid;
}
.program
{
    font-size:18;
    height:18;
    padding:4;
}
.windowActive { border:3px solid #aaa; }
#taskbar
{
    position:absolute;
    z-index:10000;
    width:100%;
    background:linear-gradient(#888,#333);
    box-shadow:0px 1px 9px;
    border:2px solid;
    left:-2;
}
.taskbarIcon { width:50; height:40; text-shadow:1px 1px 3px #000; }
.programActive,
.taskbarIconActive         { background:linear-gradient(#ff8,#fff); }
.taskbarIcon:hover         { background:linear-gradient(#fff,#44f); }
#tray
{
    margin:2;
    padding-left:9;
    padding-right:9;
    color:#fff;
    background:linear-gradient(#000,#333);
    border:1px solid;
    border-radius:6px;
    text-shadow:1px 1px 3px #000;
}
.trayIcon       { padding:2; }
.trayIcon:hover { background:#fff3; }
.popup
{
    position:relative;
    z-index:10000;
    width:200;
    padding:8;
    pointer-events:none;
    overflow:hidden;
    white-space:normal;
    text-align:center;
    background:linear-gradient(#eee,#888);
    box-shadow:9px 9px 19px;
    border:2px solid;
    border-radius:9px;
}
.trophyIcon
{
    padding:9;
    font-size:40;
    text-shadow:2px 2px 4px;
    white-space:nowrap;
}
#background
{
    position:absolute;
    width:100%;
    height:100%;
    color:#0002;
    font-family:impact;
    font-size:30vw;
    font-weight:900;
}
.program, #taskbar, .taskbarIcon, #background, #tray
{
    display:flex;
    align-items:center;
    justify-content:center;
}
</style>
<template id=T>
<style>
:host
{
    visibility:hidden;
    overflow:hidden;
    position:absolute;
    background:#000;
    box-shadow:5px 5px 9px;
    border:3px solid #222;
    border-radius:6px;
}
.titlebar
{
    height:34;
    font-size:24;
    display:flex;
    align-items:center;
    overflow:hidden;
    white-space:nowrap;
    background:linear-gradient(#ccc,#444);
    border-bottom:3px solid;
}
.titlebarActive { background:linear-gradient(#eee,#88f); }
.titlebarSticky { background:linear-gradient(#ccc,#844); }
#name           { width:100%; overflow:hidden; cursor:grab; }
#icon           
{ 
    display:inline;
    text-shadow:1px 1px 3px #000;
    margin-left:9;
    margin-right:9;
    pointer-events:none;
}
#frame
{
    width:100%;
    height:100%;
    background:#fff;
    border:none;
    visibility:hidden;
}
#codeDisplay
{
    width:100%;
    height:99;
    resize:none;
    display:none;
    background:#000;
    color:#fff;
    border:2px solid #fff;
    outline:0;
}
#full:hover   { background:#fff; }
#help:hover   { background:#0ff; }
#code:hover   { background:#f0f; }
#shrink:hover { background:#0ff; }
#grow:hover   { background:#0f0; }
#reload:hover { background:#ff0; }
#close:hover  { background:#f00; }
</style>
</template>
<div id=background></div>
<div id=desktop>
<div id=taskbar>
<div id=taskbarSpace style=flex:1></div>
<div id=tray></div>
</div>
<div id=popups style=float:right></div>
<div id=programsMenu style=position:absolute></div>
<div id=menu>
<button id=buttonFullScreen>Fullscreen
<button id=buttonCode>Code
<button id=buttonHelp>Help
<button id=buttonResetSize>Reset Size
<button id=buttonReload>Reload
<button id=buttonClose>Close
<script>

'use strict';

///////////////////////////////////////////////////////////////////////////////
// OS13k Debug (remove from minified)

const OS13kVersion = 58;
{
    // version check, clear local storage if older
    if (localStorage.OS13kVersion && localStorage.OS13kVersion != OS13kVersion)
    {
        alert('OS13k version out of date! System reset in 3, 2, 1...');
        localStorage.clear();
    }

    localStorage.OS13kVersion = OS13kVersion;

    // load default programs if none found
    var programsDefault = 0;
    if (typeof programs == 'undefined')
    {
        alert('No programs found, using defaults!')

        var sticky=2**0, reload=2**1, awake=2**2, full=2**3, resize=2**4, code=2**5;
        var defaultFlags = full|reload|resize, defaultWidth = 720, defaultHeight = 405;
        var programs = 
        [
            [,'‚ùå',,,,'Close All'],
            ['help.html','<b><span style=color:#0f0>?',380,400],

            [,'‚öôÔ∏è',,,,'System',,
            [
                ['system/settings.html','üéöÔ∏è',470,160,sticky],
                ['system/trophyCase.html','üèÜ',,,resize|sticky],
                ['system/wordList.html','üìï',,,resize|sticky],
                ['system/clock.dweet.js','üï∞Ô∏è',200,200,sticky|code|awake],
                ['system/systemTest.html',,,,resize|code|sticky],
            ]]
        ];
    }
} // debug stuff

///////////////////////////////////////////////////////////////////////////////
// Minification Stuff

{
// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs localStorage.OS13k, OS13k, iframeContent.zzfx
// @js_externs OS13k.Clamp, OS13k.Percent, OS13k.Lerp
// @js_externs OS13k.Random, OS13k.randomSeed, iframeContent.OS13kReload
// @js_externs OS13k.Trophies, OS13k.Trophy, OS13k.GetTrophy
// @js_externs OS13k.PlaySeed, OS13k.PlaySamples, OS13k.Note
// @js_externs OS13k.Speak, OS13k.StopSpeech
// @js_externs OS13k.Settings(), OS13k.SaveSettings()
// @js_externs OS13k.CreateShader, OS13k.RenderShader
// @js_externs OS13k.KeyDirection, OS13k.KillHTML, OS13k.Popup
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==

// Minification Steps
// 1. Remove touch support and optional code
// 2. Paste programs directly below here
// 3. Remove optional stuff listed below
// 4. Verify that it works the same
// 5. HTML Minifier http://minifycode.com/html-minifier/
// 6. Google Closure https://closure-compiler.appspot.com/home
// 7. Terser no extra compression https://xem.github.io/terser-online/
// 8. Zip
// 9. Advzip "advzip -z -4 -i 1000 OS13kMin.zip"

// Rework stuff marked OPTIONAL for final build
// - all files must be packed together to save space
// - smaller webgl names r10215
// - move css into code, get rid of names

} // Minification Stuff

///////////////////////////////////////////////////////////////////////////////
// OS13k Client Interface

class _OS13k
{

/////////////////////////////////////////////////////////////////////////////
// OS13k Math

    Clamp   (a, min=0, max=1)  { return Math.min(Math.max(a, min), max); }
    Percent (v, a, b)          { return b-a ? this.Clamp((v-a)/(b-a), 0, 1) : 0; }
    Lerp    (p, a, b)          { return a + this.Clamp(p, 0, 1) * (b-a); }
    Random  (max=1, min=0)    
    {
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= (this.randomSeed||-1) << 13;
        this.randomSeed ^= this.randomSeed >> 17;
        this.randomSeed ^= this.randomSeed << 5;
        return this.Percent(Math.abs(this.randomSeed) % 1e9 / 1e9, min, max);
    }

/////////////////////////////////////////////////////////////////////////////
// OS13k Trophies
    
    // get the trophy list
    Trophies() { return [...trophies]; }

    // award player with trophy, returns 0 if already owned
    Trophy(game='', name='', icon='', message='', language='ja')
    {
        // replace commas and apostrophes
        const Clean=string=>(string+'').replace(/`/g, "'").replace(/,/g, '');
        game    = Clean(game);
        name    = Clean(name);
        icon    = Clean(icon);
        message = Clean(message);
        
        // build key
        const key = game + `,${ name },` + icon;
        
        // remove html tags
        icon    = this.KillHTML(icon,    maxWordLength, 1);
        name    = this.KillHTML(name,    maxWordLength, 1);
        game    = this.KillHTML(game,    maxWordLength, 1);
        message = this.KillHTML(message, maxWordLength, 1);
        
        // find in trophy list
        const i = trophies.findIndex(e=>e[4]==key);
        
        // skip if same message
        if (i >=0 && trophies[i][3] == message) return 0;
        
        // add or update trophy list
        const trophyData = [game, name, icon, message, key];
        i < 0 ? trophies.unshift( trophyData ) :
            trophies[i] = trophyData;

        // save trophy
        localStorage['OS13kTrophy,' + key] = message;
        
        // reload trophy window
        trophyTrayIcon.program && trophyTrayIcon.program.Reload();
        
        // use game as name if there is no name
        name || game && (name = game, game = '');

        // add trophy popup
        this.Popup(
            `<div class=trophyIcon>${ 
                icon || 'üèÜ' }</div><div><b>${ // icon
                name }</b><br><i>${            // name
                game }</i></div>` +            // game
                message,                       // message
            name || game,                      // speak
            language);                         // language
            
        // save trophies
        OS13k.Save();
        
        // return trophy data
        return trophyData;
    }
    
    // get message, 0 if no trophy
    GetTrophy(game, name)
    {
        // find in trophy list
        const i = trophies.findIndex(e=>e[0]==game & e[1]==name);
        
        // return trophy message
        return i < 0 ? 0 : trophies[i][3];
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Audio

    // play zzfx sound from seed
    PlaySeed(seed, lengthScale=1, volume=1, randomness=.05, frequency)
    {
        if (typeof seed == 'string')
        {
            const splitSeed = seed.split(',');
            seed = parseFloat(splitSeed[0]);
            splitSeed.length > 1 && parseFloat(lengthScale = splitSeed[1]);
            splitSeed.length > 2 && parseFloat(volume = splitSeed[2]);
        }
    
        // set random seed
        this.randomSeed = seed;
        
        // clamp max length
        lengthScale = OS13k.Clamp(lengthScale, .1, 5);
        
        // helper functions
        const R=()=>this.Random(), C=()=>R()<.5?R():0, S=()=>C()?1:-1,
        
        // randomize sound length
        attack  = R()**3/4*lengthScale,
        decay   = R()**3/4*lengthScale,
        sustain = R()**3/4*lengthScale,
        release = R()**3/4*lengthScale,
        length  = attack + decay + sustain + release,
        f = R()**2*2e3;
        
        // generate random sound
        return zzfx
        (
           volume,           // volume
           randomness,       // randomness
           frequency || f, // frequency
           attack,           // attack
           sustain,          // sustain
           release,          // release
           R()*5|0,          // shape
           R()**2*3,         // shapeCurve
           C()**3*99*S(),    // slide
           C()**3*99*S(),    // deltaSlide
           C()**2*1e3*S(),   // pitchJump
           R()**2 * length,  // pitchJumpTime
           C() * length,     // repeatTime
           C()**4,           // noise
           C()**3*9*S(),     // modulation
           C()**4,           // bitCrush
           C()**3/2,         // delay
           1 - C(),          // sustain volume
           decay             // decay
        );
    }
    
    // play raw audio sample data
    PlaySamples(samples, sampleRate=44100)
    {
        // create source and buffer
        const buffer = audioContext.createBuffer(1, samples.length, sampleRate)
        buffer.getChannelData(0).set(samples);

        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(gain);
        source.start();
        return source;
    }
    
    // get frequency of a musical note on a diatonic scale
    Note(semitoneOffset=0, rootNoteFrequency=440)
    { return rootNoteFrequency * 2**(semitoneOffset/12); }

    // speak the text
    Speak(text, rate=1, pitch=1, volume=1, language='en', stopSpeech)
    {
        // common languages (not supported in all browsers)
        // it - italian,  fr - french, de - german,  es - spanish, pl - polish
        // ja - japanese, hi - hindi,  ru - russian, zh - chinese, ko - korean
    
        // set utterance parameters
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.volume = volume * gain.gain.value * 3;
        utterance.pitch = pitch;
        utterance.rate = rate;
        utterance.lang = language;

        // stop speech if set
        stopSpeech && OS13kSystem.StopSpeech();

        // play speech
        settings[1] && speechSynthesis && speechSynthesis.speak(utterance);
    }
        
/////////////////////////////////////////////////////////////////////////////
// OS13k Shaders

    // create pixel shader
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // use hardcoded values to save space
        const xVERTEX_SHADER       = 35633;
        const xARRAY_BUFFER        = 34962;
        const xSTATIC_DRAW         = 35044;
        const xBYTE                = 5120;
        const xFRAGMENT_SHADER     = 35632;
        const xCOMPILE_STATUS      = 35713;
        const xTEXTURE_2D          = 3553;
        const xUNPACK_FLIP_Y_WEBGL = 37440;
        const xTEXTURE_MIN_FILTER  = 10241;
        const xLINEAR              = 9729;

        // create a simple pass through vertex shader
        const vertexShader = x.createShader(xVERTEX_SHADER);
        x.shaderSource(vertexShader,
            '#version 300 es\n' +
            'in vec4 c;' +
            'void main()' +
            '{gl_Position=c;}');
        x.compileShader(vertexShader);
        
        // create vertex buffer that is a big triangle that covers the screen
        const vertexBuffer = xARRAY_BUFFER;
        x.bindBuffer(vertexBuffer, x.createBuffer());
        x.bufferData(vertexBuffer, new Int8Array([-3,1,1,-3,1,1]), xSTATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0, 2, xBYTE, 0, 0, 0); // 2D vertex
        
        // check vertex shader for errors
        //if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
        //    throw x.getShaderInfoLog(vertexShader);
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(xFRAGMENT_SHADER);
        const shaderProgramCode = 
            '#version 300 es\n' +
            'precision mediump float;' +
            'uniform float iTime;' +
            'uniform int iFrame;' +
            'uniform vec4 iMouse;' +
            'uniform vec3 iResolution;' +
            'uniform sampler2D iChannel0;' +
            'out vec4 c;\n' +
            code +
            '\nvoid main()' +
            '{mainImage(c,gl_FragCoord.xy);' +
            'c.a=1.;}';
        x.shaderSource(pixelShader, shaderProgramCode);
        x.compileShader(pixelShader);

        // check pixel shader for errors OPTIONAL
        //if (!x.getShaderParameter(pixelShader, xCOMPILE_STATUS))
        //    throw x.getShaderInfoLog(pixelShader);

        // create texture
        x.bindTexture(xTEXTURE_2D, x.createTexture());
        x.texParameteri(xTEXTURE_2D, xTEXTURE_MIN_FILTER, xLINEAR);
        x.pixelStorei(xUNPACK_FLIP_Y_WEBGL, 1); 
        
        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    // render a pixel shader
    RenderShader(canvas, shaderProgram, time=0, frame=0, X, Y, Z, W)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // use hardcoded values to save space
        const xRGBA          = 6408;
        const xUNSIGNED_BYTE = 5121;
        const xTRIANGLE_FAN  = 6;
        const xTEXTURE_2D    = 3553;
        
        // set uniforms
        x.uniform3f(x.getUniformLocation(shaderProgram,'iResolution'), 
            canvas.width, canvas.height, 1);
        x.uniform1f(x.getUniformLocation(shaderProgram,'iTime'), time);
        x.uniform1f(x.getUniformLocation(shaderProgram,'iFrame'), frame);
        x.uniform1i(x.getUniformLocation(shaderProgram,'iChannel0'), 0);
        x.uniform4f(x.getUniformLocation(shaderProgram,'iMouse'), X, Y, Z, W);
        
        // render shader
        x.drawArrays(xTRIANGLE_FAN, 0, 3);
        
        // set texture to the newly rendered image
        x.texImage2D(xTEXTURE_2D, 0, xRGBA, xRGBA, xUNSIGNED_BYTE, canvas);
    }

/////////////////////////////////////////////////////////////////////////////
// OS13k Input

    // get direction from wasd or arrow keys
    KeyDirection(keyCode)
    {
        let x=0, y=0;
        (keyCode == 87 | keyCode == 38) && ++y; // up
        (keyCode == 83 | keyCode == 40) && --y; // down
        (keyCode == 68 | keyCode == 39) && ++x; // right
        (keyCode == 65 | keyCode == 37) && --x; // left
        return {x, y};
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Text
    
    // replace html tags in a string
    KillHTML(string, maxLength)
    {
        // convert to string
        return (string+='')
        
            // clamp max length
            .substring(0, maxLength? maxLength: string.length)
            
            // replace < with &lt;
            .replace(/</g,'&lt;');
    }
    
    Popup(html, speak, language)
    {
        // create the popup
        const popup = popups.appendChild(document.createElement('div'));
        popup.className = 'popup';
        popup.innerHTML = html;
        popup.speak = speak;
        popup.speakLanguage = language;
        popup.style.visibility = 'hidden';
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Seralization
    
    Save()
    {   
        // save data if finished startup
        finishedStartup && (
        localStorage.OS13k = JSON.stringify(
        {
            t:trophies,
            s:settings,
            i:programInfos,
            p:startProgramName = startProgram ? startProgram.name : ''
        }));
        
        // volume
        OS13kSystem.SetVolume(settings[0]);
        
        // speech
        settings[1] || OS13kSystem.StopSpeech();
        
        // background
        background.style.background = 
            `linear-gradient(${settings[3]},${settings[4]})`;
        background.innerText = settings[5];
        
        // popups
        settings[2] || (popups.innerHTML = '');
        
        // filter
        desktop.style.filter = settings[6][1];
        background.style.filter = settings[6][1];
    }
    
    Load()
    {
        // use defaults if no settings found
        if (!localStorage.OS13k) return;
    
        // load data
        const saveData   = JSON.parse(localStorage.OS13k);
        trophies         = saveData.t;
        settings         = saveData.s;
        programInfos     = saveData.i;
        startProgramName = saveData.p;
    }
    
    Settings() { return settings; }
    
    SaveSettings(volume, speech, showPopups, color1, color2, text, filter)
    {
        // set settings and save
        settings = 
        [
            gain.gain.value = volume,
            speech,
            showPopups,
            color1,
            color2,
            text,
            filter
        ];
        this.Save();
    }
    
}; // _OS13k
var OS13k = new _OS13k;

///////////////////////////////////////////////////////////////////////////////
// OS13k Variables

const taskbarHeight = 44, titlebarHeight = 37, programHeight = 26,
      startWindowOpenX = 9, startWindowOpenY = 51,
      popupTime = 3, defaultVolume = .3, maxWordLength = 32,

    // increment to force pages to be refreshed OPTIONAL
    forceRefresh = '?1016',

    // init web audio
    audioContext = new AudioContext, gain = audioContext.createGain();
      
let grabWindow, grabOffsetX, grabOffsetY, finishedStartup,
    windowActive, activeProgram, helpProgram, activeTaskbarIcon, loadIcon,
    lastActiveElement, topZ = 0, loading = 0, hadInput = 0,
    windowOpenX = startWindowOpenX, windowOpenY = startWindowOpenY,
    startProgram, startProgramName, trophyTrayIcon, settingsTrayIcon,  
    clockTrayIcon, programInfos = [], trophies = [],
    
    // default settings (volume, speech, filter, bgcolor)
    settings = [.3, 1, 1, '#222233', '#332222', 'OS13k', 0];

///////////////////////////////////////////////////////////////////////////////
// OS13k System Functions - handles non client facing features of OS13k

class _OS13kSystem
{
    Start()
    {
        // connect gain
        gain.connect(audioContext.destination);
        
        // create tray icons
        trophyTrayIcon    = new OS13kTrayIcon();
        settingsTrayIcon  = new OS13kTrayIcon();
        clockTrayIcon     = new OS13kTrayIcon();
        
        // load os13k data
        OS13k.Save(OS13k.Load());
    
        // listen for trophies from other windows
        window.onstorage=e=> this.CheckForTrophy(e.key);

        // stop spech if page is unloaded
        document.body.onunload = OS13kSystem.StopSpeech();

        // set button functions
        buttonFullScreen.onmousedown =()=> windowActive.FullScreen();
        buttonHelp.onmousedown       =
        buttonCode.onmousedown       =()=> windowActive.ShowCode();
        buttonResetSize.onmousedown  =()=> windowActive.Resize(1);
        buttonReload.onmousedown     =()=> windowActive.Reload();
        buttonClose.onmousedown      =()=> windowActive.Close();

        // create the load program taskbar icon and add folders/programs
        loadIcon = new OS13kTaskbarIcon( {icon:'üíæ', name:'Load Program'} );
        loadIcon.windowOrMenu = new OS13kProgramMenu(programs);
        
        // welcome message
        OS13k.Trophy('','Welcome to OS13k!','üëã');

        // search local storage for new trophies (from other JS13k games)
        for (const key in localStorage) this.CheckForTrophy(key);

        // try to handle startup now in case no programs are loading
        this.UpdateStartup();

        // kick off update
        this.Update();
    }

    // wait for startup to finish
    UpdateStartup()
    {
        // skip until not loading and finished startup
        if (loading | finishedStartup) return;

        // open start program (check top to stop infinite recursion if meta)
        startProgram = startProgram || helpProgram;
        startProgram && self == top | startProgram.sticky && startProgram.Open();
            
        // finish startup after opening startup programs
        finishedStartup = 1;
        
        // save os13k data
        OS13k.Save();
    }

    // main update loop
    Update()
    {
        // request new animation frame
        requestAnimationFrame(OS13kSystem.Update);

        // fade in desktop, convert opacity to number
        loading || (document.body.style.opacity 
            = Math.min(1,.02 + document.body.style.opacity*1));

        // update trophy count
        trophyTrayIcon.innerHTML = trophies.length + ' üèÜ';

        // update time
        clockTrayIcon.title = new Date();
        const time = clockTrayIcon.title.slice(16,24).split(':');
        clockTrayIcon.innerHTML = (time[0]%12?time[0]%12:12) + ':' + time[1];
            
        // listen for iframe becomming new active element
        const activeElement = document.activeElement;
        if (lastActiveElement != activeElement)
        {
             // set active element
            activeElement.SetActive && activeElement.SetActive();
            lastActiveElement = activeElement;

            // set that we had input if user selected a window
            windowActive == activeElement && (hadInput = 1);
        }

        // show popups after startup is finished and there was input
        if (!finishedStartup || !hadInput) return;
        
        // update popups, use copy to prevent skipping if removed
        let offsetHeight = 0, i = 0;
        for(const popup of [...popups.children])
        {
            // speak popup
            popup.speak && OS13k.Speak(popup.speak, 1, 1, 1, popup.speakLanguage);
            popup.speak = 0;
            
            if (!settings[5])
                popups.removeChild(popup);
            else if (!document.fullscreenElement)
            {
                // move popup up, set to bottom if it was invisible
                let y = popup.style.visibility ? 
                     innerHeight : parseFloat(popup.style.top) + offsetHeight - 9;
                popup.style.visibility = '';
                
                if (y < taskbarHeight)
                {
                    // stop popup below taskbar
                    y = taskbarHeight;

                    // fade out popup if at top
                    if (!i++ && !(popup.style.opacity = (popup.style.opacity || popupTime) - .01))
                    {
                        // remove when invisible and adjust for height
                        const rect = popup.getBoundingClientRect();
                        offsetHeight += rect.height;
                        popups.removeChild(popup);
                    }
                }

                // set popup position
                popup.style.top = y;
            }
        }
    }

    // close all menus
    CloseMenus()
    {
        // hide all menus
        for (const child of programsMenu.children)
            child.style.visibility = menu.style.visibility = '';
            
            
        // unselect active program
        activeProgram && (activeProgram.className = 'program');
    }

    // try to give trophy if key is valid
    CheckForTrophy(key)
    {
        const keyParts = key.split(',');
        return keyParts.shift() == 'OS13kTrophy' &&
            OS13k.Trophy(...keyParts, localStorage[key]);
    }

    // set audio volume
    SetVolume(volume)
    {
        // set gain and stop all speech if muted
        (gain.gain.value = volume) || 
            OS13kSystem.StopSpeech(OS13k.Trophy('OS13k','Shut Up!','üîá','Muted'));
    }
    
    // stop any current or queued speech
    StopSpeech() { speechSynthesis && speechSynthesis.cancel(); }
    
} // OS13kSystem
const OS13kSystem = new _OS13kSystem;

///////////////////////////////////////////////////////////////////////////////
// OS13kProgramMenu - holds a list of programs

class OS13kProgramMenu extends HTMLElement
{
	constructor(infos, y=0, parentMenu)
    {
		super();
        
        // add to programs menu
        this.className    = 'programMenu';
        this.style.left   = parentMenu && parentMenu.getBoundingClientRect().right - 2;
        this.style.top    = y;
        this.parentMenu   = parentMenu;
        programsMenu.appendChild(this);

        // add programs to menu
        for (const info of infos)
        {
            // create program and add it to menu
            const folder = info[7];
            this.appendChild(new OS13kProgram(folder ? 
                new OS13kProgramMenu(folder, y, this) : this, ...info));
                
            // add program height as we move down the list
            y += programHeight;
        }
    }

    SetActive()
    {
        // close menus so they can reopen with this active
        OS13kSystem.CloseMenus();
        
        // set parent active
        this.parentMenu && this.parentMenu.SetActive();
        
        // make visible
        this.style.visibility = 'visible';
    }
} // OS13kProgramMenu
customElements.define('m-', OS13kProgramMenu);

///////////////////////////////////////////////////////////////////////////////
// OS13kProgram - stores program info and handles loading from folders
    
class OS13kProgram extends HTMLElement
{
	constructor(programMenu, src='', icon='üí†', width=defaultWidth, height=defaultHeight, flags, name='', help='', folder)
    {
		super();
        
        // split source by . to get extension OPTIONAL
        const srcParts = src.split('.');
        
        // get name from camel case src OPTIONAL
        if (!name)
        {
            // split source by / to get filename
            let srcCleanName = srcParts[0].split('/');
            
            // add spaces between lower case and capitals
            srcCleanName = srcCleanName[srcCleanName.length-1].replace(/([a-z](?=[A-Z]))/g, '$1 ');
            
            // make first letter uppercase
            name = srcCleanName.charAt(0).toUpperCase() + srcCleanName.slice(1);
        }
        
        // check for special extensions
        const extension = src ? srcParts[1] : '';
        this.isDweet = extension == 'dweet';
        this.isShader = extension == 'shader';

        // set icon data
        this.className = 'program';
        this.src    = src;
        this.icon   = icon;
        this.width  = width;
        this.height = height;
        this.name   = name;
        this.folder = folder;   
        this.key    = 'OS13kP' + src;
        this.programMenu = programMenu;
        
        // set code only if help not shown or if has extension and not disabled
        this.Fc = !(this.help = help) && 
            (flags & code || ((this.isDweet || this.isShader) && flags == undefined));
            
        // set flags
        flags = flags || defaultFlags;
        this.sticky   = flags & sticky;
        this.reload   = flags & reload;
        this.awake    = flags & awake;
        this.full     = flags & full;
        this.resize   = flags & resize;
        
        // set code only if help not shown or if has extension and not disabled
        this.code = !(this.help = help) && 
            (code || ((this.isDweet || this.isShader) && code == undefined));
        
        // set title if not a folder
        this.title = folder ? '' : name;
        
        // load saved program data
        this.LoadInfo();
        
        // create div for icon to auto close html tags
        const iconDisplay = this.appendChild(document.createElement('div'));
        iconDisplay.style = 'pointer-events:none;width:45;text-shadow:1px 1px 3px #000;text-align:center';
        iconDisplay.innerHTML = icon;
        
        // name and folder
        this.innerHTML += `<div style=flex:1;padding-right:9;pointer-events:none>${
            name }</div>` + (folder? '‚ñ∂' : '');
        
        // save special programs
        name == 'Settings'    && settingsTrayIcon.SetProgram(this);
        name == 'Trophy Case' && trophyTrayIcon.SetProgram(this);
        name == 'Clock'       && clockTrayIcon.SetProgram(this);
        name == 'Help'        && this.saveInfo.open == undefined 
                              && (helpProgram = this);

        // check if start program or sticky open
        this.sticky ? this.saveInfo.open && this.Open() :
            this.name == startProgramName && (startProgram = this); 
    }
    
    Move()
    {
        // set container program menu active 
        this.programMenu && this.programMenu.SetActive();
        
        // set active
        activeProgram = this;
        this.className = 'program programActive';
    }
    
    Open()
    {
        if (this.window)
        {        
            // set window to be active and clamp
            this.window.SetActive(1, 1);
            
            // prevent main document focus
            return false;
        }
        if (this.src)
        {
            // get saved window position
            let x = this.saveInfo.x, y = this.saveInfo.y;
            
            // update window open positions if no position was set
            x || (
                x = windowOpenX,
                y = windowOpenY,
                (windowOpenX += titlebarHeight) > 400 && (windowOpenX = startWindowOpenX),
                (windowOpenY += titlebarHeight) > 200 && (windowOpenY = startWindowOpenY));

            // open the window
            this.window = new OS13kWindow(this, x, y);

            // update info and save
            this.SaveInfo();
        }
        else if (!this.folder)
        {
            // close all windows if no src or folder
            for (const c of [...desktop.children])
                c.Close && c.Close();

            // reset window open position
            windowOpenX = startWindowOpenX;
            windowOpenY = startWindowOpenY;

            OS13k.Trophy('OS13k','Coffee Is For Closers','‚òï','Closed All');
        }
    }
    
    SetActive() { this.Open(); }
    
    // call reload function in iframe if it exists
    Reload()
    {
        this.window && this.window.iframeContent &&
            this.window.iframeContent.OS13kReload &&
            this.window.iframeContent.OS13kReload();
    }
    
    // toggle the program open or closed
    Toggle()
    {
        windowActive && windowActive == this.window ?
            this.window.Close() : this.Open();
    }
    
    // load saved program info from local storage
    LoadInfo() 
    {
        // find in program info list
        const i = programInfos.findIndex(e=>e.name==this.name);
        this.saveInfo = i < 0 ? {} : programInfos[i];
    }
   
    // save program info to local storage and reset settings if non sticky closed
    SaveInfo(open = 1)
    {
        // build the save info
        this.saveInfo = 
        {
            name: this.name,
            open,
            x: open | this.sticky ? this.window.style.left : 0,
            y: this.window.style.top,
            scale: open | this.sticky ? this.window.scale : 1
        }
        
        // add to programs info and save
        const i = programInfos.findIndex(e=>e.name==this.name);
        OS13k.Save(i < 0 ? programInfos.push(this.saveInfo) 
            : programInfos[i] = this.saveInfo);
    }
    
} // OS13kProgram
customElements.define('p-', OS13kProgram);

///////////////////////////////////////////////////////////////////////////////
// OS13kWindow - window to a running program, handles program loading

class OS13kWindow extends HTMLElement
{
	constructor(program, x, y)
    {
		super();

        // add to desktop
        desktop.appendChild(this);
        
        // save settings
        this.program = program;
        this.style.left = x;
        this.style.top = y;
        this.menu = menu;
        
        // shadow root
		this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = T.innerHTML;
        
        // title bar
        this.titlebar = this.shadowRoot.appendChild(document.createElement('div'));
        this.titlebar.id = 'titlebar';
        this.titlebar.title = program.title;
        
        // title bar name
        this.name = this.titlebar.appendChild(document.createElement('div'));
        this.name.id = 'name';
        
        // create div for icon to auto close html tags
        const icon = this.name.appendChild(document.createElement('div'));
        icon.id = 'icon';
        icon.innerHTML = program.icon;

        // name
        this.name.innerHTML += program.name;
       
        // create title bar icons
        const AddTitlebarIcon=(id, title, svg, svgShape='path')=>
        {
            const icon = this.titlebar.appendChild(document.createElement('div'));
            icon.id = id;
            icon.title = title;
            icon.innerHTML = 
            `<svg style=height:100%;width:28;pointer-events:none viewBox='0 0 10 10'><${svgShape} stroke=#000 fill=none ${svg} />`;
        }
        program.resize && 
            AddTitlebarIcon('grow', 'Grow', 'd="M2 5L8 5M5 8L5 2"',
            AddTitlebarIcon('shrink', 'Shrink', 'd="M2 5L8 5"'));
        program.full && AddTitlebarIcon(
            'full', 'Full Screen', 'x=1 y=2 width=8 height=6', 'rect');
        program.help && AddTitlebarIcon('help', 'Help', 'd="M5 8L8 2L2 2L5 8L8 2"');
        program.Fc && AddTitlebarIcon('code', 'Code', 'd="M5 2L8 8L2 8L5 2L8 8"');
        program.reload && AddTitlebarIcon(
            'reload', 'Reload', 'cx=5 cy=5 r=3', 'circle');
        AddTitlebarIcon('close', 'Close', 'd="M2 2L8 8M8 2L2 8"');

        // create content wrapper
        (this.iframeWrapper =
            this.shadowRoot.appendChild(document.createElement('div')))
            .style.background = '#000';

        // create code/help display
        (this.codeDisplay =
            this.shadowRoot.appendChild(document.createElement('textarea')))
            .id = 'codeDisplay';
        this.codeDisplay.setAttribute('readOnly', 1);
        
        // resize window size to fit inner width while preserving aspect
        const width = program.resize ? 
            Math.min(program.width*(this.program.saveInfo.scale||1), innerWidth-6) :
            program.width;
            
        // set width and height and titlebar width
        this.titlebar.style.width      = 
        this.iframeWrapper.style.width  = width;
        this.iframeWrapper.style.height = width * program.height / program.width;
        this.scale = width / program.width;

        // create iframe
        this.iframe = this.iframeWrapper.appendChild(document.createElement('iframe')); 
        this.iframe.id = 'frame';
        
        // announce game when first opened
        finishedStartup && OS13k.Speak(this.program.name);
        
        // track if programs are loading during startup
        loading += !finishedStartup;
        
        // wait for frame to load and set that it is not loading
        this.iframe.onload =e=> {

            // set up iframe          
            const iframeContent = this.iframeContent = e.target.contentWindow;

            // get the document and text, will fail if cross site
            const iframeDocument = iframeContent.document;
            
            // check for special extensions
            const hasExtension = program.isDweet || program.isShader;
            
            // get the document text
            const iframeText = hasExtension ?
                iframeDocument.body.innerText : iframeDocument.body.innerHTML;

            // set help/code display
            this.codeDisplay.value = program.help || iframeText;

            // pass zzfx to iframe
            iframeContent.zzfx = zzfx;

            // prevent iframes context menu
            iframeContent.oncontextmenu =()=> false;

            // check for extensions
            if (hasExtension) 
            {
                // create full size canvas
                iframeDocument.body.innerHTML = 
                    `<canvas id=c width=1920 height=1080 style=` +
                    'width:100%;background:#' +
                    (program.isDweet ? 'fff' : '000') +'>';
                
                // set body style
                iframeDocument.body.style = 
                    'background:#111;' +
                    'overflow:hidden;' +
                    'margin:0;' +
                    'display:flex;' +
                    'align-items:center';

                // create dweet
                program.isDweet && iframeContent.eval(
                    'u=t=>{' + iframeText + '};' +
                    'x=c.getContext`2d`;' +
                    'S=Math.sin;' +
                    'C=Math.cos;' +
                    'T=Math.tan;' +
                    'R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;' + 
                    'loop=t=>requestAnimationFrame(loop,' +
                    (program.awake? '' : 't<1e3|document.hasFocus()&&') +
                        'u((60*(frame++/60)-frame-1|0?frame-1:frame)/60));' +
                    'loop(frame=0)');

                // create shader
                program.isShader && iframeContent.eval(
                    'x=c.getContext`webgl2`;' +
                    'onmousemove=e=>e.buttons&&(X=e.x,Y=c.height-e.y);' +
                    'onmousedown=e=>(X=Z=e.x,Y=W=c.height-e.y);' +
                    'onmouseup=e=>Z=W=0;' +
                    's=parent.OS13k.CreateShader(c,`' + iframeText + '`);' + 
                    'loop=t=>requestAnimationFrame(loop,' +
                    (program.awake? '' : 't<1e3|document.hasFocus()&&') +
                        '(c.width=innerWidth,' + 
                        'c.height=innerHeight,' + 
                        'parent.OS13k.RenderShader(c,s,f/60,f++,X,Y,Z,W)));' + 
                    'loop(X=Y=Z=W=f=0)');
            }

            // add taskbar icon if it doesnt exist (from being reloaded)
            this.taskbarIcon ||
                (this.taskbarIcon = new OS13kTaskbarIcon(program, this));

            // make visible
            this.style.visibility = this.iframe.style.visibility = 'visible';
            
            // only set active if not grabbing
            grabWindow || this.SetActive();
    
            // update startup routine
            OS13kSystem.UpdateStartup(loading&&--loading);
        }
        
        // load the iframe, force refresh of src
        this.iframe.src = program.src + forceRefresh;
    }
    
    Open(target, x, y, clamp)
    {
        // set active
        this.SetActive(1, clamp);
        
        // set grab window if name is clicked on
        if (target == this.name)
        {
            // set this to be the grab window
            grabWindow = this;
            
            // use grabbing cursor
            background.style.cursor = taskbar.style.cursor = 'grabbing';
            
            // prevent windows from getting focus
            desktop.style.pointerEvents = 'none';

            // save grab offset
            const rect = this.getBoundingClientRect();
            grabOffsetX = x - rect.left;
            grabOffsetY = y - rect.top;
            
            // allow main document focus
            return;
        }
        
        // check for title bar buttons
        target.id == 'full'        && this.FullScreen();
        target.id == 'reload'      && this.Reload();
        target.id == 'close'       && this.Close();
        target.id == 'shrink'      && this.Resize(this.scale - .2);
        target.id == 'grow'        && this.Resize(this.scale + .2);
        (target.id == 'help' | target.id == 'code') && this.ShowCode();
        
        // allow main document focus if code display or grabbing
        return target == this.codeDisplay || grabWindow == this;
    }
    
    Resize(scale)
    {
        // change size of window while preserving aspect
        const wNew = OS13k.Clamp(this.program.width * scale, 300, 1920);
        const hNew = this.program.height * (this.scale = wNew / this.program.width);
        
        // get old width
        const w = parseFloat(this.iframeWrapper.style.width);
        
        // adjust window position for new width
        this.style.left = parseFloat(this.style.left) + w - wNew;
        
        // set new size
        this.titlebar.style.width = this.iframeWrapper.style.width = wNew;
        this.iframeWrapper.style.height = hNew;
    
        // update program info
        this.program.SaveInfo();
    }
    
    SetActive(active=1, clamp)
    {
        // close menus when window is set active
        OS13kSystem.CloseMenus();
        
        // set style, dim non active windows
        this.className = active? 'windowActive' : '';
        this.titlebar.className = 'titlebar ' 
            + (active && !loading? 'titlebarActive' : this.program.sticky ? 'titlebarSticky' : '');
        this.iframeWrapper.style.filter = active || this.program.awake ? 
            '' : 'saturate(.7)brightness(.7';

        // check if active
        if (!active) return;
        
        // save start program if finished startup and not sticky
        finishedStartup && !this.program.sticky && 
            OS13k.Save(startProgram = this.program);

        // set focus to iframe if not loading
        loading || this.iframeContent && this.iframeContent.focus();

        // clamp window to screen
        const rect = this.getBoundingClientRect();
        clamp && (
            this.style.left = OS13k.Clamp(rect.x, 0, innerWidth - rect.width,
            this.style.top = OS13k.Clamp(rect.y, taskbarHeight, 
                Math.max(taskbarHeight, innerHeight - rect.height))));

        if (windowActive != this)
        {
            // deactivate old window
            windowActive && windowActive.SetActive(0);
            
            // set this to be active window
            windowActive = this;

            // move z to top
            this.style.zIndex = ++topZ;

            // show menu buttons
            const SetButtonVisibility=(button, visible)=>
                button.style.display = visible ? '' : 'none';
            SetButtonVisibility(buttonFullScreen, this.program.full);
            SetButtonVisibility(buttonCode,       this.program.code);
            SetButtonVisibility(buttonHelp,       this.program.help);
            SetButtonVisibility(buttonReload,     this.program.reload);
            SetButtonVisibility(buttonResetSize,  this.program.resize);

            // set taskbar icon active if it exists
            // it will not have been created yet if frame is loading
            this.taskbarIcon && this.taskbarIcon.SetActive();
        }
        
        return false;
    }
    
    FullScreen()
    {
        // check if full screen allowed
        if (!this.program.full) return;
        
        // set full screen
        this.iframeWrapper.webkitRequestFullScreen &&
            this.iframeWrapper.webkitRequestFullScreen();
        this.iframeWrapper.mozRequestFullScreen &&
            this.iframeWrapper.mozRequestFullScreen();
            
        OS13k.Trophy('OS13k','Pro Gamer','üïπÔ∏è','Went Full Screen');
    }
    
    ShowCode()
    {
        // toggle showing code
        this.codeDisplay.style.display = 
            (this.showCode = !this.showCode) ? 'inline' : '';
        
        this.program.help || OS13k.Trophy('OS13k','Hacker','üë®‚Äçüíª','Viewed Code');
    }
    
    // reload program or reload iframe and set invisible
    Reload()
    {
        this.program.Reload() || 
            this.iframeContent.location.reload(this.iframe.style.visibility = '');
    }
    
    Close()
    {
        // remove start program if closed
        this.program.name == startProgramName 
            && OS13k.Save(startProgram = 0);
            
        // save info and set closed
        this.program.SaveInfo(0);
        
        // invalidate window after info is saved
        this.program.window = 0;
        
        // remove taskbar icon and self
        this.taskbarIcon.remove();
        this.remove();
    }
} // OS13kWindow
customElements.define('w-', OS13kWindow);

///////////////////////////////////////////////////////////////////////////////
// OS13kTaskbarIcon - icon on taskbar that can be used as shortcut

class OS13kTaskbarIcon extends HTMLElement
{
	constructor(program, windowOrMenu)
    {
		super();
        
        // create icon
        this.className = 'taskbarIcon';
        this.innerHTML = '<div style=pointer-events:none>' + program.icon;
        this.title = program.title || program.name;
        
        // only set menu if not the load icon
        this.menu = windowOrMenu && menu;
        
        // save window, only a menu if its the load icon
        this.windowOrMenu = windowOrMenu;
        
        // add to taskbar
        taskbarSpace.before(this);
    }
    
    Open()
    {
        // set active
        this.SetActive();
        
        // allow main document focus only if its the load icon
        this == loadIcon;
    }
    
    SetActive(active=1)
    {
        // set window active and clamp
        active && this.windowOrMenu.SetActive(1, 1);
    
        // load icon cant be the active taskbar item
        if (this == loadIcon) return;
        
        // set active style
        this.className = 'taskbarIcon ' + (active ? 'taskbarIconActive' : '');
        
        // check if active
        if (!active) return;
            
        // unselect old taskbar icon
        activeTaskbarIcon && activeTaskbarIcon != this &&
            activeTaskbarIcon.SetActive(0);

        // set this to be active taskbar icon
        activeTaskbarIcon = this;
    }
    
} // OS13kTaskbarIcon
customElements.define('i-', OS13kTaskbarIcon);

///////////////////////////////////////////////////////////////////////////////
// OS13kTrayIcon - icon on taskbar tray for OS shortcuts

class OS13kTrayIcon extends HTMLElement
{
	constructor()
    {
		super();
        
        // create tray icon and add it
        this.className = 'trayIcon';
        tray.appendChild(this);
    }
    
    SetProgram(program)
    {
        // set program, title, and icon
        this.program = program;
        this.title = program.title;
        this.innerHTML = program.icon;
    }
    
    Open() { this.program ? this.program.Toggle() : this.functionCall(); }
} // OS13kTrayIcon
customElements.define('t-', OS13kTrayIcon);

///////////////////////////////////////////////////////////////////////////////
// Mouse Input

{
onmousedown=e=>
{
    // set there has been user input
    hadInput = 1;
    
    // check if clicked on load icon while programs menu was visible
    if (e.target == loadIcon && e.target.windowOrMenu.style.visibility)
    {
        // close menus because they were open
        OS13kSystem.CloseMenus();
        
        // reactivate active window
        windowActive && windowActive.SetActive();
        
        // prevent main document from taking focus
        return false;
    }
    
    // close menus on mouse down
    OS13kSystem.CloseMenus();

    // reset program menu position
    programsMenu.style.left = 0;
    programsMenu.style.top = taskbarHeight;

    // prevent stuck grab (from tabbing to another window while grabbing)
    if (grabWindow) return onmouseup(e);
    
    // get orignal target
    const originalTarget = e.originalTarget || e.path[0];
    
    // check for non left click
    if (e.button)
    {
        // check for right click
        if (e.button & 2)
        {
            const target = e.target.window || e.target;

            // don't do anything if code or button clicked on
            if (originalTarget.id != 'codeDisplay' & e.target.localName != 'button')
            {
                // set target active, use load icon if no valid target
                (target.SetActive ? target : loadIcon).SetActive();

                // get which menu to open
                const targetMenu = e.target.menu ? menu : programsMenu;

                // show context menu
                targetMenu.style.left = e.x;
                targetMenu.style.top  = e.y;
                targetMenu.style.visibility = 'visible';
            }
        }
    
        // allow main document to take focus
        return;
    }

    // open on left click, reactivate window if no valid target
    return e.target.Open ? e.target.Open(originalTarget, e.x, e.y) :
        windowActive && windowActive.SetActive();
}

onmousemove=e=>
(
    grabWindow &&
    (
        // update grab position
        grabWindow.style.left = e.x - grabOffsetX,
        grabWindow.style.top = e.y - grabOffsetY,
        
        // save info
        grabWindow.program.SaveInfo()
    ),
    
    // handle mouse move
    e.target.Move && e.target.Move()
)

onmouseup=e=>
    // set grab window active, no clamp, and set cursor to default, unset grab
    grabWindow && (grabWindow.SetActive(1, 0),
        background.style.cursor = taskbar.style.cursor
            = desktop.style.pointerEvents = grabWindow = '');

// prevent default right click context menu
oncontextmenu=e=>false;

} // mouse input

///////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth 

const zzfx = // play a sound
(volume = 1, randomness = .05, frequency = 220, attack = 0, sustain = 0, release = .1, shape = 0, shapeCurve = 1, slide = 0, deltaSlide = 0, pitchJump = 0, pitchJumpTime = 0, repeatTime = 0, noise = 0, modulation = 0, bitCrush = 0, delay = 0, sustainVolume = 1, decay = 0, sampleRate = 44100, b = [])=>
{
    attack = 99 + attack * sampleRate;
    sustain *= sampleRate;
    release *= sampleRate;
    decay *= sampleRate;
    delay *= sampleRate;
    
    for(
        // init parameters and helper functions
        let PI2 = Math.PI*2,
        random =r=> 1 + r*2*Math.random() - r,
        sign =v=> v>0? 1 : -1,
        length = attack + decay + sustain + release + delay,
        startSlide = slide *= 500 * PI2 / sampleRate**2,
        startFrequency = frequency *= random(randomness) * PI2 / sampleRate,
        modPhase = sign(modulation) * PI2/4,
        t=0, tm=0, i=0, j=1, r=0, c=0, s=0;
    
        // loop and generate waveform
        i < length; b[i++] = s)
    {
        if (++c>bitCrush*100)                            // bit crush
        {
            c = 0;                                       // reset bit crush
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation * PI2 / sampleRate - modPhase); // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
                Math.sin((s%PI2)**3) :                   // 4 noise
                Math.max(Math.min(Math.tan(s), 1), -1):  // 3 tan
                1-(2*s/PI2%2+2)%2:                       // 2 saw
                1-4*Math.abs(Math.round(s/PI2)-s/PI2):   // 1 triangle
                Math.sin(s);                             // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * (                              // envelope
                i < attack ? i/attack :                  // attack
                i < attack + decay ?                     // decay
                1-((i-attack)/decay)*(1-sustainVolume) : // decay falloff
                i < attack + decay + sustain ?           // sustain
                sustainVolume :                          // sustain volume
                i < length - delay ?                     // release
                (length - i - delay)/release *           // release falloff
                sustainVolume :                          // release volume
                0);                                      // post release

            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i - delay|0]/2) : s;                   // sample delay
        }

        t += random(noise);                          // noise
        tm += random(noise);                         // modulation noise
        frequency += slide += deltaSlide             // frequency slide
            * 500 * PI2 / sampleRate**3;             // apply sample rate

        if (j && ++j > pitchJumpTime * sampleRate)   // pitch jump
        {
            frequency += pitchJump                   // apply pitch jump
                * PI2 / sampleRate;                  // apply sample rate
            startFrequency += pitchJump              // also apply to start
                * PI2 / sampleRate;                  // apply sample rate
            j = 0;                                   // reset pitch jump time
        }

        if (repeatTime && ++r > repeatTime* sampleRate) // repeat
        {
            frequency = startFrequency;               // reset frequency
            slide = startSlide;                       // reset slide
            r = 1;                                    // reset repeat time
            j = j || 1;                               // reset pitch jump time
        }
    }

    return OS13k.PlaySamples(b);
}

///////////////////////////////////////////////////////////////////////////////
// Start OS13k!

OS13kSystem.Start();

///////////////////////////////////////////////////////////////////////////////
// Mobile Support OPTIONAL

// save if user was touching
let wasTouching;
    
if (typeof ontouchstart != 'undefined')
{
    // remove hovers, they get stuck on mobile
    const RemoveHovers=e=>
    {
        // remove all hover effects
        for (const sheet of e.styleSheets)
        for (let i = sheet.rules.length; i--; )
            sheet.rules[i].selectorText &&
            sheet.rules[i].selectorText.match('hover') &&
            sheet.deleteRule(i);
    }
    RemoveHovers(document);
                
    // handle touch event
    const ProcessTouch=e=>
    {
        // check if touching
        const touching = e.touches.length;
        if (touching)
        {
            // set event pos
            e.x = e.touches[0].clientX;
            e.y = e.touches[0].clientY;

            // pass event to mousemove
            onmousemove(e);
            
            // give focus to main window
            window.focus();
        }

        // pass event to mouse down, prevent closing folders when clicked
        touching & !wasTouching & !e.target.folder && onmousedown(e);

        // pass event to mouse up
        !touching & wasTouching && onmouseup(e);

        // set was touching
        wasTouching = touching;
        
        // remove hovers from active window
        windowActive && RemoveHovers(windowActive.shadowRoot);
        
        // prevent default if possible
        return !e.cancelable;
    }
    
    // set touch events
    ontouchstart = ontouchmove = ontouchend = ontouchcancel = ProcessTouch;
};

</script>