<!--

OS13k is a tiny pseudo operating system designed for a JS13k community project. It has native support for Shadertoys, Dweets, ZzFX, trophies, and much more.

Your mission, if you choose to accept it, is to help us fill it up with as much cool stuff as we can fit.

Please keep this project confidential!

✌️😄 ❤️ OS13k Team

-->

<title>OS13k - A tiny operating system for JS13k</title>
<link rel=icon type=image/x-icon href='favicon.png?1'/>
<meta charset=utf-8>
<meta name=viewport content='width=device-width,initial-scale=1,user-scalable=0'>
<style>
body
{
    touch-action:none;
    margin:0;
    overflow:hidden;
    font-family:arial;
    user-select:none;
    white-space:nowrap;
}
#taskbar
{
    position:absolute;
    border:2px solid;
    z-index:10000;
    width:100%;
    background:linear-gradient(#888,#333);
    left:-2;
    box-shadow:0px 1px 9px;
}
.taskbarIcon
{
    font-size:22;
    width:50;
    height:40;
    text-shadow:1px 1px 2px #000;
}
#tray
{
    font-size:22;
    border:1px solid;
    margin:2;
    padding:2;
    background:linear-gradient(#000,#333);
    color:#fff;
    border-radius:7px;
    padding-left:9;
    padding-right:9;
}
.trayIcon       { padding-left:5; padding-right:5; }
.trayIcon:hover { background:#fff3;}
#menu
{
    visibility:hidden;
    display:flex;
    flex-direction:column;
    background:#000;
}
.folder, #menu
{
    position:absolute;
    border:2px solid;
    z-index:20000;
    box-shadow:5px 5px 9px;
}
.trophyPopup
{
    position:relative;
    border:2px solid;
    z-index:10001;
    box-shadow:5px 5px 9px;
    width:200;
    padding:8;
    font-size:26;
    text-align:center;
    background:linear-gradient(#eee,#888);
    white-space:normal;
    margin:9;
    border-radius:9px;
}
.program
{
    font-size:18;
    height:18;
    padding:4;
}
.programActive,
.taskbarIconActive         { background:linear-gradient(#ff8,#fff); }
.taskbarIcon:hover         { background:linear-gradient(#fff,#44f); }
.taskbarIconActive:hover   { background:linear-gradient(#ff8,#44f); }
.folder                    { background:linear-gradient(#fff,#777); }
#title
{
    position:absolute;
    width:100%;
    height:100%;
    color:#0002;
    font-family:impact;
    font-weight:900;
    font-size:20vw;
    background:linear-gradient(#223,#322);
}
.flexCenter, .taskbarIcon, #taskbar, .program, #tray, #title
{
    display:flex;
    align-items:center;
    justify-content:center;
}
</style>
<template id=template>
<style>
:host
{
    box-shadow:5px 5px 9px;
    border:2px solid #222;
    background:#000;
    display:flex;
    flex-direction:column;
    overflow:hidden;
    position:absolute;
}
.titlebar
{
    height:44;
    font-size:26;
    background:linear-gradient(#eee,#888);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    white-space:nowrap;
}
.titlebarActive
{
    background:linear-gradient(#eee,#88f);
}
#frame
{
    width:100%;
    height:100%;
    border:none;
    background:#000;
    overflow:hidden;
    background:#fff;
}
#name
{
    width:100%;
    cursor:grab;
    overflow:hidden;
}
.icon
{
    text-shadow:1px 1px 2px #000;
    margin-left:9;
    margin-right:9;
}
.titleBarElement, .icon
{
    pointer-events:none;
    display:inline;
}
#codeDisplay
{
    height:99;
    resize:none;
    background:#000;
    color:#fff;
    display:none;
    border:1px solid #fff;
    outline:none;
}
#reload,
#full,
#code         { width:40; }
#close        { width:28; }
#help:hover   { background:#0ff; }
#code:hover   { background:#0f0; }
#full:hover   { background:#fff; }
#reload:hover { background:#ff0; }
#close:hover  { background:#f00; }
div svg       { width:100%; pointer-events:none; }
</style>
<svg width=0 height=0>
<symbol id=icon-code viewBox='0 0 10 10'>
    <path stroke=#000 stroke-width=.7 fill=none d='M5 2L8 8L2 8L5 2L8 8'/>
<symbol id=icon-full viewBox='0 0 10 10'>
    <rect stroke=#000 stroke-width=.7 fill=none x=1 y=2 width=8 height=6 />
<symbol id=icon-reload viewBox='0 0 10 10'>
    <circle stroke=#000 stroke-width=.7 fill=none cx=5 cy=5 r=3 />
<symbol id=icon-close viewBox='0 0 10 10'>
    <path stroke=#000 d='M1 1L9 9M9 1L1 9'/>
</template>
<div id=desktop>
<div id=taskbar>
<div id=traySpace style=flex:1></div>
<div id=tray>
    <div id=trayTrophy class=trayIcon title='Trophy Case'></div>
    <div id=trayVolume class=trayIcon title='Toggle Mute'>🔊</div>
    <div id=trayTime class=trayIcon></div>
</div>
</div>
<div id=trophyPopups style=float:right;position:relative></div>
<div id=programsFolder style=position:absolute></div>
<div id=title>OS13k
<div id=menu>
<button id=buttonFullScreen onclick=activeWindow.FullScreen()>Fullscreen
<button id=buttonShowCode onclick=activeWindow.ShowCode()>Show Code
<button id=buttonReload onclick=activeWindow.Reload()>Reload
<button id=buttonClose onclick=activeWindow.Close()>Close
<script src=programs.js?53></script>
<script>

/////////////////////////////////////////////////////////////////////////////
// OS13k Debug Stuff (remove from minified)

// version check
if (localStorage.OS13kVersion != 9)
    localStorage.clear(),localStorage.OS13kVersion = 9;
    
// load default programs if none found
if (typeof programs == 'undefined')
    programs = [{src:'system/test.html'},{src:'system/trophies.html'},{src:'system/clock.dweet.js',width:200,height:200,sleep:0}];

/////////////////////////////////////////////////////////////////////////////
// Use Strict and Closure Config

'use strict';

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs OS13k, OS13kFolder, OS13kProgram, OS13kWindow, OS13kTaskbarIcon
// @js_externs zzfx, zzfxV, icon.folder
// @js_externs _OS13k.Trophy, _OS13k.GetTrophies, _OS13k.KeyDirection, _OS13k.Speak
// @js_externs _OS13k.CreateShader, _OS13k.RenderShader, _OS13k.CreateCanvas
// @js_externs _OS13k.PlaySamples, _OS13k.PlaySeed, _OS13k.GetNote
// @js_externs _OS13k.Random, _OS13k.randomSeed 
// @js_externs _OS13k.Clamp, _OS13k.Percent, _OS13k.Lerp, _OS13k.StripHTML
// @js_externs iframeContent.OS13k, iframeContent.OS13kStart, iframeContent.zzfx
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==

/////////////////////////////////////////////////////////////////////////////
// OS13k System

class _OS13k
{
    Trophy(game='OS13k', name='', icon='', message='', saveTrophies=1)
    {
        // build key
        const key = game + ',' + name + ',' + icon;
        const storageKey = 'OS13kTrophy,' + key;
        
        // strip html
        icon = this.StripHTML(icon) || '🏆';
        name = this.StripHTML(name);
        game = this.StripHTML(game);
        message = this.StripHTML(message);
        
        // find in trophy list
        const trophyIndex = trophies.findIndex(e=>e[4]==key)
        
        // skip if no game or same message
        if (!game || trophyIndex >=0 && trophies[trophyIndex][3] == message)
            return;
        
        // add or update trophy list
        const trophyData = [game, name, icon, message, key];
        trophyIndex < 0 ? 
            trophies.push( trophyData ) :
            trophies[trophyIndex] = trophyData;

        // save local storage
        if (saveTrophies)
        {
            localStorage[storageKey] = message;
            localStorage.OS13kTrophies = JSON.stringify(trophies);
        }
        
        // use game as name if there is no name
        name || (name = game, game = '');

        // build popup element
        const trophyElement = document.createElement('div');
        trophyElement.className = 'trophyPopup';
        trophyElement.innerHTML = 
            '<div class=flexCenter style=overflow:hidden;flex-direction:column>' +
                '<div style="white-space:nowrap;font-size:40;padding:9;text-shadow:2px 2px 4px #000">' + 
                    icon +                                  // icon
                '</div>' +
                '<div style=width:100%;overflow:hidden>' +  // info
                    '<b>' + name + '</b><br>' +             // name
                    '<i>' + game + '</i>' +                 // game
                '</div>' +
            '<div style=font-size:20;padding:8>' + message; // message
            
        // add trophy to bottom of screen
        trophyElement.style.top = innerHeight;
        trophyPopups.appendChild(trophyElement);
        
        // refresh trophy window if it is being displayed
        trophyProgram.window && trophyProgram.window.iframeContent &&
            trophyProgram.window.iframeContent.OS13kStart();
    }
    
    GetTrophies() { return trophies; } 
    
    KeyDirection(keyCode)
    {
        // get direction from wasd or arrow keys
        let x = 0, y = 0;
        (keyCode == 87 || keyCode == 38) && ++y; // up
        (keyCode == 83 || keyCode == 40) && --y; // down
        (keyCode == 68 || keyCode == 39) && ++x; // right
        (keyCode == 65 || keyCode == 37) && --x; // left
        return {x, y}
    }
    
    PlaySeed(seed, lengthScale=1, volume=1, randomness=.05)
    {
        // set random seed
        const R=()=>this.Random(), C=()=>R()<.5, S=()=>C()?1:-1;
        this.randomSeed = seed;
        
        // randomize sound length
        lengthScale /= 2;
        const attack  = R()**3*lengthScale;
        const sustain = R()**3*lengthScale;
        const release = R()**3*lengthScale;
        const length  = attack + sustain + release;
        
        // create random sound
        return zzfx(...
        [
           volume,               // volume
           randomness,           // randomness
           R()**2*2e3,           // frequency
           attack,               // attack
           sustain,              // sustain
           release,              // release
           R()*5|0,              // shape
           R()**2*3,             // shapeCurve
           C() * R()**3*99*S(),  // slide
           C() * R()**3*99*S(),  // deltaSlide
           C() * R()**2*1e3*S(), // pitchJump
           R()**2 * length,      // pitchJumpTime
           C() * R() * length,   // repeatTime
           C() * R()**4,         // noise
           C() * R()**3*9*S(),   // modulation
           C() * R()**4,         // bitCrush
           C() * R()**3/2,       // delay
        ]);
    }
    
    PlaySamples(samples, sampleRate=44100)
    {
        // play raw audio sample data
        const buffer = audioContext.createBuffer(1, samples.length, sampleRate);
        const source = audioContext.createBufferSource();
        buffer.getChannelData(0).set(samples);
        source.buffer = buffer;
        source.connect(gain);
        source.start();
        return source;
    }
    
    GetNote(rootNoteFrequency=440, semitoneOffset=0)
    {
        // get frequency of a musical note on a diatonic scale
        return rootNoteFrequency * 2**(semitoneOffset/12);
    }

    Speak(text) { speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }
    
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');

        // create a simple pass through vertex shader
        const vertexShader = x.createShader(x.VERTEX_SHADER);
        x.shaderSource(vertexShader,
            '#version 300 es\n' +
            'in vec4 p;' +
            'void main()' +
            '{gl_Position=p;}');
        x.compileShader(vertexShader);
        
        // create vertex buffer that is a big triangle
        const vertexBuffer = x.ARRAY_BUFFER;
        x.bindBuffer(vertexBuffer,x.createBuffer());
        x.bufferData(vertexBuffer,new Int8Array([-3,1,1,-3,1,1]),x.STATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0,2,x.BYTE,0,0,0); // 2D vertex
        
        // check vertex shader for errors
        //if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
        //    throw x.getShaderInfoLog(vertexShader);
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(x.FRAGMENT_SHADER)
        const shaderProgramCode = 
            '#version 300 es\n' +
            'precision mediump float;' +
            'uniform float iTime;' +
            'uniform vec4 iMouse;' +
            'uniform vec3 iResolution;' +
            'uniform sampler2D iChannel0;' +
            'out vec4 outColor;\n' +
            code +
            '\nvoid main()' +
            '{mainImage(outColor,gl_FragCoord.xy);' +
            'outColor.a=1.;}';
        x.shaderSource(pixelShader, shaderProgramCode)
        x.compileShader(pixelShader);

        // check pixel shader for errors
        if (!x.getShaderParameter(pixelShader, x.COMPILE_STATUS))
            throw x.getShaderInfoLog(pixelShader);

        // create texture
        x.bindTexture(x.TEXTURE_2D, x.createTexture());
        x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.LINEAR);
        x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL, 1); 
        
        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    RenderShader(canvas, shaderProgram, time=0)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // set uniforms
        const uniformLocation=name=>x.getUniformLocation(shaderProgram, name);
        x.uniform3f(uniformLocation('iResolution'), canvas.width, canvas.height, 1);
        x.uniform1f(uniformLocation('iTime'), time);
        x.uniform1i(uniformLocation('iChannel0'), 0);
        
        // render shader
        x.viewport(0, 0, canvas.width, canvas.height);
        x.drawArrays(x.TRIANGLE_FAN, 0, 3);
        
        // set texture to the newly renderd canvas
        x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, x.RGBA, x.UNSIGNED_BYTE, canvas);
    }
    
    // helper functions
    StripHTML(string)      { return (string||'').replace(/(<([^>]+)>)/ig,''); }
    Clamp(a, min=0, max=1) { return Math.min(Math.max(a, min),max); }
    Percent(v, a, b)       { return b-a? this.Clamp((v-a)/(b-a), 0, 1) : 0; }
    Lerp(p, a, b)          { return a + this.Clamp(p, 0, 1) * (b-a); }
    Random(max=1, min=0)
    {
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= (this.randomSeed||-1) << 13;
        this.randomSeed ^= this.randomSeed >> 17;
        this.randomSeed ^= this.randomSeed << 5;
        return this.Percent(Math.abs(this.randomSeed) % 1e9 / 1e9, min, max);
    }
}; // _OS13k

/////////////////////////////////////////////////////////////////////////////
// OS13k Desktop

const taskbarHeight = 42, programHeight = 26, titlebarHeight = 46,
      startWindowOpenX = 9, startWindowOpenY = 51, 
      trophyPopupTime = 3, defaultVolume = .3;
      
let grabObject, grabOffsetX, grabOffsetY,
    activeWindow, activeProgram, activeTaskbarIcon,
    lastActiveElement, loadIcon, firstProgram, topZ = 0,
    windowOpenX = startWindowOpenX, windowOpenY = startWindowOpenY,
    trophies = [], trophyProgram, clockProgram;

const Init=()=>
{
    // set taskbar functions
    trayTrophy.onmousedown = trayTrophy.ontouchstart = ToggleTrophies;
    trayVolume.onmousedown = trayVolume.ontouchstart = ToggleMute;
    trayTime.onmousedown = trayTime.ontouchstart = ToggleClock;

    // create the folder taskbar icon and add folders/programs
    const taskbarIcon = 
        loadIcon = new OS13kTaskbarIcon( {icon:'💾', name:'Apps'}, 
            new OS13kFolder(programs, 0, 0));

    // open first program in list
    firstProgram && firstProgram.MouseClick();
    
    // parse trophy list
    trophies = localStorage.OS13kTrophies ? JSON.parse(localStorage.OS13kTrophies) : [];

    // search local storage for trophies
    for (let i = localStorage.length; i--;)
    {
        // check if it is a trophy
        const key = localStorage.key(i);
        const keyParts = key.split(',');
        if (keyParts.shift() == 'OS13kTrophy')
            OS13k.Trophy(...keyParts, localStorage[key], 0);
    }
    
    // save trophies
    localStorage.OS13kTrophies = JSON.stringify(trophies);
    OS13k.Trophy(undefined,'Welcome!','👋');
}

const Update=()=>
{
    requestAnimationFrame(Update);

    // listen for iframe becomming new active element
    const activeElement = document.activeElement;
    if (lastActiveElement != activeElement)
    {
        // set focus to new active element
        activeElement.SetActive && activeElement.SetActive();
        lastActiveElement = activeElement;
    }
    
    // update trophy popups if not fullscreen
    if (!document.fullscreenElement)
    {
        let offsetHeight = 0, waitToFade = 0;
        
        // use copy of trophies to prevent skipping if removed
        for(const popup of [...trophyPopups.children])
        {
            let y = parseInt(popup.style.top) + offsetHeight - 9;
            if (y < taskbarHeight)
            {
                if (!waitToFade && !(popup.style.opacity = (popup.style.opacity || trophyPopupTime) - .01))
                {
                    // remove when invisible and adjust for height
                    const rect = popup.getBoundingClientRect();
                    offsetHeight += rect.height;
                    trophyPopups.removeChild(popup);
                }
                waitToFade = y = taskbarHeight;
            }

            popup.style.top = y;
        }
    }
    
    // set trophy count
    trayTrophy.innerHTML = trophies.length + ' 🏆';
    
    // set time
    trayTime.title = new Date();
    const time = trayTime.title.slice(16,24).split(':')
    trayTime.innerHTML = (time[0]%12?time[0]%12:12) + ':' + time[1];
}

const CloseFolders=()=>
{
    // hide all drop down folders
    for (const c of programsFolder.children)
        c.localName == 'os13k-folder' && (c.style.visibility = 'hidden');

    // hide menu
    menu.style.visibility = '';
}

const CloseWindows=()=>
{
    // use copy of children to prevent skipping
    for (const c of [...desktop.children])
        c.Close && c.Close()

    // reset window open position
    windowOpenX = startWindowOpenX;
    windowOpenY = startWindowOpenY;
    
    OS13k.Trophy(undefined,'Coffee Is For Closers','☕','Closed All');
}

const FocusTopWindow=()=>
{
    // find the top window and focus on it
    let topWindow;
    for (const c of desktop.children)
    {
        c.localName == 'os13k-window' &&
        (!topWindow || topWindow.style.zIndex < c.style.zIndex) &&
            (topWindow = c);
    }
    topWindow && topWindow.Focus();
}

const ToggleMute=()=>
{
    gain.gain.value = gain.gain.value ? 0 : defaultVolume;
    trayVolume.innerHTML = (gain.gain.value ? '🔊' : '🔇');
            
    OS13k.Trophy(undefined,'Shut Up','🔇','Muted');
}

const ToggleTrophies=()=>
{
    if (trophyProgram.window)
        trophyProgram.window.Close()
    else
        trophyProgram.MouseClick(
            windowOpenX = startWindowOpenX,
            windowOpenY = startWindowOpenY);
}

const ToggleClock=()=>
{
    if (clockProgram.window)
        clockProgram.window.Close()
    else
        clockProgram.MouseClick(
            windowOpenX = startWindowOpenX,
            windowOpenY = startWindowOpenY);
}

/////////////////////////////////////////////////////////////////////////////
// OS13kTaskbarIcon

class OS13kTaskbarIcon extends HTMLElement
{
	constructor(program, window = 0)
    {
		super();
        
        // create icon
        this.className = 'taskbarIcon';
        this.innerHTML = '<div style=pointer-events:none>' + program.icon;
        this.window = window;
        this.title = program.name +
            (program.isDweet ? ' - Dweet' : program.isShader ? ' - Shader' : '') +
            (program.author ? '\nBy ' + program.author : '');
        
        // add to taskbar
        traySpace.before(this);
    }
    
    MouseClick()
    {  
        // focus on window or drop down folder
        this.window.Focus(1);
    }
    
    SetActive(active=1)
    {
        // unselect old icon and set style
        activeTaskbarIcon && activeTaskbarIcon.SetActive(activeTaskbarIcon = 0);
        activeTaskbarIcon = this;
        this.className = 'taskbarIcon' + (active ? ' taskbarIconActive' : '');
    }
} // OS13kTaskbarIcon

customElements.define('os13k-taskbar-icon', OS13kTaskbarIcon);

/////////////////////////////////////////////////////////////////////////////
// OS13kFolder

class OS13kFolder extends HTMLElement
{
	constructor(infos, x, y, parentFolder)
    {
		super();
        
        // add to desktop
        this.className = 'folder';
        this.style.left = x;
        this.style.top = y;
        this.parentFolder = parentFolder;
        programsFolder.appendChild(this);
        
        // add programs to folder
        for (const info of infos)
            this.appendChild(info.program = new OS13kProgram(info));
        
        // get width offset and add new folders recursively
        const rect = this.getBoundingClientRect();
        for (const info of infos)
        {
            // create the folder and hook up to programs
            info.folder && (info.program.folder = new OS13kFolder(info.folder, rect.right - 2, y, this));
            y += programHeight;
        }
    }

    Focus(fromTaskbar)
    {
        // check if it is visible
        const wasVisible = !this.style.visibility;
            
        CloseFolders();
        if (!fromTaskbar || !wasVisible)
        { 
            // make visible
            this.parentFolder && this.parentFolder.Focus();
            this.style.visibility = '';
        }
        else
            activeWindow && activeWindow.Focus();
        
        if (fromTaskbar && this.parentNode == programsFolder)
        {
            programsFolder.style.left = 0;
            programsFolder.style.top = taskbarHeight;
        }
    }
} // OS13kFolder

customElements.define('os13k-folder', OS13kFolder);

/////////////////////////////////////////////////////////////////////////////
// OS13kProgram

class OS13kProgram extends HTMLElement
{
	constructor({'x':x, 'y':y, 'name':name, 'icon':icon, 'src':src, 'width':width=720, 'height':height=405, 'author':author, 'folder':folder, 'full':full=1, 'reload':reload, 'code':code, 'sleep':sleep=1})
    {
		super();
        
        // set icon defaults
        src = src || '';
        name = name || src.split('.')[0];
        icon = icon || '💠';     
        
        // check for special extensions
        const extension = src? src.split('.')[1] : '';
        this.isDweet = extension == 'dweet';
        this.isShader = extension == 'shader';
        this.hasExtension = this.isDweet || this.isShader
        firstProgram || src && (firstProgram = this);

        // set icon data
        this.className = 'program';
        this.name = name;
        this.icon = icon;
        this.src = src;
        this.width = width;
        this.height = height;
        this.author = author;
        this.sleep = sleep;
        this.full = full;
        this.reload = reload || (this.hasExtension && reload === undefined);
        this.code = code || (this.hasExtension && code === undefined);
            
        // icon
        const iconDisplay = document.createElement('div');
        iconDisplay.style = 'pointer-events:none;width:45;text-shadow:1px 1px 2px #000;text-align:center';
        iconDisplay.innerHTML = icon;
        this.appendChild(iconDisplay);
        
        // name
        const nameDisplay = document.createElement('div');
        nameDisplay.style = 'pointer-events:none;flex:1'
        nameDisplay.innerHTML = name;
        this.appendChild(nameDisplay);
        
        // folder arrow
        if (folder)
        {
            const folderDisplay = document.createElement('div');
            folderDisplay.style = 'pointer-events:none'
            folderDisplay.innerHTML = '▶';
            this.appendChild(folderDisplay);
        }
        
        // save trophy program
        src.substr(0,15) == 'system/trophies' && (trophyProgram = this);
        
        // save clock program
        src.substr(0,12) == 'system/clock' && (clockProgram = this);
    }
    
    MouseMove()
    {
        // set active
        activeProgram = this;
        this.className = 'program programActive';
        (this.folder? this.folder : this.offsetParent).Focus();
    }
    
    MouseClick() 
    {
        this == trophyProgram && OS13k.Trophy(undefined,'Hoarder','','Viewed Trophys');
        this == clockProgram && OS13k.Trophy(undefined,'Clock Watcher','🕰️','Checked Time');
          
        if (this.src)
        {
            // open the window
            this.window || (this.window = new OS13kWindow(this));

            // set focus to window
            this.window.Focus(1);
        }
        else if (!this.folder)
        {
            // close all
            CloseFolders();
            CloseWindows();
        }
    }
} // OS13kProgram

customElements.define('os13k-program', OS13kProgram);

/////////////////////////////////////////////////////////////////////////////
// OS13kWindow

class OS13kWindow extends HTMLElement
{
	constructor(program)
    {
		super();
        
        // add to desktop
        desktop.appendChild(this);
        
        // create taskbar program
        this.taskbarIcon = new OS13kTaskbarIcon(program, this);
        this.program = program;
        
        // set window position
        this.style.left = windowOpenX;
        this.style.top = windowOpenY;
        (windowOpenY += titlebarHeight) > 200 && (windowOpenY = startWindowOpenY);
        (windowOpenX += titlebarHeight) > 400 && (windowOpenX = startWindowOpenX);
        
        // create shadow root
		this.shadow = this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = template.innerHTML;
        
        // create title bar
        this.titlebar = document.createElement('div');
        this.titlebar.id = 'titlebar';
        this.shadowRoot.appendChild(this.titlebar);
        
        // create title bar name
        this.titlebarName = document.createElement('div');
        this.titlebarName.id = 'name';
        this.titlebar.appendChild(this.titlebarName);
        
        // icon
        const iconDisplay = document.createElement('div');
        iconDisplay.className = 'icon';
        iconDisplay.innerHTML = program.icon;
        this.titlebarName.appendChild(iconDisplay);
        
        // name
        const nameDisplay = document.createElement('div');
        nameDisplay.className = 'titleBarElement';
        nameDisplay.innerHTML = program.name + 
            (program.author? ' - ' + program.author: '');
        this.titlebarName.appendChild(nameDisplay);
        
        // create title bar icons
        const AddtitlebarIcon=(id, title)=>
        {
            const icon = document.createElement('div');
            icon.innerHTML = `<svg><use href=#icon-${icon.id = id}>`;
            icon.title = title;
            this.titlebar.appendChild(icon);
        }
        program.full && AddtitlebarIcon('full', 'Full Screen');
        program.code && AddtitlebarIcon('code', 'Show Code');
        program.reload && AddtitlebarIcon('reload', 'Reload');
        AddtitlebarIcon('close', 'Close');
        
        // create thin black line below title bar
        const titlebarGap = document.createElement('div');
        titlebarGap.style='height:2;background:#222';
        this.shadowRoot.appendChild(titlebarGap);

        // create content wrapper
        const frameWrapper = this.frameWrapper = document.createElement('div');
        frameWrapper.style.background = '#000'
        this.shadowRoot.appendChild(frameWrapper);
        
        // limit window size to inner size
        this.style.width = Math.min(program.width, innerWidth-4);
        frameWrapper.style.width  = Math.min(program.width,  innerWidth-4);
        frameWrapper.style.height = Math.min(program.height, innerHeight);

        // create iframe
        const iframe = this.iframe = document.createElement('iframe'); 
        iframe.id = 'frame';
        iframe.style.visibility = 'hidden';
        iframe.src = program.src;
        frameWrapper.appendChild(iframe);
                
        // load frame
        iframe.onload=e=>
        {
            // set up iframe          
            const iframeContent = this.iframeContent = e.target.contentWindow;
            let iframeDocument, iframeText;
            
            try
            {
                // get the document and text, will fail if cross site
                iframeDocument = iframeContent.document;
                iframeText = program.hasExtension ?
                    iframeDocument.body.innerText : iframeDocument.body.innerHTML;

                // create code display
                this.codeDisplay = document.createElement('textarea');
                this.codeDisplay.id = 'codeDisplay'; 
                this.codeDisplay.setAttribute('readOnly', 1);
                this.codeDisplay.value = iframeText;
                this.shadowRoot.appendChild(this.codeDisplay);
            }
            catch (e) {}
            
            if (iframeDocument)
            {
                // pass OS13k to iframe
                iframeContent.OS13k = OS13k;
                iframeContent.zzfx = zzfx;
                iframeContent.OS13kStart && iframeContent.OS13kStart();
            }

            // check for extensions
            if (iframeDocument && program.hasExtension)
            {
                // create full size canvas
                iframeDocument.body.innerHTML = 
                    `<canvas id=c width=1920 height=1080 style=` +
                    'width:100%;background:#' +
                    (program.isDweet ? 'fff' : '000') +'>';
                iframeDocument.body.style = 
                    'background:#111;' +
                    'overflow:hidden;' +
                    'margin:0;' +
                    'display:flex;' +
                    'align-items:center';

                // create dweet
                program.isDweet && iframeContent.eval(
                    'u=t=>{' + iframeText + '};' +
                    'x=c.getContext`2d`;' +
                    'S=Math.sin;' +
                    'C=Math.cos;' +
                    'T=Math.tan;' +
                    'R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;' +
                    'loop=t=>requestAnimationFrame(loop,' +
                        `${program.sleep?'document.hasFocus()':1}&&` +
                        'u((60*(frame++/60)-frame-1|0?frame-1:frame)/60));' +
                    'loop(frame=0)');

                // create shader
                program.isShader && iframeContent.eval(
                    'g=c.getContext`webgl2`;' +
                    'x=y=z=w=0;' +
                    'onmousemove=e=>e.buttons&&(x=e.x,y=c.height-e.y);' +
                    'onmousedown=e=>(x=z=e.x,y=w=c.height-e.y);' +
                    'onmouseup=e=>z=w=0;' +
                    'loop=t=>requestAnimationFrame(loop,' +
                        `${program.sleep?'document.hasFocus()':1}&&(` +
                        'c.width=innerWidth,' + 
                        'c.height=innerHeight,' + 
                        'g.uniform4f(g.getUniformLocation(s,"iMouse"),x,y,z,w),' +
                        'OS13k.RenderShader(c,s,t/1e3)));' + 
                    'loop(s=OS13k.CreateShader(c,`' + iframeText + '`))');
            }

            // show iframe and set focus
            iframe.style.visibility = '';
            this.Focus();
        }
    }
    
    MouseDown(e, originalTarget)
    {
        // set grab object if name is clicked on
        originalTarget.id == 'name' && (grabObject = this);
        
        // set focus
        this.Focus();
    }
    
    MouseClick(target)
    {
        // check for title bar buttons
        target.id == 'full'        && this.FullScreen();
        target.id == 'code'        && this.ShowCode();
        target.id == 'reload'      && this.Reload();
        target.id == 'close'       && this.Close();
        target.id != 'codeDisplay' && this.Focus();
    }
    
    Focus(clampToWindow)
    {
        // set focus
        CloseFolders();
        this.iframeContent && this.iframeContent.focus();
        this.SetActive();
        
        if (clampToWindow)
        {
            // clamp window to screen
            const rect = this.getBoundingClientRect();
            this.style.left = OS13k.Clamp(rect.x, 0, innerWidth - rect.width);
            this.style.top = OS13k.Clamp(rect.y, taskbarHeight, 
                Math.max(taskbarHeight, innerHeight - rect.height));
        }
    }
    
    SetActive(active=1)
    {
        if (active)
        {
            if (activeWindow != this)
            {
                // deactivate old window
                activeWindow && activeWindow.SetActive(0);

                // move z to top
                this.style.zIndex = ++topZ;

                // show menu buttons
                buttonShowCode.style.display = this.program.code? '' : 'none';
                buttonReload.style.display   = this.program.reload? '' : 'none';
            }
        
            // close folders and menu
            CloseFolders();
        }
            
        // set active
        activeWindow = active && this;
        this.style.filter = active || !this.program.sleep? '' : 'saturate(.7)brightness(.7';
        this.titlebar.className = 'titlebar' + (active? ' titlebarActive' : '')
        this.taskbarIcon.SetActive();
    }
    
    FullScreen()
    {
        // set fullscreen
        this.Focus();
        const fullScreenElement = this.frameWrapper;
        if (fullScreenElement.webkitRequestFullScreen)
            fullScreenElement.webkitRequestFullScreen();
        else if (fullScreenElement.mozRequestFullScreen)
            fullScreenElement.mozRequestFullScreen();
            
        OS13k.Trophy(undefined,'Pro Gamer','🕹️','Went Fullscreen');
    }
    
    ShowCode()
    {
        // toggle showing code
        this.Focus();
        this.codeDisplay.style.display = 
            (this.showCode = !this.showCode) ? 'block' : '';
            
        OS13k.Trophy(undefined,'Hacker','👨‍💻','Viewed Code');
    }
    
    Reload()
    {
        // hide iframe and reload it
        this.iframe.style.visibility = 'hidden';
        this.iframeContent.location.reload();
    }
    
    Close()
    {
        // destroy window
        this.program.window = 0;
        this.taskbarIcon.remove();
        this.remove();
        
        // try to focus on top window
        FocusTopWindow();
    }
} // OS13kWindow

customElements.define('os13k-window', OS13kWindow);

/////////////////////////////////////////////////////////////////////////////
// Mouse Input

onmousedown=e=>
{
    // take context from active elment
    document.activeElement.blur();

    // prevent getting stuck
    if (grabObject)
        return onclick(e);
    
    // ignore menu buttons
    if (e.target.localName == 'button')
        return;
    
    // hide menu if not clicked on
    e.target.offsetParent.id != 'menu' && (menu.style.visibility = '');
        
    // hide folders if not clicked on
    e.target.offsetParent.className != 'folder' && e.target != loadIcon &&
        CloseFolders();

    // only look for left mouse button
    if (e.button)
        return e.button == 2; // prevent all but right click
    
    // handle mouse down
    const originalTarget = e.originalTarget || e.path[0];
    e.target.MouseDown && e.target.MouseDown(e, originalTarget);
    
    if (grabObject)
    {
        // set grabbing mode
        document.body.style.cursor = grabObject.titlebarName.style.cursor = 'grabbing';
        grabObject.frameWrapper.style.pointerEvents = 'none';
        
        // save grab offset
        const rect = e.target.getBoundingClientRect();
        grabOffsetX = e.x - rect.x;
        grabOffsetY = e.y - rect.y;
    }
}

onmousemove=e=>
{
    if (grabObject)
    {
        // update grab object position
        grabObject.style.left = e.x - grabOffsetX;
        grabObject.style.top = e.y - grabOffsetY;
    }
    
    // unselect active program
    activeProgram && (activeProgram.className = 'program');
    
    // handle mouse move
    e.target.MouseMove && e.target.MouseMove();
}

onclick=e=>
{
    // allow pointer events and reset cursor
    document.body.style.cursor = '';
    if (grabObject)
    {
        grabObject.titlebarName.style.cursor = 'grab';
        grabObject.frameWrapper.style.pointerEvents = '';
    }
        
    // release grab object
    grabObject = 0;
    
    // hide menu
    menu.style.visibility = '';
        
    // focus on active window
    const originalTarget = e.originalTarget || e.path[0];
    e.target != loadIcon && e.target.localName != 'os13k-program' && activeWindow && 
        originalTarget.id != 'codeDisplay' && activeWindow.Focus();

    // handle click
    e.target.MouseClick && e.target.MouseClick(originalTarget);
}

oncontextmenu=e=>
{
    // hide menu
    menu.style.visibility = '';
    
    const menuElement = menu;
    if (!e.target.SetActive || e.target == loadIcon)
    {
        // open folder if clicked on desktop or folder icon
        menuElement = programsFolder;
        loadIcon.MouseClick();
    }
    if (e.target.window)
    {
        // set target frame active if it is an icon
        e.target.window.SetActive && e.target.window.SetActive();
    }
    else 
    {
        // set active if it is a window
        e.target.SetActive && e.target.SetActive();
    }
    
    // show menu
    menuElement.style.left = e.x;
    menuElement.style.top = e.y;
    menuElement.style.visibility = 'visible';
    
    // prevent default context menu
    return false;
}

ondblclick=e=>
{
    // go fullscreen if titlebar name or icon is double clicked
    const originalTarget = e.originalTarget || e.path[0];
    const target = e.target.window || e.target;
    if ((originalTarget.id == 'name') || e.target.window)
        target.FullScreen && target.FullScreen();
}

/////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth 

// init web audio
const audioContext = new (AudioContext || webkitAudioContext);
audioContext.Z = audioContext.createBufferSource;
audioContext.createBufferSource = (s = audioContext.Z())=>
(
    s.start = s.start || s.noteOn,
    s.stop  = s.stop  || s.noteOff,
    s
);

// setup gain node
const gain = audioContext.createGain();
gain.connect(audioContext.destination);
gain.gain.value = defaultVolume;

// play zzfx sound
const zzfx =
(
    // parameters
    volume=1, randomness=.05, frequency=220, attack=0, sustain=0, release=.1, shape=0, shapeCurve=1, slide=0, deltaSlide=0, pitchJump=0, pitchJumpTime=0, repeatTime=0, noise=0, modulation=0, bitCrush=0, delay=0,

    // locals
    PI2 = Math.PI*2,
    sampleRate = 44100,
    random = r => r*2*Math.random()-r,
    sign = v => v>0?1:-1,
    startSlide = slide *= 500 * PI2 / sampleRate**2,
    startFrequency = frequency *= (1 + random(randomness)) * PI2 / sampleRate,
    modPhase = sign(modulation) * PI2/4,
    b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, d=.5,
    length, buffer
) =>
{
    // init parameters
    attack = 99 + attack * sampleRate | 0;
    sustain = sustain * sampleRate | 0;
    release = release * sampleRate | 0;
    delay = delay * sampleRate | 0;
    deltaSlide *= 500 * PI2 / sampleRate**3;
    length = attack + sustain + release + delay;
    modulation *= PI2 / sampleRate;
    pitchJump *= PI2 / sampleRate;
    pitchJumpTime = pitchJumpTime * sampleRate;
    repeatTime = repeatTime * sampleRate;

    // generate waveform
    for(; i < length;b[i++] = s)
    {
        if (++c > bitCrush*100)                          // bit crush
        {
            c = 0;                                       // reset bit crush
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation - modPhase);    // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
                Math.sin((s%PI2)**3) :                   // 4 noise
                Math.max(Math.min(Math.tan(s),1),-1):    // 3 tan
                1-(2*s/PI2%2+2)%2:                       // 2 saw
                1-4*Math.abs(Math.round(s/PI2)-s/PI2):   // 1 triangle
                Math.sin(s);                             // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * (                              // envelope
                i < attack ? i/attack :                  // attack
                i < attack + sustain ? 1 :               // sustain
                i < length - delay ?                     // post release
                1 - (i - attack - sustain)/release : 0); // release
                
            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i-delay]/2) : s;
        }

        t += 1 + random(noise);             // noise
        tm += 1 + random(noise);            // modulation noise
        frequency += slide += deltaSlide;   // frequency slide

        if (j && ++j > pitchJumpTime)       // pitch jump
        {
            frequency += pitchJump;         // apply pitch jump
            startFrequency += pitchJump;    // also apply to start frequency
            j = 0;                          // reset pitch jump time
        };

        if (repeatTime && ++r > repeatTime) // repeat
        {
            frequency = startFrequency;     // reset frequency
            slide = startSlide;             // reset slide
            r = 1;                          // reset repeat time
            j = j || 1;                     // reset pitch jump time
        }
    }
    
    return OS13k.PlaySamples(b);
}

/////////////////////////////////////////////////////////////////////////////
// Start OS13k!

const OS13k = new _OS13k;
Init();
Update();

/////////////////////////////////////////////////////////////////////////////////////
// Touch Input (optional)

try
{
    let wasTouching;
    const ProcessTouch=e=>
    {
        const touching = e.touches.length;
        if (touching)
        {
            // set event pos
            e.x = e.touches[0].clientX;
            e.y = e.touches[0].clientY;
            
            // pass event on to mouse input
            !wasTouching && onmousedown(e);
            onmousemove(e);
        }
        else
            wasTouching && onclick(e);
        wasTouching = touching;
        
        return false; // prevent default
    }

    // set all touch events
    ontouchstart = ontouchmove = ontouchend = ontouchcancel = ProcessTouch;
}
catch (e) {}

</script>