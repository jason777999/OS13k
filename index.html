<!--

OS13k is a tiny operating system designed for JS13k.
It has native support for Shadertoys, Dweets, ZzFX, trophies, and more.
https://github.com/KilledByAPixel/OS13k

Please keep this project confidential!

❤️ OS13k Team ✌️😄

-->

<title>OS13k - A Tiny JavaScript Operating System</title>
<link rel=icon type=image/x-icon href='favicon.ico'/>
<meta name=viewport content='width=device-width,initial-scale=1,user-scalable=0'>
<script src=programs.js?v153></script>

<!-- HTML above is OPTIONAL -->

<meta charset=utf-8>
<style>
body
{
    opacity:0;
    margin:0;
    overflow:hidden;
    font-family:arial;
    font-size:22;
    user-select:none;
    white-space:nowrap;
    background:#000;
}
#menu
{
    display:flex;
    flex-direction:column;
    background:#000;
}
.programMenu { background:linear-gradient(#fff,#777); }
#menu, .programMenu
{
    visibility:hidden;
    position:absolute;
    z-index:20000;
    box-shadow:5px 5px 9px;
    border:2px solid;
}
.program
{
    font-size:18;
    height:18;
    padding:4;
}
.activeWindow { border:3px solid#aaa; }
#taskbar
{
    position:absolute;
    z-index:10000;
    width:100%;
    background:linear-gradient(#888,#333);
    box-shadow:0px 1px 9px;
    border:2px solid;
    left:-2;
}
.taskbarIcon { width:50; height:40; text-shadow:1px 1px 3px#000; }
.programActive,
.taskbarIconActive         { background:linear-gradient(#ff8,#fff); }
.taskbarIcon:hover         { background:linear-gradient(#fff,#44f); }
#tray
{
    margin:2;
    padding-left:9;
    padding-right:9;
    color:#fff;
    background:linear-gradient(#000,#333);
    border:1px solid;
    border-radius:6px;
    text-shadow:1px 1px 3px#000;
}
.trayIcon       { padding:2; }
.trayIcon:hover { background:#fff3; }
.popup
{
    position:relative;
    z-index:10000;
    width:200;
    padding:8;
    pointer-events:none;
    white-space:normal;
    text-align:center;
    background:linear-gradient(#eee,#888);
    box-shadow:9px 9px 19px;
    border:2px solid;
    border-radius:9px;
}
.trophyIcon
{
    padding:9;
    font-size:40;
    text-shadow:2px 2px 4px;
    white-space:nowrap;
}
#background
{
    position:absolute;
    width:100%;
    height:100%;
    color:#0002;
    font-family:impact;
    font-size:30vw;
    font-weight:900;
    position:absolute;
}
.program, #taskbar, .taskbarIcon, #background, #tray
{
    display:flex;
    align-items:center;
    justify-content:center;
}
</style>
<template id=T>
<style>
:host
{
    visibility:hidden;
    position:absolute;
    background:#000;
    box-shadow:5px 5px 9px;
    border:3px solid#222;
    border-radius:6px;
    overflow:hidden;
}
input, button,span { margin:4; }
textarea           { padding:9; }
span               { white-space:nowrap; }
.titlebar
{
    height:34;
    font-size:24;
    display:flex;
    align-items:center;
    white-space:nowrap;
    background:linear-gradient(#ccc,#444);
    border-bottom:3px solid;
}
.titlebarActive       { background:linear-gradient(#eee,#88f); }
.titlebarActiveUser   { background:linear-gradient(#eee,#8f8); }
.titlebarActiveSticky { background:linear-gradient(#eee,#f88); }
.titlebarSticky       { background:linear-gradient(#ccc,#844); }
#name                 { width:100%; overflow:hidden; cursor:grab; }
#icon           
{ 
    display:inline;
    text-shadow:1px 1px 3px#000;
    margin-left:9;
    margin-right:9;
    pointer-events:none;
}
#frame
{
    width:100%;
    height:100%;
    background:#fff;
    border:none;
    visibility:hidden;
}
#codeDisplay
{
    display:none;
}
#codeText
{
    height:199;
    background:#000;
    color:#fff;
}
#errorText
{
    background:#000;
    color:#f00;
}
#codeOptions
{
    background:#111;
    color:#fff;
    font-size:16;
    padding:10;
    white-space: normal;
}
#codeText, #errorText, #codeOptions
{
    width:100%;
    resize:none;
    outline:0;
    border-top:2px solid;
}
#Full:hover   { background:#fff; }
#Help:hover   { background:#0ff; }
#Code:hover   { background:#f0f; }
#Shrink:hover { background:#0ff; }
#Grow:hover   { background:#0f0; }
#Reload:hover { background:#ff0; }
#Close:hover  { background:#f00; }
</style>
</template>
<div id=background></div>
<div id=desktop>
<div id=taskbar>
<div id=taskbarSpace style=flex:1></div>
<div id=tray></div>
</div>
<div id=popups style=float:right></div>
<div id=programsMenu style=position:absolute></div>
<div id=menu>
<button id=buttonFullScreen>Full Screen
<button id=buttonCode>Code
<button id=buttonHelp>Help
<button id=buttonResetSize>Reset Size
<button id=buttonReload>Reload
<button id=buttonClose>Close
<script>

'use strict';

///////////////////////////////////////////////////////////////////////////////
// OS13k Debug (remove from minified)

const OS13kVersion = 68;
{
    // version check, clear local storage if older
    if (localStorage.OS13kVersion && localStorage.OS13kVersion != OS13kVersion)
    {
        alert('OS13k version out of date! System reset in 3, 2, 1...');
        localStorage.clear();
    }

    localStorage.OS13kVersion = OS13kVersion;

    // load default programs if none found
    if (typeof programs == 'undefined')
    {
        alert('No programs found!')
        var sticky = 2**0, reload = 2**1, awake = 2**2, full = 2**3, resize= 2**4, code = 2**5,
        closeAll = 2**7, newUserProgram = 2**8, clearUserPrograms = 2**9,
        defaultFlags = full|reload|resize, defaultWidth = 720, defaultHeight = 405,
        programs = 
        [
            [,'❌',,,closeAll,'Close All'],
            [,'😀',,,,'User Programs',,
            [
                [,'📌',,,newUserProgram,'New User Program'],
                [,'⚠️',,,clearUserPrograms,'Clear User Programs'],
            ]]
        ];
    }
} // debug stuff

///////////////////////////////////////////////////////////////////////////////
// Minification Stuff

{
// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs OS13k.Clamp, OS13k.Percent, OS13k.Lerp, OS13k.Hash
// @js_externs OS13k.Random, OS13k.randomSeed, iframeContent.OS13kReload
// @js_externs OS13k.Trophies, OS13k.Trophy, OS13k.GetTrophy
// @js_externs OS13k.PlaySamples, OS13k.Note
// @js_externs OS13k.PlayMusic, OS13k.GetAnalyser, OS13k.GetAnalyserData
// @js_externs OS13k.Speak, OS13k.StopSpeech, OS13k.PlaySeed
// @js_externs OS13k.SeedSamples, OS13k.SeedParameters
// @js_externs OS13k.Settings, OS13k.SaveSettings
// @js_externs OS13k.CreateShader, OS13k.RenderShader, source.gain
// @js_externs OS13k.KeyDirection, OS13k.StripHTML, OS13k.Popup
// @js_externs localStorage.OS13k, OS13k, zzfxG
// @js_externs iframeContent.OS13k, iframeContent.OS13kWindow
// @js_externs iframeContent.zzfx, iframeContent.zzfxG
// @js_externs settings.v, settings.m, settings.s, settings.p, settings.o
// @js_externs settings.c, settings.d, settings.t, settings.f
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==

// Minification Steps
// 1. Remove touch support and optional code
// 2. Paste programs directly below here
// 3. Remove optional stuff listed below
// 4. Verify that it works the same
// 5. HTML Minifier http://minifycode.com/html-minifier/
// 6. Google Closure https://closure-compiler.appspot.com/home
// 7. Terser no extra compression https://xem.github.io/terser-online/
// 8. Zip
// 9. Advzip "advzip -z -4 -i 1000 OS13kMin.zip"

// Rework stuff marked OPTIONAL for final build
// - all files must be packed together to save space
// - smaller webgl names r10215
// - move css into code, get rid of names
// - remove system trophies
// - remove console messages

} // Minification Stuff

///////////////////////////////////////////////////////////////////////////////
// OS13k Client Interface

class _OS13k
{

/////////////////////////////////////////////////////////////////////////////
// OS13k Math

    Clamp   = (a, min=0, max=1)=>  Math.min(Math.max(a, min), max);
    Percent = (v, a, b)=>          b-a ? this.Clamp((v-a)/(b-a), 0, 1) : 0;
    Lerp    = (p, a, b)=>          a + this.Clamp(p, 0, 1) * (b-a);

    // convert string to hash value like Java's hashCode()
    Hash    = (s)=>                [...s].reduce((a,c)=>c.charCodeAt()+a*31|0, 0);
    
    // seeded random numbers - Mersenne Twister
    Random  = (max=1, min=0)=>
    (
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= this.randomSeed << 13 || 1,
        this.randomSeed ^= this.randomSeed >> 17,
        this.Percent(Math.abs(this.randomSeed ^= this.randomSeed << 5) % 1e9 / 1e9, min, max)
    )

/////////////////////////////////////////////////////////////////////////////
// OS13k Trophies
    
    // award player with trophy, returns 0 if already owned
    Trophy(game='', icon='', name='', message='')
    {
        // replace commas and apostrophes
        const Clean = string=>this.StripHTML(string, maxWordLength).replace(/[,`]/g, '');
        game    = Clean(game);
        icon    = Clean(icon);
        name    = Clean(name);
        message = Clean(message);
        
        // build key
        const key = game + `,${ icon },` + name;
                
        // find in trophy list
        const i = trophies.findIndex(e=>e[4] == key);
        
        // skip if same message
        if (i >=0 && trophies[i][3] == message) return;
        
        // add or update trophy list
        const trophyData = [game, name, icon, message, key];
        i < 0 ? trophies.unshift( trophyData ) : trophies[i] = trophyData;

        // save trophy
        localStorage['OS13kTrophy,' + key] = message;

        // use game as name if there is no name
        name || (name = game, game = '')

        // add trophy popup
        this.Popup(`<div class=trophyIcon>${   // popup html
                icon || '🏆' }</div><div><b>${ // icon
                name }</b><br><i>${            // name
                game }</i></div>` +            // game
                message,                       // message
            name,                              // speak
            'ja');                             // language
        
        // save and reload trophy window
        this.Save(trophyTrayIcon.program.window?.Reload());
    }
    
    // get message, 0 if no trophy
    GetTrophy = (game, name)=> trophies.find(e=>e[0]==game & e[1]==name);
    
    // get trophy list
    Trophies = ()=> trophies;
    
    // get trophy list
    ClearTrophies = ()=> trophies = [];
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Audio

    // play seed sound
    PlaySeed(seed, lengthScale=1, volume=1, randomness=.05, frequency, music)
    { return this.PlaySamples(this.SeedSamples(...arguments), music); }
    
    // get seed samples
    SeedSamples(seed, lengthScale=1, volume=1, randomness=.05, frequency)
    { return zzfxG(...this.SeedParameters(...arguments)); }
    
    // get zzfx sound parameters from seed
    SeedParameters(seed, lengthScale=1, volume=1, randomness=.05, frequency)
    {
        // check if seed is a number
        if (parseFloat(seed = (seed+'').trim()) != seed)
        {
            // seed is not number, check if zzfx string and apply overrides
            if (seed.slice(0,9) == 'zzfx(...[')
                return seed.slice(9).split(',').map((p,i)=>
                    !i ? volume :
                    i==1 ? randomness :
                    i==2 && frequency ? frequency :
                    p.length ? parseFloat(p) : undefined);
            
            // use hash string as seed 
            seed = this.Hash(seed);
        }

        // set seed
        this.randomSeed = seed;
        
        // clamp max length
        lengthScale = this.Clamp(lengthScale, 0, 5);
     
        // helper functions
        const R = ()=>this.Random(), C = ()=>R()<.5?R():0, S = e=>C()?e:-e,
        
            // randomize sound length
            attack  = R()**3/4*lengthScale,
            decay   = R()**3/4*lengthScale,
            sustain = R()**3/4*lengthScale,
            release = R()**3/4*lengthScale,
            length  = attack + decay + sustain + release,
            f = R()**2*2e3;
        
        // generate random sound
        return [
           volume,           // volume
           randomness,       // randomness
           frequency || f,   // frequency
           attack,           // attack
           sustain,          // sustain
           release,          // release
           R()*5|0,          // shape
           R()**2*3,         // shapeCurve
           C()**3*S(99),     // slide
           C()**3*S(99),     // deltaSlide
           C()**2*S(1e3),    // pitchJump
           R()**2 * length,  // pitchJumpTime
           C() * length,     // repeatTime
           C()**4,           // noise
           C()**3*S(9),      // modulation
           C()**4,           // bitCrush
           C()**3/2,         // delay
           1 - C(),          // sustain volume
           decay             // decay
        ];
    }
    
    // play audio sample data
    PlaySamples = (samples, music, sampleRate=defaultSampleRate)=>
        this.PlaySamplesArray([samples], music, sampleRate);
    
    // play array of audio sample data, connect analyser to gain if musicOrInstrument > 1
    PlaySamplesArray(samplesArray, musicOrInstrument, sampleRate=defaultSampleRate)
    {
        // create buffer and source
        const buffer = audioContext.createBuffer(samplesArray.length, samplesArray[0].length, sampleRate),
            source = audioContext.createBufferSource();
        
        // copy samples to buffer and play
        samplesArray.map((d,i)=>buffer.getChannelData(i).set(d));
        source.buffer = buffer;
        
        // create custom gain node
        source.connect(source.gain = audioContext.createGain());
        source.gain.connect(musicOrInstrument ? gainMusic : gain);
        
        // connect analyser and start
        musicOrInstrument && (musicOrInstrument > 1 ? source.gain : source).connect(musicAnalyser);
        source.start();
        return source;
    }
    
    PlayMusic(song) 
    { 
        // handle errors when playing music
        try { return this.PlaySamplesArray(zzfxM(...song), 1); }
        catch(e) { console.log(e); }
    }
    
    GetAnalyser = ()=> analyserCanvas;
    GetAnalyserData =e=> analyserData[e];
    
    // get frequency of a note on a musical scale
    Note = (semitoneOffset=0, rootNoteFrequency=440, scaleNotes=12)=>
        rootNoteFrequency * 2**(semitoneOffset/scaleNotes);

    // speak text
    Speak(text, rate=1, pitch=1, volume=1, language='en', stopSpeech)
    {
        // common languages (not supported by all browsers)
        // it - italian,  fr - french, de - german,  es - spanish, pl - polish
        // ja - japanese, hi - hindi,  ru - russian, zh - chinese, ko - korean
    
        // set utterance parameters
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.volume = volume * gain.gain.value * 3;
        utterance.pitch = pitch;
        utterance.rate = rate;
        utterance.lang = language;

        // stop speech if set
        stopSpeech && OS13kSystem.StopSpeech();

        // play speech if allowed
        settings.s && finishedStartup && speechSynthesis && speechSynthesis.speak(utterance);
    }

/////////////////////////////////////////////////////////////////////////////
// OS13k Shaders

    // create pixel shader
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl2'),
        
            // use hardcoded glsl constants to save space
            xVERTEX_SHADER       = 35633,
            xARRAY_BUFFER        = 34962,
            xSTATIC_DRAW         = 35044,
            xBYTE                = 5120,
            xFRAGMENT_SHADER     = 35632,
            xCOMPILE_STATUS      = 35713,
            xTEXTURE_2D          = 3553,
            xUNPACK_FLIP_Y_WEBGL = 37440,
            xTEXTURE_MIN_FILTER  = 10241,
            xLINEAR              = 9729;

        // create a simple pass through vertex shader
        const vertexShader = x.createShader(xVERTEX_SHADER);
        x.shaderSource(vertexShader, '#version 300 es\nin vec4 c;void main(){gl_Position=c;}');
        x.compileShader(vertexShader);
        
        // check vertex shader for errors
        //if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
        //    throw x.getShaderInfoLog(vertexShader);
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(xFRAGMENT_SHADER);
        const shaderProgramCode = 
            '#version 300 es\n' +
            'precision mediump float;' +
            'uniform float iTime;' +
            'uniform int iFrame;' +
            'uniform vec4 iMouse;' +
            'uniform vec3 iResolution;' +
            'uniform sampler2D iChannel0;' +
            'out vec4 OS13kcolor;\n' +
            code +
            '\nvoid main()' +
            '{mainImage(OS13kcolor,gl_FragCoord.xy);' +
            'OS13kcolor.a=1.;}';
        x.shaderSource(pixelShader, shaderProgramCode);
        x.compileShader(pixelShader);

        // check pixel shader for errors
        if (!x.getShaderParameter(pixelShader, xCOMPILE_STATUS))
            throw x.getShaderInfoLog(pixelShader);
        
        // create vertex buffer that is a big triangle
        x.bindBuffer(xARRAY_BUFFER, x.createBuffer());
        x.bufferData(xARRAY_BUFFER, new Int8Array([-3,1,1,-3,1,1]), xSTATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0, 2, xBYTE, 0, 0, 0); // 2D vertex

        // create texture
        x.bindTexture(xTEXTURE_2D, x.createTexture());
        x.texParameteri(xTEXTURE_2D, xTEXTURE_MIN_FILTER, xLINEAR);
        x.pixelStorei(xUNPACK_FLIP_Y_WEBGL, 1); 
        
        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    // render a pixel shader
    RenderShader(canvas, shaderProgram, time, frame, X, Y, Z, W)
    {
        // get webgl context
        const x = canvas.getContext('webgl2'),
        
            // use hardcoded glsl constants to save space
            xRGBA          = 6408,
            xUNSIGNED_BYTE = 5121,
            xTRIANGLE_FAN  = 6,
            xTEXTURE_2D    = 3553;
        
        // set uniforms
        x.uniform3f(x.getUniformLocation(shaderProgram, 'iResolution'), canvas.width, canvas.height, 1);
        x.uniform1f(x.getUniformLocation(shaderProgram, 'iTime'), time);
        x.uniform1f(x.getUniformLocation(shaderProgram, 'iFrame'), frame);
        x.uniform1i(x.getUniformLocation(shaderProgram, 'iChannel0'), 0);
        x.uniform4f(x.getUniformLocation(shaderProgram, 'iMouse'), X, Y, Z, W);
        
        // set vieport and render shader
        x.viewport(0, 0, canvas.width, canvas.height);
        x.drawArrays(xTRIANGLE_FAN, 0, 3);
        
        // set texture to newly rendered image
        x.texImage2D(xTEXTURE_2D, 0, xRGBA, xRGBA, xUNSIGNED_BYTE, canvas);
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Text
    
    // remove html tags from a string and clamp length
    StripHTML = (string, maxLength)=>
        (string+'').substring(0, maxLength || string.length).replace(/<.*>/g, '');
    
    Popup(html, speak, language)
    {
        // create popup
        const popup = popups.appendChild(document.createElement('div'));
        popup.className = 'popup';
        popup.innerHTML = html;
        popup.speak = speak;
        popup.speakLanguage = language;
        popup.style.visibility = 'hidden';
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Seralization
    
    Save()
    {
        // save data if finished startup
        finishedStartup && (localStorage.OS13k = JSON.stringify({
            t:trophies,
            s:settings,
            i:programInfos,
            p:startProgramId,
            n:nextUserProgramId
        }));
        
        // volume
        gain.gain.value = settings.v;
        gainMusic.gain.value = settings.m;
           
        // stop speech if not enabled or sound muted
        settings.s && settings.v || OS13kSystem.StopSpeech();
        
        // background
        background.style.background = `linear-gradient(${settings.c},${settings.d})`;
        background.innerText = settings.t;
        
        // filter
        background.style.filter = desktop.style.filter = settings.f;
    }
    
    SaveSettings(volume, musicVolume, speech, popups, systemSounds, color1, color2, text, filter)
    {
        // set settings and save
        this.Save(settings = {
            v:gain.gain.value = volume,
            m:gainMusic.gain.value = musicVolume,
            s:speech,
            p:popups,
            o:systemSounds,
            c:color1,
            d:color2,
            t:text,
            f:filter
        });
    }
    
    Settings = ()=> settings;
}; // _OS13k
var OS13k = new _OS13k;

///////////////////////////////////////////////////////////////////////////////
// OS13k Variables

const taskbarHeight = 44, titlebarHeight = 37, programHeight = 26, 
      startOpenOffset = 9, popupTime = 3, defaultVolume = .3, 
      maxWordLength = 32, defaultSampleRate = 44100, analyserWaitTime = 1e4,

    // system sounds
    soundOpen       = -8,
    soundClose      = 92,
    soundGrabStart  = 45,
    soundGrabEnd    = 42,
    soundMenu       = 8,
    soundTrophy     = 96,
    soundActive     = 66,
    soundShrink     = 75,
    soundGrow       = 61,
    soundFullScreen = -9,
    soundHelp       = 48,
    soundCode       = 16,
    soundReload     = 85,
    soundProgram    = 90,

    // init web audio
    audioContext = new AudioContext, 
    gain = audioContext.createGain(), 
    gainMusic = audioContext.createGain(), 
    musicAnalyser = audioContext.createAnalyser();

let grabWindow, grabOffsetX, grabOffsetY, finishedStartup, nextUserProgramId = 0,
    activeWindow, activeProgram, activeTaskbarIcon, loadIcon, allCodeIsSafe,
    analyserCanvas, analyserData = [], lastMusicTime = -analyserWaitTime,
    lastActiveFrame, topZ = 0, loading = 0, hadInput = 0,
    windowOpenX = startOpenOffset, windowOpenY = startOpenOffset + taskbarHeight,
    startProgram, startProgramId, programInfos = [], trophies = [],
    trophyTrayIcon, settingsTrayIcon, clockTrayIcon, musicTrayIcon,

    // volume, music, speech, popups, color1, color2, text, filter
    settings = {v:.3, m:.3, s:1, p:1, o:1, c:'#222233', d:'#332222', t:'OS13k', f:''};

///////////////////////////////////////////////////////////////////////////////
// OS13k System Functions - handles non client facing features of OS13k

class _OS13kSystem
{
    Start()
    {
        // load os13k data
        if (localStorage.OS13k)
        {
            const saveData    = JSON.parse(localStorage.OS13k);
            trophies          = saveData.t;
            settings          = saveData.s;
            programInfos      = saveData.i;
            startProgramId    = saveData.p;
            nextUserProgramId = saveData.n;
        }
        
        // save and update settings
        OS13k.Save();
        
        // setup audio
        gain.connect(audioContext.destination);
        gainMusic.connect(audioContext.destination);
        
        // create tray icons
        musicTrayIcon     = new OS13kTrayIcon();
        trophyTrayIcon    = new OS13kTrayIcon();
        settingsTrayIcon  = new OS13kTrayIcon();
        clockTrayIcon     = new OS13kTrayIcon();
        
        // create analyser canvas
        analyserCanvas = musicTrayIcon.appendChild(document.createElement('canvas'));
        analyserCanvas.style = 'width:16;height:16;margin:2;pointer-events:none';
        
        // listen for trophies from other windows
        onstorage = e=> this.CheckForTrophy(e.key);

        // stop spech if page is unloaded
        onunload = e=> this.StopSpeech();

        // set menu button functions
        buttonFullScreen.onmousedown =()=> activeWindow.FullScreen();
        buttonHelp.onmousedown       =
        buttonCode.onmousedown       =()=> activeWindow.ShowCode();
        buttonResetSize.onmousedown  =()=> activeWindow.SetActive(1, 1, activeWindow.Resize(1, soundGrow));
        buttonReload.onmousedown     =()=> activeWindow.Reload();
        buttonClose.onmousedown      =()=> activeWindow.Close();

        // create load program taskbar icon and add folders/programs
        loadIcon = new OS13kTaskbarIcon( {icon:'💾', name:'Load Program'}, new OS13kProgramMenu(programs) );
        loadIcon.windowOrMenu.Rebuild();

        // welcome message
        OS13k.Trophy('', '👋', 'Welcome to OS13k!');

        // search local storage for new trophies (from other JS13k games)
        for (const key in localStorage) this.CheckForTrophy(key);

        // try to update startup and kick off first update
        this.Update(this.UpdateStartup());
    }

    // wait for startup to finish
    UpdateStartup()
    {
        // skip until not loading and finished startup
        if (loading | finishedStartup) return;
            
        // open start program (check top to stop infinite recursion if meta)
        self == top | startProgram?.sticky && startProgram?.Open?.(startProgram = 0);
            
        // finish startup after opening startup programs
        finishedStartup = 1;
        
        // save os13k data
        OS13k.Save();
    }

    // main update loop
    Update(time)
    {
        // request new animation frame
        requestAnimationFrame(OS13kSystem.Update);
            
        // check if iframe became new active element
        const activeElement = document.activeElement;
        const activeFrame = 
            activeElement.shadowRoot?.activeElement == activeElement.iframe ? 
            activeElement.iframe : 0;
                
        // if a new frame took focus, set window active and that we had input
        activeFrame && lastActiveFrame != activeFrame && activeElement.SetActive(hadInput = 1);
         
         // set last active frame
        lastActiveFrame = activeFrame;

        // fade in desktop after loading, convert opacity to number
        loading || (document.body.style.opacity = Math.min(1,.02 + document.body.style.opacity*1));

        // update trophy count
        trophyTrayIcon.innerHTML = trophies.length + ' 🏆';
        
        // update time
        clockTrayIcon.title = new Date();
        clockTrayIcon.innerHTML = clockTrayIcon.title.replace(/.* (\d+:\d+):.*/, '$1');
        
        // get analyser data
        musicAnalyser.fftSize = 512;
        const frequencyData = new Uint8Array(512),
            context = analyserCanvas.getContext('2d');
        musicAnalyser.getByteFrequencyData(frequencyData);
        analyserCanvas.width = analyserCanvas.height = 32

        // render analyser
        for(let i = 0; i < 32; )
        {
            // get frequency band volume and adjust for loudness
            const volume = (frequencyData[i+3] / 255)**3 * (1 + Math.log10((i+3) * defaultSampleRate / 1024 ));

            // draw loudness bar
            context.fillStyle = `hsl(${-99-59*volume} 99%50%)`;
            context.fillRect(i, 31, 1, -7*volume);
            
            // set anaylzer data, normalize between 0-1
            analyserData[i++] = OS13k.Clamp(volume / 5, 0, 1);

            // save how long there has been no music
            lastMusicTime = volume ? time : lastMusicTime;
        }
        
        // set analyser visibility
        analyserCanvas.style.display = time - lastMusicTime < analyserWaitTime ? '' : 'none';
        
        // show popups after startup is finished and there was input
        if (!finishedStartup || !hadInput) return;
        
        // update popups, use copy to prevent skipping if removed
        let offsetY = 0;
        [...popups.children].map((popup,i)=>
        {
            // speak popup
            popup.speak && OS13k.Speak(popup.speak, 1, 1, 1, popup.speakLanguage);
            popup.speak = 0;
            
            if (!settings.p)
                popups.removeChild(popup);
            else if (!document.fullscreenElement)
            {
                // move popup up, set to bottom if it was invisible
                let y = popup.style.visibility ? innerHeight : parseInt(popup.style.top) + offsetY - 9;
                popup.style.visibility = '';
                
                if (y < taskbarHeight)
                {
                    // stop popup below taskbar
                    y = taskbarHeight;

                    // fade out popup if at top
                    if (!i && (popup.style.opacity = (popup.style.opacity || popupTime) - .01) < 0)
                    {
                        // remove when invisible and adjust for height
                        offsetY += popup.getBoundingClientRect().height;
                        popups.removeChild(popup);
                    }
                }

                // set popup position
                popup.style.top = y;
            }});
    }

    // close all menus
    CloseMenus()
    {
        // hide all menus
        for(const child of programsMenu.children)
            child.style.visibility = menu.style.visibility = '';
        
        // unselect active program
        activeProgram && (activeProgram.className = 'program');
    }

    // try to give trophy if key is valid
    CheckForTrophy(key)
    {
        const keyParts = key ? key.split(',') : [];
        return keyParts.shift() == 'OS13kTrophy' &&
            OS13k.Trophy(...keyParts, localStorage[key]);
    }
    
    // stop any current or queued speech
    StopSpeech() { speechSynthesis && speechSynthesis.cancel(); }
    
    // play system sound if enabled
    Sound(seed, length) { finishedStartup && hadInput && settings.o && OS13k.PlaySeed(seed, length); }

} // OS13kSystem
const OS13kSystem = new _OS13kSystem;

///////////////////////////////////////////////////////////////////////////////
// OS13kProgramMenu - holds a list of programs

class OS13kProgramMenu extends HTMLElement
{
	constructor(infos, parentMenu)
    {
		super();
        
        // add to programs menu
        this.className    = 'programMenu';
        this.parentMenu   = parentMenu;
        this.programInfos = infos;
        
        // add programs to menu
        for(const info of infos)
        {
            // create program and menu
            const program = info.program = new OS13kProgram(...info);  
            program.programMenu = program.folder ? new OS13kProgramMenu(program.folder, this) : this;  
                
            // create user program info and add to info list after clear
            program.flags & clearUserPrograms &&
                programInfos.map(info=> info.code != undefined && infos.push(
                    [,info.icon,info.width,info.height,defaultFlags|code,info.name,,,info.id]));
        }
    }
    
    Rebuild(y = 0)
    {
        // clear programs menu
        this.innerHTML = '';
        programsMenu.appendChild(this);
  
        // add programs to menu
        this.programInfos.map(info=>this.appendChild(info.program));
        
        // set position
        this.style.top  = y;
        this.style.left = this.parentMenu ?
            this.parentMenu.getBoundingClientRect().right - 2 : 
            programsMenu.style.left = 0;

        // add folders after programs so width is correct
        this.programInfos.map(info=>
        {
            // rebuild child program menus
            info.program.programMenu != this && info.program.programMenu.Rebuild(y);
            
            // add program height as we move down list
            y += programHeight;
        });
    }

    SetActive()
    {
        // close menus so they can reopen with this active
        OS13kSystem.CloseMenus();
        
        // set parent active
        this.parentMenu?.SetActive();
        
        // make visible
        this.style.visibility = 'visible';
    }

    AddUserProgram(copyProgram)
    {
        // create new program
        const program = new OS13kProgram(...
            copyProgram ? 
            [,copyProgram.icon, copyProgram.width, copyProgram.height, defaultFlags|code, 
                copyProgram.name + '+', , ,++nextUserProgramId] :
            [,'✋',,,defaultFlags|code,,,,++nextUserProgramId]);
        
        // add to menu program infos
        this.programInfos.push({program});
        
        // set menu and rebuild menus
        program.programMenu = this;
        loadIcon.windowOrMenu.Rebuild();
        
        // set code, use default if none found
        program.info.code = copyProgram ? copyProgram.info.code :
        '// Auto detects HTML, Dweet, or Shadertoy! ✌️😄\n' +
        'for(x.fillRect(0,0,i=s=2e3,s);i--;x.globalAlpha=.1)\n' +
        'x.clearRect((S(i)*1e9-t*i/9)%s,i*9%s,i%9,i%9)';

        // copy program info, set position below original
        copyProgram && (
            program.info.scale = copyProgram.info.scale,
            windowOpenX = copyProgram.info.x,
            windowOpenY = copyProgram.info.y + titlebarHeight);
            
        // mark code as safe, open, and show code
        program.stopFocus = 1;
        program.Open(program.userProgram = allCodeIsSafe = 1);
        program.window.ShowCode(1);
        program.window.codeText.focus();
        program.stopFocus = 0;
        return program;
    }

} // OS13kProgramMenu
customElements.define('m-', OS13kProgramMenu);

///////////////////////////////////////////////////////////////////////////////
// OS13kProgram - stores program info and handles loading from folders
    
class OS13kProgram extends HTMLElement
{
	constructor(src='', icon='💠', width=defaultWidth, height=defaultHeight, flags, name='', help='', folder, userProgramId)
    {
		super();
        
        // split source by . to get extension
        const srcParts = src.split('.');
        
        // split source by / to get filename to convert camel case to nice name
        const srcCleanName = srcParts[0].split('/').pop().replace(/([a-z](?=[A-Z]))/g, '$1 ');
        name = name || srcCleanName && (srcCleanName[0].toUpperCase() + srcCleanName.slice(1));
        
        // check for special extensions
        this.isDweet =  srcParts[1] == 'dweet';
        this.isShader = srcParts[1] == 'shader';

        // set icon data
        this.className = 'program';
        this.src       = src;
        this.width     = width;
        this.height    = height;
        this.folder    = folder;
        this.id        = userProgramId || name;

        // set the program name and id
        this.SetName(icon, name);

        // set code only if help not shown or if has extension and not disabled
        this.code = !(this.help = help) && 
            (flags & code || ((this.isDweet | this.isShader) && flags == undefined));
        
        // set flags
        this.flags    = flags = flags || defaultFlags;
        this.sticky   = flags & sticky;
        this.reload   = flags & reload;
        this.awake    = flags & awake;
        this.full     = flags & full;
        this.resize   = flags & resize;
        
        // load saved program data
        this.Load();

        // check for user code
        this.userProgram = this.info.code != undefined;
        
        // save special programs
        name == 'Settings'     && settingsTrayIcon.SetProgram(this);
        name == 'Trophy Case'  && trophyTrayIcon.SetProgram(this);
        name == 'Clock'        && clockTrayIcon.SetProgram(this);
        name == 'Music Player' && musicTrayIcon.SetProgram(this);
        
        // open help if it has not been opened yet
        name == 'Help' && this.info.open == undefined && (startProgram = this);
        
        // check if sticky open or start program
        this.sticky ? this.info.open && this.Open() :
            this.id == startProgramId && (startProgram = this);
    }

    SetName(icon, name)
    {
        // clear html
        this.innerHTML = '';

        // create div for icon to auto close html tags
        const iconDisplay = this.appendChild(document.createElement('div'));
        iconDisplay.style = 'pointer-events:none;width:45;text-shadow:1px 1px 3px #000;text-align:center';
        iconDisplay.innerHTML = this.icon = icon;;
        
        // name and folder
        this.innerHTML += `<div style=flex:1;padding-right:9;pointer-events:none>${
            this.name = OS13k.StripHTML(name) || 'User Program ' + this.id
            }</div>` + (this.folder? '▶' : '');
    }
    
    Move()
    {
        // set container program menu active 
        this.programMenu.SetActive();
        
        // set active
        this.className = 'program programActive';
        activeProgram !=this && OS13kSystem.Sound(soundProgram, 0);
        activeProgram = this;
    }
    
    Open()
    {
        if (this.window)
        {        
            // set window to be active and clamp
            this.window.SetActive(1, 1);
        }
        else if (this.src || this.userProgram)
        {
            // get saved window position
            let x = this.info.x, y = this.info.y;
            
            // update window open positions if no position was set
            x || (
                x = windowOpenX,
                y = windowOpenY,
                (windowOpenX += titlebarHeight) > 400 && (windowOpenX =  windowOpenY = startOpenOffset),
                (windowOpenY += titlebarHeight) > 300 && (windowOpenY =  windowOpenY = startOpenOffset + taskbarHeight));
            

            // open window
            this.window = new OS13kWindow(this, x, y);

            // update info and save
            this.Save();
        }
        if (this.flags & newUserProgram)
        {
            // create user program with default code
            this.programMenu.AddUserProgram();
        }
        if (this.flags & closeAll)
        {
            // close all windows if no src or folder and play sound
            [...desktop.children].map(child=>child.Close?.());

            // reset window open position
            windowOpenX = startOpenOffset;
            windowOpenY = startOpenOffset + taskbarHeight;

            OS13k.Trophy('OS13k', '☕', 'Coffee Is For Closers', 'Closed All');
        }
        if (this.flags & clearUserPrograms && confirm(this.name + '?'))
        {
            // remove from menu info and close windows
            this.programMenu.programInfos = this.programMenu.programInfos.filter(info=>
                !info.program.userProgram || (info.program?.window?.Close(), false));
            OS13kSystem.Sound(soundClose, 4);
            
            // remove user program infos
            programInfos = programInfos.filter(info=>info.code == undefined);
            OS13k.Save();
            
            // rebuild menu
            loadIcon.windowOrMenu.Rebuild();
        }
    }
    
    SetActive() { this.Open(); }
    
    Toggle() { activeWindow == this.window ? this.window.Close() : this.Open(); }
    
    Load() 
    {
        // load saved program info from local storage
        const i = programInfos.findIndex(e=>e.id == this.id);
        this.info = i < 0 ? {} : programInfos[i];
    }

    // save program info and reset settings when closed if non sticky
    Save(open = 1)
    {
        // build save info
        this.info = 
        {
            open,
            id: this.id,
            x: open | this.sticky ? parseInt(this.window.style.left) : 0,
            y: parseInt(this.window.style.top),
            scale: open | this.sticky ? this.window.scale : 1,

            // user program info
            name: this.name,
            icon: this.icon,
            width: this.width,
            height: this.height,
            code: this.info.code,
            allowSleep: this.userProgram? this.window.allowSleep.checked : 1,
            liveEdit: this.window.liveEdit.checked
        }
        
        // add to programs info and save
        const i = programInfos.findIndex(e=>e.id == this.id);
        i < 0 ? programInfos.push(this.info) : programInfos[i] = this.info
        OS13k.Save();
    }
    
} // OS13kProgram
customElements.define('p-', OS13kProgram);

///////////////////////////////////////////////////////////////////////////////
// OS13kWindow - window to a running program, handles program loading

class OS13kWindow extends HTMLElement
{
	constructor(program, x, y)
    {
		super();

        // add to desktop
        desktop.appendChild(this);
        
        // save settings
        this.program = program;
        this.style.left = x;
        this.style.top = y;
        this.menu = 1;
        this.activeCount = 0;
        
        // shadow root
		this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = T.innerHTML;
        
        // title bar
        this.titlebar = this.shadowRoot.appendChild(document.createElement('div'));
        this.titlebar.id = 'titlebar';
        
        // title bar name
        this.name = this.titlebar.appendChild(document.createElement('div'));
        this.name.id = 'name';

        const SetName = ()=>
        {
            // clear html
            this.name.innerHTML = '';

            // create div for icon to auto close html tags
            const icon = this.name.appendChild(document.createElement('div'));
            icon.id = 'icon';
            icon.innerHTML = program.icon;

            // name
            this.name.innerHTML += program.name;
        }
        SetName();
       
        // create title bar icons
        const AddTitlebarIcon=(title, svg, shape='path')=>
        {
            const icon = this.titlebar.appendChild(document.createElement('div'));
            icon.id = title.split(' ')[0];
            icon.title = title;
            icon.innerHTML = 
            `<svg style=height:100%;width:28;pointer-events:none viewBox='0 0 10 10'><${shape} stroke=#000 fill=none ${svg} />`;
        }
        program.resize && 
            AddTitlebarIcon('Grow', 'd="M2 5L8 5M5 8L5 2"',
            AddTitlebarIcon('Shrink', 'd="M2 5L8 5"'));
        program.full && AddTitlebarIcon('Full Screen', 'x=1 y=2 width=8 height=6', 'rect');
        program.help && AddTitlebarIcon('Help', 'd="M5 8L8 2L2 2L5 8L8 2"');
        program.code && AddTitlebarIcon('Code', 'd="M5 2L8 8L2 8L5 2L8 8"');
        program.reload && AddTitlebarIcon('Reload', 'cx=5 cy=5 r=3', 'circle');
            AddTitlebarIcon('Close', 'd="M2 2L8 8M8 2L2 8"');

        // create content wrapper
        this.iframeWrapper = this.shadowRoot.appendChild(document.createElement('div'));
        this.iframeWrapper.style.background = '#000';

        // create code/help display
        this.codeDisplay = this.shadowRoot.appendChild(document.createElement('div'));
        this.codeDisplay.id = 'codeDisplay';

        // create code/help display
        this.codeText = this.codeDisplay.appendChild(document.createElement('textarea'));
        this.codeText.id = 'codeText';
          
        // use custom code  
        program.userProgram ? this.codeText.value = program.info.code : this.codeText.readOnly = true;
        this.codeText.spellcheck = false;

        // init custom code options
        const codeOptions = this.codeOptions = this.codeDisplay.appendChild(document.createElement('div'));
        codeOptions.id = 'codeOptions';
        program.userProgram || (codeOptions.style.display = 'none');

        // build code options html
        codeOptions.innerHTML = 
            '<span><button id=S>📷</button></span>' +
            '<span>Icon <input style=width:35 id=I></span> ' +
            '<span>Name <input id=N></span> ' +
            '<span>Size <input style=width:50 type=number id=W>x<input style=width:50 type=number id=H></span>' + 
            `<span>Sleep <input type=checkbox id=P ${program.info.allowSleep != false ? 'checked' : ''}></span>` +
            `<span>Live Edit <input type=checkbox id=L ${program.info.liveEdit != false ? 'checked' : ''}></span>` +
            '<span><button id=G>Save</button></span>' +
            '<span><button id=C>Copy</button></span>' +
            '<span><button id=D>Delete</button></span>' +
            `<span><span id=Z>${program.info.code?.length}</span> Bytes` +
            '<a id=A><canvas id=V style=display:none>';

        // get links to code options and create error text
        const iconInput = this.shadowRoot.getElementById('I'),
            nameInput = this.shadowRoot.getElementById('N'),
            widthInput = this.shadowRoot.getElementById('W'),
            heightInput = this.shadowRoot.getElementById('H'),
            link = this.shadowRoot.getElementById('A'),
            canvas = this.shadowRoot.getElementById('V'),
            canvasContext = canvas.getContext('2d'),
            errorText = this.errorText = this.codeDisplay.appendChild(document.createElement('textarea'));
        errorText.id = 'errorText';
        errorText.readOnly = true;
        
        // copy button
        this.shadowRoot.getElementById('C').onmousedown=()=>program.programMenu.AddUserProgram(program);

        // delete button
        this.shadowRoot.getElementById('D').onmousedown=()=>
        {
            // remove from menu info and close
            program.programMenu.programInfos 
                = program.programMenu.programInfos.filter(info=>info.program.info.id != program.id);
            this.Close();
            
            // remove infos
            programInfos = programInfos.filter(info=>info.id != program.id);

            // close, save, and rebuild menu
            OS13k.Save();
            loadIcon.windowOrMenu.Rebuild();
        }
        
        // save button
        this.shadowRoot.getElementById('G').onmousedown=()=>
            link.click(link.href = URL.createObjectURL(new Blob([this.codeText.value], {type:'text/plain'})),
            link.download = 'OS13k_File_' + program.name);

        // screenshot button
        this.screenshot = this.shadowRoot.getElementById('S');
        this.screenshot.onmousedown=()=>
        {
            // wrap in try block in case canvas doesnt exist
            try {
                link.click(
                    // copy to a white canvas before saving
                    canvasContext.fillStyle = '#fff',
                    canvasContext.fillRect(0, 0, 
                        canvas.width  = this.iframeContent.c.width, 
                        canvas.height = this.iframeContent.c.height),
                        canvasContext.drawImage(this.iframeContent.c, 0, 0),
                    link.href = canvas.toDataURL('image/jpeg'),
                    link.download = 'OS13k_Image_' + program.name);
            } catch(e) {} // ignore screenshot errors
        }

        // get elements by id
        this.codeSize = this.shadowRoot.getElementById('Z');
        this.liveEdit = this.shadowRoot.getElementById('L'); 
        this.allowSleep = this.shadowRoot.getElementById('P'); 
        nameInput.value = program.name; 
        iconInput.value = program.icon;
        widthInput.value = program.width; 
        heightInput.value = program.height;

        // set new icon and name when changed
        iconInput.oninput =
        nameInput.oninput =
        this.liveEdit.oninput =e=>
        {
            program.SetName(OS13k.StripHTML(iconInput.value), nameInput.value);
            program.Save();
            SetName();
            this.taskbarIcon.SetName();
        }

        // size options
        widthInput.onchange =
        heightInput.onchange =e=>
        {
            program.width = widthInput.value = OS13k.Clamp(widthInput.value, 99, defaultWidth);
            program.height = heightInput.value = OS13k.Clamp(heightInput.value, 99, program.width*2);

            // update to new size and clamp to desktop
            this.Resize(1);
            this.SetActive(1, 1);
        }

        // allow sleep button
        this.allowSleep.oninput =e=> this.Reload(1, program.Save());

        // resize window size to fit inner width while preserving aspect
        const width = program.resize ? 
            Math.min(program.width*(program.info.scale||1), innerWidth-6) :
            program.width;
            
        // set window width, height, and scale while preserving aspect ratio
        this.style.width                = width;
        this.iframeWrapper.style.height = width * program.height / program.width;
        this.scale = width / program.width;
        
        // announce game when first opened
        OS13k.Speak(program.name);
        
        // update loading and create iframe
        this.CreateFrame(loading += !finishedStartup);
    }
    
    WriteToFrame(code)
    {
        // open iframe to write code
        this.iframeContent.document.open();

        // set on error now to catch errors on load
        this.iframeContent.onerror = (message, source, lineno, colno, e)=>this.SetErrorText(e);
        !this.program.userProgram || allCodeIsSafe ? this.iframeContent.document.write(code) : 0;
        this.iframeContent.document.close();
    }

    SetErrorText(text)
    {
        this.errorText.value = text;
        this.errorText.style.display = text ? '' : 'none';
        return true;
    }
    
    CreateFrame()
    {
        // wait for frame to load
        const loadFrame = ()=>
        {
            // get type of user code, html, shadertoy, or dweet
            program.userProgram && (program.info.code.trim()[0] != '<' ?
                program.isDweet = !( program.isShader = program.info.code.search(/void\s+mainImage/) >= 0) :
                program.isDweet = program.isShader = 0);
            const hasExtension = program.isDweet || program.isShader;

            // check if code is safe to execute
            const codeIsSafe = !this.program.userProgram || allCodeIsSafe;

            // only dweets and shadertoys can do screenshots
            this.screenshot.disabled = !hasExtension || !codeIsSafe;

            // show error messages from user code
            program.userProgram && (iframeContent.onerror = (message, source, lineno, colno, e)=>this.SetErrorText(e))

            // get iframe content and document (will fail if cross site)       
            const iframeDocument = iframeContent.document;
            const iframeText = program.userProgram ? program.info.code :
                program.help || (hasExtension ? iframeDocument.body.innerText : iframeDocument.body.innerHTML);
            
            // set code/help display if not user program
            program.userProgram || (this.codeText.value = iframeText);

            // pass OS13k constants to iframe
            iframeContent.OS13k = OS13k;
            iframeContent.OS13kWindow = this;
            iframeContent.zzfx = zzfx;
            iframeContent.zzfxG = zzfxG;

            // set to grey if code is not safe
            codeIsSafe || (iframeDocument.body.style.background = '#111');

            // check for extensions
            if (hasExtension && codeIsSafe) try
            {
                // create canvas
                this.WriteToFrame(
                    `<canvas id=c width=1920 height=1080 style=width:100%;background:${
                    program.isShader ?
                    '#000' : '#fff' }>`);

                // set body style
                iframeDocument.body.style =
                    'background:#111;' +
                    'overflow:hidden;' +
                    'margin:0;' +
                    'display:flex;' +
                    'align-items:center';
                    
                // loop protection for user dweets
                const code = program.userProgram && !program.isShader? 
                    'OS13kL=0;' +
                    iframeText.replace(
                        /(for\s*\((?!\s+of\s+)(?!\s+in\s+)[^;]*;[^;]*;|while\s*\()\s*(\S)/g, (a, b, c)=> b && c ? b +
                        `++OS13kL>1e5&&(u=e=>{throw'Timed out!'})()` +
                        (c == ')' ? '' : ',') + c : a ) : iframeText;

                // show error messages from user code (must be set again here because it got wiped out)
                iframeContent.onerror = (message, source, lineno, colno, e)=>this.SetErrorText(e);

                // create dweet or shader program
                iframeContent.eval(
                    'frame=0;' +
                    (program.isShader ? // preserve buffer for user programs for screenshot
                        `x=c.getContext('webgl2',${program.userProgram ? '{preserveDrawingBuffer:true}' : ''});` +
                        'onmousemove=e=>e.buttons&&(X=e.x,Y=c.height-e.y);' +
                        'onmousedown=e=>(X=Z=e.x,Y=W=c.height-e.y);' +
                        'onmouseup=e=>Z=W=0;' +
                        's=parent.OS13k.CreateShader(c,`' + code + '`);' +
                        'u=t=>(' +
                        'c.width=innerWidth,' +
                        'c.height=innerHeight,' +
                        'parent.OS13k.RenderShader(c,s,t,frame++,X,Y,Z,W));' +
                        'OS13k_=t=>requestAnimationFrame(OS13k_,' +
                            (program.awake || program.info.allowSleep == 0? '' : 
                                't<1e3|parent.document.activeElement==OS13kWindow&&') +
                            'u(t/1e3));' +
                            'OS13k_(X=Y=Z=W=0)'
                        :
                        'x=c.getContext`2d`;' +
                        'S=Math.sin;' +
                        'C=Math.cos;' +
                        'T=Math.tan;' +
                        'OS13k=parent.OS13k;' +
                        'zzfx=parent.zzfx;' +
                        'R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;' +
                        'u=t=>{' + code + '\n};' +

                        // update, limit framerate and fix time glitches
                        'OS13k_=t=>(requestAnimationFrame(OS13k_),' +
                            (program.awake || program.info.allowSleep == 0? '' : 
                                't<1e3|parent.document.activeElement==OS13kWindow&&') +
                            't>OS13kF-2&&'+
                            'u(((t=frame++/60)*60|0==frame-1)&&t>0?t+1e-6:t, OS13kF=Math.max(OS13kF+1000/60,t)));' +
                            'OS13k_(OS13kF=0)'));
            }
            catch (e)
            {
                // set error text and throw error if not user code
                this.SetErrorText(e && e.message ? e.message : e);
                if (!program.userProgram) throw e;
            }
            
            // mouse down on iframe to load unsafe code, and call normal mousedown
            codeIsSafe || (iframeContent.onmousedown = e=>(this.Reload(allCodeIsSafe = 1), onmousedown(e)));
            
            // prevent iframes context menu and drop events
            iframeContent.ondrop = iframeContent.ondragover = iframeContent.oncontextmenu =()=>false;
            
            // add taskbar icon if it doesnt exist and set active
            this.taskbarIcon || (this.taskbarIcon = new OS13kTaskbarIcon(program, this)).SetActive();

            // make visible
            this.style.visibility = this.iframe.style.visibility = 'visible';
            
            // update loading
            loading = loading && --loading
            
            // update startup routine
            OS13kSystem.UpdateStartup();

            // listen for reload from iframe, prevent infnite recursion
            program.userProgram && (iframe.onload = ()=> reloadCount++ && this.Reload(1, 0));

            // release grab window since this one will be in front
            grabWindow && onmouseup();
        }
        
        // remove old iframe if it exists
        this.iframe && this.iframeWrapper.removeChild(this.iframe);

        // create iframe
        const iframe = this.iframe = this.iframeWrapper.appendChild(document.createElement('iframe')); 
        const iframeContent = this.iframeContent = iframe.contentWindow;
        const program = this.program;
        let reloadCount = 0;
        iframe.id = 'frame';
        
        // load src and force pages to be refreshed
        if (program.userProgram)
        {
            // clear error text
            this.SetErrorText();

            // allow code editing, check for alt+enter to reload
            this.codeText.onkeydown =e=> !e.altKey || e.keyCode == 13 && this.SetCode(this.codeText.value);
            this.codeText.oninput =e=> this.liveEdit.checked && this.SetCode(this.codeText.value);

            // write code to iframe and load it immediately
            loadFrame(this.WriteToFrame(program.info.code));
        }
        else
        {
            // load source
            iframe.onload = ()=> loadFrame();
            this.iframe.src = program.src + '?v55';
        }
    }
        
    SetCode(code)
    {
        // set code when changed
        this.program.info.code = code;
        this.codeSize.innerHTML = code.length;
        this.program.Save();

        // mark code as safe and reset iframe
        this.CreateFrame(allCodeIsSafe = 1);
    }
    
    Open(target, x, y)
    {
        // set active if not copy button
        target.id != 'C' && this.SetActive();
        
        // set grab window if name is target
        if (target == this.name)
        {
            // set grab window and play sound
            grabWindow = this;
            OS13kSystem.Sound(soundGrabStart)
            
            // use grabbing cursor
            document.body.style.cursor = 'grabbing';
            
            // prevent anything from getting focus white grabbing
            desktop.style.pointerEvents = 'none';

            // save grab offset
            grabOffsetX = x - parseInt(this.style.left);
            grabOffsetY = y - parseInt(this.style.top);
            return;
        }
        
        // check for title bar buttons
        target.id == 'Full'        && this.FullScreen();
        target.id == 'Reload'      && this.Reload();
        target.id == 'Close'       && this.Close();
        target.id == 'Shrink'      && this.Resize(this.scale - .2, soundShrink);
        target.id == 'Grow'        && this.Resize(this.scale + .2, soundGrow);
        (target.id == 'Help' | target.id == 'Code') && this.ShowCode();
    }
    
    Resize(scale, sound)
    {
        // get new width and fix window offset
        const wNew = OS13k.Clamp(this.program.width * scale, 170, 1920);
        this.style.left = parseInt(this.style.left) + parseInt(this.style.width) - wNew;
        
        // set new size
        this.style.width = wNew;
        this.iframeWrapper.style.height = this.program.height * (this.scale = wNew / this.program.width);
    
        // update program info and play sound
        this.program.Save();
        sound && OS13kSystem.Sound(sound);
    }
    
    SetActive(active=1, clamp)
    {
        // close menus when window is set active
        OS13kSystem.CloseMenus();
        
        // set style, dim non active windows
        this.className = active? 'activeWindow' : '';
        this.titlebar.className = 'titlebar titlebar' + 
            (active? 'Active' : '') + 
            (this.program.sticky ? 'Sticky' : this.program.userProgram ? 'User' : '');
        this.iframeWrapper.style.filter = active || this.program.awake ? 
            '' : 'saturate(.7)brightness(.7';

        // check if active
        if (!active) return;
        
        // save start program if finished startup and not sticky
        finishedStartup && !this.program.sticky && OS13k.Save(startProgramId = this.program.id);

        // set focus to iframe using timeout to make it work cross browser
        loading || this.program.stopFocus || document.activeElement != this && setTimeout(e=>this.iframeContent?.focus(lastActiveFrame = this.iframe));

        // clamp window to screen
        const rect = this.getBoundingClientRect();
        clamp && (
            this.style.left = OS13k.Clamp(rect.x, 0, innerWidth - rect.width,
            this.style.top = OS13k.Clamp(rect.y, taskbarHeight, 
                Math.max(taskbarHeight, innerHeight - rect.height))));

        if (activeWindow != this)
        {
            // deactivate old window and set this one active and play sound
            activeWindow && activeWindow.SetActive(0);
            activeWindow = this;
            OS13kSystem.Sound(this.activeCount++ ? soundActive : soundOpen);

            // move z to top
            this.style.zIndex = ++topZ;

            // show menu buttons
            const SetButtonVisibility = (button, visible)=>button.style.display = visible ? '' : 'none';
            SetButtonVisibility(buttonFullScreen, this.program.full);
            SetButtonVisibility(buttonCode,       this.program.code);
            SetButtonVisibility(buttonHelp,       this.program.help);
            SetButtonVisibility(buttonReload,     this.program.reload);
            SetButtonVisibility(buttonResetSize,  this.program.resize);

            // set taskbar icon active if it exists
            this.taskbarIcon?.SetActive();
        }
    }
    
    FullScreen()
    {
        // check if full screen allowed
        if (!this.program.full) return;

        // reload code if it wasnt safe yet and set it is safe and play sound
        allCodeIsSafe || this.Reload(allCodeIsSafe = 1);
        OS13kSystem.Sound(soundFullScreen);
        
        // set full screen
        this.iframeWrapper.webkitRequestFullScreen &&
            this.iframeWrapper.webkitRequestFullScreen();
        this.iframeWrapper.mozRequestFullScreen &&
            this.iframeWrapper.mozRequestFullScreen();
        
        OS13k.Trophy('OS13k','🕹️','Pro Gamer','Went Full Screen');
    }
    
    ShowCode(silent)
    {
        // toggle showing code and play sound
        this.codeDisplay.style.display = (this.showCode = !this.showCode) ? 'inline' : '';
        silent || OS13kSystem.Sound(this.program.help ? soundHelp : soundCode);
        
        // set active and clamp
        activeWindow.SetActive(1, 1);

        this.program.help || OS13k.Trophy('OS13k','👨‍💻','Hacker','Viewed Code');
    }
    
    Reload(silent, clamp=1)
    {
        // update program info and play sound
        this.program.userProgram && (this.program.info.code = this.codeText.value);
        this.program.Save();
        silent || OS13kSystem.Sound(soundReload);
        
        // set active and clamp
        activeWindow.SetActive(1, clamp);
        
        // reload program or reload iframe and set invisible
        this.iframeContent &&
            this.iframeContent.OS13kReload ?
            this.iframeContent.OS13kReload() :
            this.program.userProgram ?
                this.SetCode(this.program.info.code) :
            this.CreateFrame(this.iframe.style.visibility = '');
    }
    
    Close()
    {
        // remove start program if closed and play sound
        this.program.id == startProgramId && (startProgramId = '');
        OS13kSystem.Sound(soundClose);
            
        // save info and set closed
        this.program.Save(0);
        
        // invalidate window after info is saved
        this.program.window = 0;
        
        // remove taskbar icon and self
        this.taskbarIcon && this.taskbarIcon.remove();
        this.remove();
    }
} // OS13kWindow
customElements.define('w-', OS13kWindow);

///////////////////////////////////////////////////////////////////////////////
// OS13kTaskbarIcon - icon on taskbar that can be used as shortcut

class OS13kTaskbarIcon extends HTMLElement
{
	constructor(program, windowOrMenu)
    {
        super();
        
        // create icon
        this.className = 'taskbarIcon';
        this.program = program;
        this.menu = this.windowOrMenu = windowOrMenu;
        this.SetName();
        
        // add to taskbar
        taskbarSpace.before(this);
    }

    SetName()
    {
        this.innerHTML = '<div style=pointer-events:none>' + (this.program.icon || '💠');
        this.title = this.program.name;
    }
    
    Open() { this.SetActive(); }
    
    SetActive(active=1)
    {
        // set window active and clamp
        active && this.windowOrMenu.SetActive(1, 1);
    
        // load icon cant be active taskbar item
        if (this == loadIcon)
            return OS13kSystem.Sound(soundMenu, .5);
        
        // set active style
        this.className = 'taskbarIcon ' + (active ? 'taskbarIconActive' : '');
        
        // if active, unselect old taskbar icon and set this active
        active && activeTaskbarIcon != this && (activeTaskbarIcon?.SetActive(0), activeTaskbarIcon = this);
    }
    
} // OS13kTaskbarIcon
customElements.define('i-', OS13kTaskbarIcon);

///////////////////////////////////////////////////////////////////////////////
// OS13kTrayIcon - icon on taskbar tray for OS shortcuts

class OS13kTrayIcon extends HTMLElement
{
	constructor()
    {
		super();
        
        // create tray icon and add it
        this.className = 'trayIcon';
        tray.appendChild(this);
    }
    
    SetProgram(program)
    {
        // set program, title, and icon
        this.program = program;
        this.title = program.name;
        
        // create span for icon to add analyser
        const icon = this.appendChild(document.createElement('span'));
        icon.innerHTML = program.icon;
        icon.style.pointerEvents = 'none';
    }
    
    Open() { this.program ? this.program.Toggle() : this.functionCall(); }
} // OS13kTrayIcon
customElements.define('t-', OS13kTrayIcon);

///////////////////////////////////////////////////////////////////////////////
// Mouse Input

{
onmousedown = e=>
{
    // set there has been user input
    hadInput = 1;
    
    // check if load icon is target while programs menu was visible
    if (e.target == loadIcon && e.target.windowOrMenu.style.visibility)
    {
        // close menus because they were open
        OS13kSystem.CloseMenus();
        
        // reactivate active window
        activeWindow?.SetActive();
        
        // prevent main document from taking focus
        return false;
    }
    
    // close menus on mouse down
    OS13kSystem.CloseMenus();

    // reset program menu position
    programsMenu.style.left = 0;
    programsMenu.style.top = taskbarHeight;

    // prevent stuck grab (from tabbing to another window while grabbing)
    if (grabWindow) return onmouseup(e);
    
    // get orignal target
    const originalTarget = e.originalTarget || e.path[0];
    
    // check if not left mouse button
    if (e.button)
    {
        // dont allow right click on buttons
        if (originalTarget.localName == 'button')
            return false;

        // check for right mouse button
        if (e.button & 2)
        {
            // set target active, use load icon if no valid target
            (e.target.SetActive ? e.target : loadIcon).SetActive();

            // get which menu to open
            const targetMenu = e.target.menu ? (OS13kSystem.Sound(soundMenu, .5), menu) : programsMenu;

            // show context menu
            targetMenu.style.left = e.x;
            targetMenu.style.top  = e.y;
            targetMenu.style.visibility = 'visible';
        }
    
        // allow main document to take focus
        return;
    }

    // open or reactivate window if no valid target
    e.target.Open ? e.target.Open(originalTarget, e.x, e.y) : activeWindow?.SetActive();
    
    // allow event to contiue only if input
    return e.target == loadIcon || /input|textarea/.test(originalTarget.localName);
}

onmousemove = e=>
{
    // update grab position
    grabWindow ? grabWindow.style.left = e.x - grabOffsetX : 0;
    grabWindow ? grabWindow.style.top = e.y - grabOffsetY : 0;
    
    // handle mouse move
    e.target.Move?.();
}

onmouseup = ()=>
    // set grab window active, no clamp, and set cursor to default, unset grab
    grabWindow && (grabWindow.program.Save(),
    OS13kSystem.Sound(soundGrabEnd),
    grabWindow.SetActive(1, 0),
        document.body.style.cursor = desktop.style.pointerEvents = grabWindow = '');

// prevent default right click context menu
oncontextmenu = ()=>false;

} // mouse input

///////////////////////////////////////////////////////////////////////////////
// Drag and Drop

// prevent default drop events
ondragover = ()=>false;

// allow drag and drop code into editor
ondrop =e=>
{
    if (e.target.program.userProgram && (e.originalTarget || e.path[0]).id == 'codeText')
    {
        // read file, set code, and set active
        const reader = new FileReader();
        reader.onload = f=>e.target.SetActive(1, 0, e.target.SetCode(f.target.result));
        reader.readAsText(e.dataTransfer.files[0], 'utf-8'); 
    }
    return false;
}

///////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth

// play a zzfx sound
var zzfx = (...parameters)=>OS13k.PlaySamples(zzfxG(...parameters)),

 // generate zzfx samples
zzfxG = (volume = 1, randomness = .05, frequency = 220, attack = 0, sustain = 0, release = .1, shape = 0, shapeCurve = 1, slide = 0, deltaSlide = 0, pitchJump = 0, pitchJumpTime = 0, repeatTime = 0, noise = 0, modulation = 0, bitCrush = 0, delay = 0, sustainVolume = 1, decay = 0, sampleRate = defaultSampleRate, b = [])=>
{
    attack = 99 + attack * sampleRate;
    sustain *= sampleRate;
    release *= sampleRate;
    decay *= sampleRate;
    delay *= sampleRate;
    
    for(
        // init parameters and helper functions
        let PI2 = Math.PI*2,
        random =r=> 1 + r*2*Math.random() - r,
        sign =v=> v>0? 1 : -1,
        length = attack + decay + sustain + release + delay,
        startSlide = slide *= 500 * PI2 / sampleRate**2,
        startFrequency = frequency *= random(randomness) * PI2 / sampleRate,
        modPhase = sign(modulation) * PI2/4,
        t=0, tm=0, i=0, j=1, r=0, c=0, s=0;
    
        // loop and generate waveform
        i < length; b[i++] = s)
    {
        if (++c>bitCrush*100)                            // bit crush
        {
            c = 0;                                       // reset bit crush
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation * PI2 / sampleRate - modPhase); // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
                Math.sin((s%PI2)**3) :                   // 4 noise
                Math.max(Math.min(Math.tan(s), 1), -1):  // 3 tan
                1-(2*s/PI2%2+2)%2:                       // 2 saw
                1-4*Math.abs(Math.round(s/PI2)-s/PI2):   // 1 triangle
                Math.sin(s);                             // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * (                              // envelope
                i < attack ? i/attack :                  // attack
                i < attack + decay ?                     // decay
                1-((i-attack)/decay)*(1-sustainVolume) : // decay falloff
                i < attack + decay + sustain ?           // sustain
                sustainVolume :                          // sustain volume
                i < length - delay ?                     // release
                (length - i - delay)/release *           // release falloff
                sustainVolume :                          // release volume
                0);                                      // post release

            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i - delay|0]/2) : s;                   // sample delay
        }

        t += random(noise);                          // noise
        tm += random(noise);                         // modulation noise
        frequency += slide += deltaSlide             // frequency slide
            * 500 * PI2 / sampleRate**3;             // apply sample rate

        if (j && ++j > pitchJumpTime * sampleRate)   // pitch jump
        {
            frequency += pitchJump                   // apply pitch jump
                * PI2 / sampleRate;                  // apply sample rate
            startFrequency += pitchJump              // also apply to start
                * PI2 / sampleRate;                  // apply sample rate
            j = 0;                                   // reset pitch jump time
        }

        if (repeatTime && ++r > repeatTime* sampleRate) // repeat
        {
            frequency = startFrequency;               // reset frequency
            slide = startSlide;                       // reset slide
            r = 1;                                    // reset repeat time
            j = j || 1;                               // reset pitch jump time
        }
    }
    
    return b;
},

///////////////////////////////////////////////////////////////////////////////
//! ZzFXM (v1.0.0) | (C) Keith Clark | MIT | https://github.com/keithclark/ZzFXM

zzfxM = (instruments, patterns, sequence, speed = 6, panning) => {
  let SAMPLE_RATE = defaultSampleRate;
  let BPM = 125;                             // beats per min - always 125
  let ticksPerSecond = 1000 / (2500 / BPM);
  let tickRowSize = SAMPLE_RATE / (ticksPerSecond / speed) | 0;
  let bufferStart = 0
  let bufferPos;
  let bufferOffset;
  let sample;
  let sampleCache = {};
  let sampleCacheKey;
  let sampleByte;
  let sampleOffset;
  let noteIndex;
  let pan;
  let attenuation;
  let instrument;
  let instrumentParams;
  let period;
  let leftChannelBuffer=[];
  let rightChannelBuffer=[];

  sequence.map(patternIndex => {

    // Walk over each channel of the pattern.
    patterns[patternIndex].map((channel, channelIndex) => {

      // for each channel we need to reset the buffer offset so we can layer
      // sample data.
      bufferOffset = bufferStart;

      // Determin the panning value for this channel. If no panning was provided
      // we fallback to alternating each song channel between the left and right
      // speakers (even channel indexes will come from the left speaker, odd
      // from the right speaker)
      pan = panning ? .5 + (panning[channelIndex] || 0) / 2 : channelIndex & 1;

      // Read the channel data.
      for (noteIndex = 0; noteIndex < channel.length; bufferOffset += tickRowSize) {

        // If there's a new instrument, set it.
        instrument = channel[noteIndex++] || instrument;

        // If we have a period then we need to play a note using the current
        // instrument.
        period = channel[noteIndex++];
        if (period) {
          // Reset the attenuation and sample buffer offset so we can play a new
          // note.
          attenuation = sampleOffset = 0;

          // Create a unique key for this sample (this will coerced to a string)
          sampleCacheKey = [period,instrument];

          // If we haven't done so already, build and cache the ZzFX sample for
          // the current period and instrument. Without caching the browser will
          // will hang.
          if (!sampleCache[sampleCacheKey]) {
            instrumentParams = [...instruments[instrument - 1]];
            instrumentParams[2] *= 2 ** ((period - 12) / 12);
            sampleCache[sampleCacheKey] = zzfxG(...instrumentParams);
          }

          sample = sampleCache[sampleCacheKey];
        }

        // Update the channel attenuation value. We'll use this to control the
        // volume when rendering the sample slice for this row.
        attenuation = (channel[noteIndex++] / 64) || attenuation;

        // Fill the left and right audio buffers with data for this channel.
        // If we have sample data (a new note or the remaining sample data from
        // the previous row) then we attenuate it for the left channel using the
        // channel panning value and again for the right channel. The values are
        // then merged with the values already in the buffer. If the buffer is
        // empty we need to prefill it with `0` values for periods of slience to
        // prevent the clicking and popping noises caused by `undefined` values
        // in some browsers.
        for (bufferPos = bufferOffset; bufferPos < bufferOffset + tickRowSize; bufferPos++) {
          sampleByte = sample && (sample[sampleOffset++] * (1 - attenuation)) || 0;
          leftChannelBuffer[bufferPos] = (leftChannelBuffer[bufferPos] || 0) + sampleByte * (1 - pan);
          rightChannelBuffer[bufferPos] = (rightChannelBuffer[bufferPos] || 0) + sampleByte * pan;
        }
      }

    });

    bufferStart = bufferPos;
  });

  return [leftChannelBuffer, rightChannelBuffer];
}

///////////////////////////////////////////////////////////////////////////////
// Start OS13k!

OS13kSystem.Start();

///////////////////////////////////////////////////////////////////////////////
// Mobile Support OPTIONAL

// save if user was touching
let wasTouching;
    
if (typeof ontouchstart != 'undefined')
{
    // remove hovers, they get stuck on mobile
    const RemoveHovers=e=>
    {
        [...e.styleSheets].map(sheet=>{
        for(let i = sheet.rules.length; i--; )
            sheet.rules[i].selectorText &&
            sheet.rules[i].selectorText.match('hover') &&
            sheet.deleteRule(i)});
    }
    RemoveHovers(document);
                
    // handle touch event
    const ProcessTouch=e=>
    {
        // check if touching
        const touching = e.touches.length;
        if (touching)
        {
            // set event pos
            e.x = e.touches[0].clientX;
            e.y = e.touches[0].clientY;

            // pass event to mousemove and give focus to main window
            onmousemove(e);
        }

        // pass event to mouse down, prevent closing folders
        touching & !wasTouching & !e.target.folder && e.target != loadIcon && onmousedown(e);

        // pass event to mouse up
        !touching & wasTouching && onmouseup(e);

        // set was touching
        wasTouching = touching;
        
        // remove hovers from active window
        activeWindow && RemoveHovers(activeWindow.shadowRoot);
        
        // prevent default if not edit area
        const originalTarget = e.originalTarget || e.path[0];
        
        // allow event to contiue only if input
        return !e.cancelable || e.target == loadIcon || /input|textarea|button/.test(originalTarget.localName);
    }
    
    // set touch events
    ontouchstart = ontouchmove = ontouchend = ontouchcancel = ProcessTouch;
};

</script>