<head>
<title>OS13k - A tiny pseudo operating system for JS13k</title>
<meta charset=utf-8>
<style>
*
{
    font-family:arial;
}
body
{
    overflow:hidden;
    background:linear-gradient(#223,#322);
}
*:active
{
    cursor:grabbing;
}
.title
{
    font-size:300;
    font-family:impact;
    color:#0002;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    user-select:none;
    pointer-events:none;
}
</style>
<template id=templateIcon>
<style>
:host
{
    position:absolute;
    display:flex;
    align-items:center;
    flex-direction:column;
    user-select:none;
    pointer-events:auto;
    cursor:grab;
}
.icon
{
    width:64;
    height:64;
    font-size:42;
    background:linear-gradient(#fff,#999);
    border-radius:9px;
    box-shadow:4px 4px 5px;
    overflow:hidden;
    white-space:nowrap;
    pointer-events:none;
    display:flex;
    align-items:center;
    justify-content:center;
}
.name
{
    position:absolute;
    top:70;
    text-align:center;
    font-size:18;
    color:#FFF;
    text-shadow:1px 1px 5px #000;
}
</style>
</template>
<template id=templateWindow>
<style>
:host
{
    position:absolute;
    user-select:none;
    display:flex;
    flex-direction:column;
    box-shadow:9px 9px 9px;
    background:#000;
    border:2px solid;
    overflow:hidden;
    display:block;
}
.frame
{
    position:relative;
    width:100%;
    height:100%;
    border:none;
    background:#fff;
    overflow:hidden;
}
.folder
{
    background:#222;
}
.titleBar
{
    height:44;
    font-size:30;
    display:flex;
    align-items:center;
    white-space:nowrap;
}
.name
{
    width:100%;
    cursor:grab;
}
.full         { font-size:30; height:100%; }
.close        { font-size:43; height:100%; }
.full:hover   { background:#fff; }
.close:hover  { background:#f00; }
</style>
</template>
</head>
<body>
<span id=os13kDesktop></span>
<span class=title>OS13k</span>
<script>

'use strict';

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs OS13k, OS13kIcon, OS13kWindow, zzfx, zzfxV
// @js_externs _OS13k.Medal, _OS13k.Medal, _OS13k.GetKeyDirection
// @js_externs _OS13k.PlaySamples, _OS13k.CreateShader, _OS13k.RenderShader
// @js_externs _OS13k.Random, _OS13k.randomSeed, _OS13k.CreateDweet
// @js_externs _OS13k.Clamp, _OS13k.Percent, _OS13k.Lerp
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==

/////////////////////////////////////////////////////////////////////////////
// OS13k Desktop

const desktopLayout = 
[
{name:'Help', icon:'‚ùì', src:'help.html?6', open:1, width:380, height:340},
{name:'System', icon:'‚öôÔ∏è', folder:
[
    {name:'Test', icon:'üòÑ', src:'system/test.html?3', hideWhenClosed:1},
]},
{name:'Games', icon:'üéÆ', folder:
[
    {name:'Lava Rush', icon:'üåã', author:'Jeremy Burns', src:'games/lavaRush.html?2', width:640, height:400, background:'#000'},
    {name:'Sn1ke', icon:'üëÄ', src:'games/sn1ke.html', author:'Codegolf Team', width:450, height:330, hideWhenClosed:1},
    {name:'Tetris', icon:'üÜÉ', author:'Veubeke', src:'games/tetris.html', width:340, height:430},
    {name:`Queen's Gambit`, icon:'<span style=color:#f0f>‚ôõ</span>', src:'games/queensGambit.html?1', width:1290, height:720},
    {name:'Free Cell', icon:'‚ô†Ô∏è', src:'games/freeCell.html', width:800, height:1e3, hideWhenClosed:1},
    {name:'Digit Dilemma', icon:'<span style=font-family:monospace>‚òª</span>', src:'games/digitDilemma.html'},
    {name:'Hue Jumper', icon:'üå≤', src:'games/hueJumper.html', width:1290, height:720},
]},
{name:'Utilities', icon:'üîß', folder:
[
    {name:'Photo Booth', icon:'üì∏', src:'utilities/photoBooth.html', width:1380, height:600},
    {name:'Unicode Toys', icon:'ùñÄ', author:'Xem', src:'utilities/unicodeToys.html', width:500, height:800},
    {name:'Mini Shadertoy', icon:'ùì¢', src:'utilities/miniShadertoy.html', width:340, height:400},
]},
{name:'Toys', icon:'ü§ñ', folder:
[
    {name:'ZzFX Sounds', icon:'ùêôùêô', src:'toys/zzfxSoundBoard.html'},
    {name:'Yin Yangs', icon:'‚òØÔ∏è', src:'toys/infiniteYinYangs.html?1'},
    {name:'Meta OS13k', icon:'ùêéùêí', src:'index.html'},
]},
{name:'Dweets', icon:'<b>III</b>', folder:
[
    {name:'Black Hole', icon:'üåå', src:'dweets/blackHole.html'},
    {name:'Mandelbrot Nebula', icon:'üåü', src:'dweets/mandelbrotNebula.html'},
    {name:'Bogus Roads', icon:'üõ£Ô∏è', src:'dweets/bogusRoads.html'},
    {name:'Automatic Breakout', icon:'‚óè', src:'dweets/breakout.html'},
    {name:'Underwater Cavern', icon:'üåä', author:'Pavel', src:'dweets/underwaterCavern.html'},
    {name:'City Traffic', icon:'üöå', author:'Tomxor', src:'dweets/cityTraffic.html'},
    {name:'Train Set', icon:'üöÇ', author:'jylikangas', src:'dweets/trainSet.html'},
]},
{name:'Music', icon:'üé∂', folder:
[
    {name:'Min Bytes', icon:'<span style=color:#f00>ùìú</span>', width:500, height:500, src:'music/minBytes.html?4'},
]},
{name:'Favorites', folder:[]},
];

/////////////////////////////////////////////////////////////////////////////
// OS13k System

class _OS13k
{
    constructor()
    {
        // init web audio
        this.audioContext = new (AudioContext || webkitAudioContext);
        this.audioContext._createBufferSource = this.audioContext.createBufferSource;
        this.audioContext.createBufferSource =
        (s = this.audioContext._createBufferSource())=>
        (
            s.start = s.start || (t => this.audioContext.noteOn (t)),
            s.stop  = s.stop  || (t => this.audioContext.noteOff(t)),
            s
        );
        
        // startup os13k
        this.randomSeed = Date.now();
        this.InitDesktop();
        setInterval(this.Update, 99);
    }
    
    InitDesktop()
    {
        // add icons to desktop
        let X = iconGridSizeX/4 - iconGridSizeX;
        const AddIcon=p=>
        {
            p.x = X+=iconGridSizeX;
            p.y = iconGridSizeX/4; 
            const icon = new OS13kIcon(p); 
            os13kDesktop.appendChild(icon); 
            p.open && icon.Open();
            return icon;
        }
        for (const i of desktopLayout)
            AddIcon(i);
    }
    
    Update()
    {
        // listen for change in active element
        // this happens when clicking on an iframe
        const activeElement = document.activeElement;
        if (this.lastActiveElement != activeElement)
        {
            if (activeElement.localName == 'os13k-window')
                activeElement.Focus();
            this.lastActiveElement = activeElement;
        }
    }
    
    GetKeyDirection(keyCode)
    {
        // get direction from wasd or arrow keys
        let x = 0;
        let y = 0;
        if (keyCode == 87 || keyCode == 38) // up
            y += 1;
        if (keyCode == 83 || keyCode == 40) // down
            y -= 1;
        if (keyCode == 68 || keyCode == 39) // right
            x += 1;
        if (keyCode == 65 || keyCode == 38) // left
            x -= 1;
        return {x, y}
    }
    
    
    Medal(gameName, medalName='', difficulty=0)
    {
        // todo: show popup and unlock medal
    }
    
    PlaySoundSeed(seed)
    {
        // todo: play seeded sound
    }
    
    PlaySamples(samples, sampleRate=44100)
    {
        // play raw audio sample data
        const buffer = this.audioContext.createBuffer(1, samples.length, sampleRate);
        const source = this.audioContext.createBufferSource();
        buffer.getChannelData(0).set(samples);
        source.buffer = buffer;
        source.connect(this.audioContext.destination);
        source.start();
        return source;
    }
    
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl');

        // create simple pass through vertex shader
        const vertexShader = x.createShader(x.VERTEX_SHADER);
        x.shaderSource(vertexShader,'attribute vec4 p;void main(){gl_Position=p;}');
        x.compileShader(vertexShader);
        
        // create vertex buffer that is a giant triangle to cover the viewport
        const vertexBuffer = x.ARRAY_BUFFER;
        x.bindBuffer(vertexBuffer,x.createBuffer());
        x.bufferData(vertexBuffer,new Int8Array([-3,1,1,-3,1,1]),x.STATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0,2,x.BYTE,0,0,0); // 2D vertex
        
        // check vertex shader for errors
        if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
            return console.log(x.getShaderInfoLog(vertexShader));
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(x.FRAGMENT_SHADER)
        const shaderProgramCode = 
            'precision mediump float;'
            + 'uniform float iTime;\n'
            + 'uniform vec3 iResolution;'
            + code
            + '\nvoid main()'
            + '{mainImage(gl_FragColor,gl_FragCoord.xy);gl_FragColor.a=1.;}'
        x.shaderSource(pixelShader, shaderProgramCode)
        x.compileShader(pixelShader);

        // check pixel shader for errors
        if (!x.getShaderParameter(pixelShader, x.COMPILE_STATUS))
            return console.log(x.getShaderInfoLog(pixelShader));

        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    RenderShader(canvas, shaderProgram, time=0)
    {
        // get webgl context
        const x = canvas.getContext('webgl');
        
        // set uniforms
        x.uniform1f(x.getUniformLocation(shaderProgram,'iTime'), time);
        x.uniform3f(x.getUniformLocation(shaderProgram,'iResolution'),
            canvas.width, canvas.height, 0);
        
        // render shader
        x.viewport(0, 0, canvas.width, canvas.height);
        return x.drawArrays(x.TRIANGLE_FAN, 0, 3);
    }
    
    CreateDweet(document, code)
    {
        // set up document for dweet
        document.body.innerHTML = `<canvas id=c width=1920 height=1080 style=background:#FFF;width:100%>`;
        document.body.style = `background:#000;margin:0;overflow:hidden`;
        
        // create dweet
        document.defaultView.eval('function u(t){' + code + '}x=c.getContext`2d`;frame=0;S=Math.sin;C=Math.cos;T=Math.tan;R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;loop=()=>requestAnimationFrame(loop,document.hasFocus()&&u((60*(frame++/60)-frame-1|0?frame-1:frame)/60),c.style.width=1920/1080>innerWidth/innerHeight?innerWidth:innerHeight*1920/1080);loop()');
    }
    
    // math functions
    Clamp(a, min=0, max=1) { return Math.min(Math.max(a, min),max); }
    Percent(v, a, b)       { return b-a? this.Clamp((v-a)/(b-a), 0, 1) : 0; }
    Lerp(p, a, b)          { return a + this.Clamp(p, 0, 1) * (b-a); }
    Random(max=1, min=0)
    {
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= this.randomSeed << 13;
        this.randomSeed ^= this.randomSeed >> 17;
        this.randomSeed ^= this.randomSeed << 5;
        return max + (min-max) * (Math.abs(this.randomSeed) % 1e9 / 1e9);
    }
}; // _OS13k

/////////////////////////////////////////////////////////////////////////////
// OS13kIcon

const iconGridSizeX = 99;
const iconGridSizeY = 130;
let windowOpenOffset = 99;
let topIconZ = 0;

class OS13kIcon extends HTMLElement
{
	constructor({x, y, name, icon, src, width=720, height=405, author, folder, hideWhenClosed, allowMultiple, background})
    {
		super();
        
        // set defaults
        src = src || '';
        name = name || src.split('.')[0];
        icon = icon || ( folder ? 'üìÅ' : name[0]? name[0].toUpperCase() : '' );
        
        // set icon data
		this.shadow = this.attachShadow({mode: 'open'});
        this.name = name;
        this.icon = icon;
        this.src = src;
        this.windowWidth = width;
        this.windowHeight = height + 46; // add title bar height
        this.style.left = x;
        this.style.top = y;
        this.author = author;
        this.hideWhenClosed = hideWhenClosed || folder;
        this.allowMultiple = allowMultiple;
        this.folder = folder;
        this.background = background;
        
        // create shadow root
        this.shadowRoot.innerHTML = templateIcon.innerHTML
            +`<span class=icon>${ icon }</span>`
            +`<span class=name style=pointer-events:none>${ name }</span>`;
    }
    
    Open()
    {
        if (this.os13kWindow && !this.allowMultiple)
        {
            // reopen the old window
            this.os13kWindow.style.display = '';
        }
        else
        {
            // stager open positions
            windowOpenOffset += 42;
            if (windowOpenOffset > 300)
                windowOpenOffset = 99+20;

            // open the window
            this.os13kWindow = new OS13kWindow(windowOpenOffset, windowOpenOffset, this);
            os13kDesktop.appendChild(this.os13kWindow);
        }
        
        // set focus to window
        this.os13kWindow.Focus();
    }
    
    MouseDown()
    {
        // focus on icon's window if it exists
        if (this.parentElement.os13kWindow)
            this.parentElement.os13kWindow.Focus();
        else
        {
            // focus on desktop
            os13kDesktop.focus();
            activeWindow && activeWindow.SetActive(0);
        }
        
        // create move icon that is temporary copy
        const rect = this.getBoundingClientRect();
        const moveIcon = new OS13kIcon({x:rect.left, y:rect.top, name:this.name, icon:this.icon});
        moveIcon.realIcon = this;
        moveIcon.style.opacity = .5;
        moveIcon.style.zIndex = ++activeWindowZ;
        moveIcon.style.pointerEvents = 'none';
        os13kDesktop.appendChild(moveIcon);
        selected = moveIcon;
    }
    
    MouseUp(e)
    {
        // get rect before it is removed
        const rect = this.getBoundingClientRect();
        
        // get rid of this temporary move icon
        os13kDesktop.removeChild(this);
        
        // get element under mouse
        const element = document.elementFromPoint(e.x, e.y);
        if (!element)
            return;
        
        // try to move icon
        let target = os13kDesktop;
        let x = rect.left;
        let y = rect.top;
        if (element.localName == 'os13k-window')
        {
            // only allow dropping into folders
            if (!element.os13kIcon.folder)
                return;
               
            // prevent dropping on title bar
            const shadowElement = element.shadowRoot.elementFromPoint(e.x, e.y);
            if (shadowElement && shadowElement.id)
                return;
                
            // prevent folder self reference
            const DetectSelfReference=icon=>
            {
                if (icon.os13kWindow == element)
                    return 1;
                if (icon.os13kWindow && icon.os13kWindow.folder)
                    for( const c of icon.os13kWindow.folder.children)
                        if (DetectSelfReference(c))
                            return 1;
            }
            if (DetectSelfReference(this.realIcon))
                return alert("You can't put a folder in itself, silly!");
            
            // adjust position to local space of parent
            const rect = element.folder.getBoundingClientRect();
            x -= rect.left;
            y -= rect.top;
            
            // clamp icon to window so icon is not unreachable
            x = OS13k.Clamp(x, -32, rect.width-32);
            y = OS13k.Clamp(y, -32, rect.height-32-46);
            
            // put icon in folder
            target = element;
        }
        else
        {
            // clamp icon to window so icon is not unreachable
            x = OS13k.Clamp(x, -32, innerWidth-32);
            y = OS13k.Clamp(y, -32, innerHeight-32);
        }

        const targetFolder = target.folder || target;
        if (targetFolder != this.realIcon.parentElement)
        {
            // move icon if it is a different folder
            targetFolder.appendChild(this.realIcon);

            // deactivate window if dropped in desktop
            if (activeWindow && targetFolder == os13kDesktop)
                activeWindow.SetActive(0);
        }
        
        // focus on target
        target.Focus ? target.Focus() : target.focus();
            
        // set icon position
        this.realIcon.style.left = x;
        this.realIcon.style.top = y;
        this.realIcon.style.zIndex = ++topIconZ;
    }
} // OS13kIcon

customElements.define('os13k-icon', OS13kIcon);

/////////////////////////////////////////////////////////////////////////////
// OS13kWindow

let activeWindow;
let activeWindowZ = 1e7;

class OS13kWindow extends HTMLElement
{
	constructor(x, y, icon)
    {
		super();
        	
        // set window data
        this.os13kIcon = icon;
        this.style.left = x;
        this.style.top = y;
        this.style.width = icon.windowWidth;
        this.style.height = icon.windowHeight;
        
        // create shadow root
		this.shadow = this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = templateWindow.innerHTML;
        
        // create title bar
        const titleBar = this.titleBar = document.createElement('span');
        titleBar.className = 'titleBar';
        titleBar.innerHTML = '<span id=titleBar class=name>&nbsp;' 
            + icon.icon + '&nbsp;' 
            + icon.name + '&nbsp;' 
            + (icon.author? '(' +icon.author +')': '')
            + '</span>'
            + (icon.folder?'':'<span id=full class=full>&nbsp;üóñ&nbsp;</span>')
            + '<span id=close class=close>√ó</span>';
        this.shadowRoot.appendChild(titleBar);
        
        // create thin black line below title bar
        const titleBarGap = document.createElement('div');
        titleBarGap.style.height = 2;
        this.shadowRoot.appendChild(titleBarGap);
        
        if (icon.folder)
        {
            // create folder frame
            const folder = this.folder = document.createElement('div');
            folder.className = 'folder frame';
            folder.os13kWindow = this;
            this.shadowRoot.appendChild(folder);
            this.Focus();

            // add icons to folder
            let X = iconGridSizeX/4-iconGridSizeX;
            const AddIcon=p=>
            {
                p.x = X+=iconGridSizeX;
                p.y = iconGridSizeX/4; //todo: wrap icons
                folder.appendChild(new OS13kIcon(p));
            }
            for (const i of icon.folder)
                AddIcon(i);
        }
        else if (icon.src)
        {
            // create iframe
            const iframe = document.createElement('iframe');
            icon.background && (iframe.style.background = icon.background);
            iframe.className = 'frame';
            iframe.sandbox.add('allow-scripts');
            iframe.sandbox.add('allow-same-origin');
            iframe.sandbox.add('allow-popups');
            iframe.sandbox.add('allow-modals');
            iframe.sandbox.add('allow-pointer-lock');
            iframe.onload=e=>
            {
                // try to pass os13k to iframe
                const iframeContent = this.iframeContent = e.target.contentWindow;
                iframeContent.OS13k = OS13k;
                iframeContent.zzfx = zzfx;
                iframeContent.OS13kStart && iframeContent.OS13kStart();
                
                // set focus
                this.Focus();
            };
            
            // create content wrapper for fullscreen support
            const iframeContentWrapper = document.createElement('span');
            this.iframeContentWrapper = iframeContentWrapper;
            this.shadowRoot.appendChild(iframeContentWrapper);
            iframeContentWrapper.appendChild(iframe);
            iframe.src = icon.src;
        }
    }
    
    Close()
    {
        if (this.os13kIcon.hideWhenClosed)
        {
            // hide window so it can be reopened
            this.style.display = 'none';
        }
        else
        {
            // destroy window
            this.os13kIcon.os13kWindow = 0;
            this.remove();
        }
    }
    
    MouseDown(id)
    {
        // check for title bar buttons
        (id == 'close') && this.Close();
        (id == 'full') && this.FullScreen();
        (id == 'titleBar') && (selected = this);
            
        // set focus
        this.Focus();
    }
    
    FullScreen()
    {
        // set fullscreen
        const fullScreenElement = this.iframeContentWrapper;
        if (fullScreenElement.webkitRequestFullScreen)
            fullScreenElement.webkitRequestFullScreen();
        else if (fullScreenElement.mozRequestFullScreen)
            fullScreenElement.mozRequestFullScreen();
    }
    
    SetActive(active=1)
    {
        if (active)
        {
            // move to top when active
            this.style.zIndex = ++activeWindowZ;
            
            // deactivate old window
            if (activeWindow && activeWindow != this)
                activeWindow.SetActive(0);
        }
        
        // change title color when active
        this.titleBar.style.background = active ? '#aac' : '#777';
        
        // set active
        activeWindow = active ? this : 0;
    }
    
    Focus()
    {
        // set focus
        this.iframeContent ? this.iframeContent.focus() : this.focus();
        this.SetActive();
    }
} // OS13kWindow

customElements.define('os13k-window', OS13kWindow);

/////////////////////////////////////////////////////////////////////////////
// Input

let selected;
let seletOffsetX;
let seletOffsetY;

onmousedown=e=>
{
    // prevent getting stuck
    if (selected)
        return onmouseup(e);
    
    // get os13k target
    const originalTarget = e.originalTarget || e.path[0];
    
    // if icon was clicked on, used that instead of target which may be a window
    const target = (originalTarget.localName == 'os13k-icon') ? originalTarget : e.target;
    
    // set selected offset
    const rect = target.getBoundingClientRect();
    seletOffsetX = e.x - rect.left;
    seletOffsetY = e.y - rect.top;
    
    if (target.MouseDown)
    {
        // target mouse down event
        target.MouseDown(originalTarget.id);
        
        // prevent main document getting refocused if title bar is clicked
        if (originalTarget.id == 'titleBar' || originalTarget.id == 'full')
            e.preventDefault();
    }
    else
    {
        // deactivate window if not clicked on
        activeWindow && activeWindow.SetActive(0);
    }
    
    // prevent pointer events while dragging
    os13kDesktop.style.pointerEvents = 'none';
    selected && (document.body.style.cursor = 'grabbing');
}

onmouseup=e=>
{
    // allow pointer events and reset cursor
    os13kDesktop.style.pointerEvents = '';
    document.body.style.cursor = '';
    
    // selected mouse up event
    selected && selected.MouseUp && selected.MouseUp(e);
        
    // release selected
    selected = 0;
}

onmousemove=e=>
{
    // update selected position
    if (selected)
    {
        // clamp to window
        const x = OS13k.Clamp(e.x, 9, innerWidth-9);
        const y = OS13k.Clamp(e.y, 9, innerHeight-9);
        selected.style.left = x - seletOffsetX;
        selected.style.top = y - seletOffsetY;
    }
}

ondblclick=e=>
{
    // open icon
    const target = e.originalTarget || e.path[0];
    target.Open && target.Open();
}

oncontextmenu=e=> e.preventDefault();

/////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth 

let zzfxV = .3; // volume
const zzfx =    // play zzfx sound
(
    volume = 1, 
    randomness = .05,
    frequency = 220,
    attack = 0,
    sustain = 0,
    release = .1,
    shape = 0,
    shapeCurve = 1,
    slide = 0, 
    deltaSlide = 0, 
    pitchJump = 0, 
    pitchJumpTime = 0, 
    repeatTime = 0, 
    noise = 0,
    modulation = 0,
    bitCrush = 0,
    delay = 0,

    // locals
    PI2 = Math.PI*2,
    sampleRate = 44100,
    random = r => r*2*Math.random()-r,
    sign = v => v>0?1:-1,
    startSlide = slide *= 500 * PI2 / sampleRate**2,
    startFrequency = frequency *= 
        (1 + random(randomness)) * PI2 / sampleRate,
    modPhase = sign(modulation) * PI2/4,
    b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, d=.5,
    length, buffer
) =>
{
    // init parameters
    attack = 99 + attack * sampleRate | 0;
    sustain = sustain * sampleRate | 0;
    release = release * sampleRate | 0;
    delay = delay * sampleRate | 0;
    deltaSlide *= 500 * PI2 / sampleRate**3;
    length = attack + sustain + release + delay;
    modulation *= PI2 / sampleRate;
    pitchJump *= PI2 / sampleRate;
    pitchJumpTime = pitchJumpTime * sampleRate;
    repeatTime = repeatTime * sampleRate;

    // generate waveform
    for(; i < length;b[i++] = s)
    {
        if (++c>bitCrush*100)                            // bit crush
        {
            c = 0;
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation - modPhase);    // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
              Math.sin((s%PI2)**3) :                     // 4 noise
              Math.max(Math.min(Math.tan(s),1),-1):      // 3 tan
              1-(2*s/PI2%2+2)%2:                         // 2 saw
              1-4*Math.abs(Math.round(s/PI2)-s/PI2):     // 1 triangle
              Math.sin(s);                               // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * zzfxV * (                      // envelope
                i<attack ? i/attack :                    // attack
                i<attack+sustain ? 1 :                   // sustain
                i<length-delay ?                         // post release
                1 - (i-attack-sustain)/release : 0);     // release
                
            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i-delay]/2) : s;
        }

        t += 1 + random(noise);             // noise
        tm += 1 + random(noise);            // modulation noise
        frequency += slide += deltaSlide;   // frequency slide

        if (j && ++j > pitchJumpTime)       // pitch jump
        {
            frequency += pitchJump;         // apply pitch jump
            startFrequency += pitchJump;    // also apply to start
            j = 0;                          // reset pitch jump time
        };

        if (repeatTime && ++r > repeatTime) // repeat
        {
            frequency = startFrequency;     // reset frequency
            slide = startSlide;             // reset slide
            r = 1;                          // reset repeat time
            j = j||1;                       // reset pitch jump time
        }
    }
    
    return OS13k.PlaySamples(b);
}

/////////////////////////////////////////////////////////////////////////////
// Start OS13k!

const OS13k = new _OS13k;

</script>