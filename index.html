<!--

OS13k is a tiny operating system designed for a JS13k community project. It has native support for Shadertoys, Dweets, ZzFX, trophies, and much more.

Your mission, if you choose to accept it, is to help us fill it up with as much cool stuff as we can fit.

Please keep this project confidential!

‚úåÔ∏èüòÑ ‚ù§Ô∏è OS13k Team

-->

<title>OS13k - A Tiny JavaScript Operating System</title>
<link rel=icon type=image/x-icon href='favicon.ico'/>
<meta name=viewport content='width=device-width,initial-scale=1,user-scalable=0'>
<script src=programs.js?v139></script>

<!-- HTML above is OPTIONAL -->

<meta charset=utf-8>
<style>
body
{
    opacity:0;
    margin:0;
    overflow:hidden;
    font-family:arial;
    font-size:22;
    user-select:none;
    white-space:nowrap;
    background:#000;
}
#menu
{
    display:flex;
    flex-direction:column;
    background:#000;
}
.programMenu { background:linear-gradient(#fff,#777); }
#menu, .programMenu
{
    visibility:hidden;
    position:absolute;
    z-index:20000;
    box-shadow:5px 5px 9px;
    border:2px solid;
}
.program
{
    font-size:18;
    height:18;
    padding:4;
}
.activeWindow { border:3px solid #aaa; }
#taskbar
{
    position:absolute;
    z-index:10000;
    width:100%;
    background:linear-gradient(#888,#333);
    box-shadow:0px 1px 9px;
    border:2px solid;
    left:-2;
}
.taskbarIcon { width:50; height:40; text-shadow:1px 1px 3px #000; }
.programActive,
.taskbarIconActive         { background:linear-gradient(#ff8,#fff); }
.taskbarIcon:hover         { background:linear-gradient(#fff,#44f); }
#tray
{
    margin:2;
    padding-left:9;
    padding-right:9;
    color:#fff;
    background:linear-gradient(#000,#333);
    border:1px solid;
    border-radius:6px;
    text-shadow:1px 1px 3px #000;
}
.trayIcon       { padding:2; }
.trayIcon:hover { background:#fff3; }
.popup
{
    position:relative;
    z-index:10000;
    width:200;
    padding:8;
    pointer-events:none;
    white-space:normal;
    text-align:center;
    background:linear-gradient(#eee,#888);
    box-shadow:9px 9px 19px;
    border:2px solid;
    border-radius:9px;
}
.trophyIcon
{
    padding:9;
    font-size:40;
    text-shadow:2px 2px 4px;
    white-space:nowrap;
}
#background
{
    position:absolute;
    width:100%;
    height:100%;
    color:#0002;
    font-family:impact;
    font-size:30vw;
    font-weight:900;
    position:absolute;
}
.program, #taskbar, .taskbarIcon, #background, #tray
{
    display:flex;
    align-items:center;
    justify-content:center;
}
</style>
<template id=T>
<style>
:host
{
    visibility:hidden;
    position:absolute;
    background:#000;
    box-shadow:5px 5px 9px;
    border:3px solid #222;
    border-radius:6px;
    overflow:hidden; 
}
.titlebar
{
    height:34;
    font-size:24;
    display:flex;
    align-items:center;
    white-space:nowrap;
    background:linear-gradient(#ccc,#444);
    border-bottom:3px solid;
}
.titlebarActive       { background:linear-gradient(#eee,#88f); }
.titlebarActiveUser   { background:linear-gradient(#eee,#8f8); }
.titlebarActiveSticky { background:linear-gradient(#eee,#f88); }
.titlebarSticky       { background:linear-gradient(#ccc,#844); }
#name                 { width:100%; overflow:hidden; cursor:grab; }
#icon           
{ 
    display:inline;
    text-shadow:1px 1px 3px #000;
    margin-left:9;
    margin-right:9;
    pointer-events:none;
}
#frame
{
    width:100%;
    height:100%;
    background:#fff;
    border:none;
    visibility:hidden;
}
#codeDisplay
{
    display:none;
}
#codeText
{
    height:99;
    background:#000;
    color:#fff;
}
#errorText
{
    background:#000;
    color:#f00;
}
#codeOptions
{
    background:#111;
    color:#fff;
    font-size:16;
    padding:10;
    overflow:auto;
}
#codeText, #errorText, #codeOptions
{
    width:100%;
    resize:none;
    outline:0;
}
#full:hover   { background:#fff; }
#help:hover   { background:#0ff; }
#code:hover   { background:#f0f; }
#shrink:hover { background:#0ff; }
#grow:hover   { background:#0f0; }
#reload:hover { background:#ff0; }
#close:hover  { background:#f00; }
</style>
</template>
<div id=background></div>
<div id=desktop>
<div id=taskbar>
<div id=taskbarSpace style=flex:1></div>
<div id=tray></div>
</div>
<div id=popups style=float:right></div>
<div id=programsMenu style=position:absolute></div>
<div id=menu>
<button id=buttonFullScreen>Full Screen
<button id=buttonCode>Code
<button id=buttonHelp>Help
<button id=buttonResetSize>Reset Size
<button id=buttonReload>Reload
<button id=buttonClose>Close
<script>

'use strict';

///////////////////////////////////////////////////////////////////////////////
// OS13k Debug (remove from minified)

const OS13kVersion = 68;
{
    // version check, clear local storage if older
    if (localStorage.OS13kVersion && localStorage.OS13kVersion != OS13kVersion)
    {
        alert('OS13k version out of date! System reset in 3, 2, 1...');
        localStorage.clear();
    }

    localStorage.OS13kVersion = OS13kVersion;

    // load default programs if none found
    var programsDefault = 0;
    if (typeof programs == 'undefined')
    {
        alert('No programs found, using defaults!')

        var sticky=2**0, reload=2**1, awake=2**2, full=2**3, resize=2**4, code=2**5,
        closeAll = 2**7, newUserProgram = 2**8, clearUserPrograms = 2**9,
        defaultFlags = full|reload|resize, defaultWidth = 720, defaultHeight = 405,
        programs = 
        [
            [,'‚ùå',,,closeAll,'Close All'],
            ['help.html','<b><span style=color:#0f0>?',380,400,sticky],

            [,'‚öôÔ∏è',,,,'System',,
            [
                ['system/settings.html','üéöÔ∏è',470,190,sticky],
                ['system/trophyCase.html','üèÜ',,,full|resize|sticky],
                ['system/clock.dweet.js','üï∞Ô∏è',200,200,sticky|code|awake],
                ['system/systemTest.html',,600,370,defaultFlags|code],
            ]],
            
            [,'üòÄ',,,,'User Programs',,
            [
                [,'üìå',,,newUserProgram,'New User Program'],
                [,'‚ö†Ô∏è',,,clearUserPrograms,'Clear User Programs'],
            ]]
        ];
    }
} // debug stuff

///////////////////////////////////////////////////////////////////////////////
// Minification Stuff

{
// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs localStorage.OS13k, OS13k, zzfxG
// @js_externs iframeContent.zzfx, iframeContent.OS13kW
// @js_externs OS13k.Clamp, OS13k.Percent, OS13k.Lerp
// @js_externs OS13k.Random, OS13k.randomSeed, iframeContent.OS13kReload
// @js_externs OS13k.Trophies, OS13k.Trophy, OS13k.GetTrophy
// @js_externs OS13kSystem.Sound, OS13k.PlaySamples, OS13k.Note
// @js_externs OS13k.Speak, OS13k.StopSpeech, OS13k.PlaySeed
// @js_externs OS13k.Settings(), OS13k.SaveSettings()
// @js_externs OS13k.CreateShader, OS13k.RenderShader, source.gain
// @js_externs OS13k.KeyDirection, OS13k.StripHTML, OS13k.Popup
// @js_externs settings.v, settings.m, settings.s, settings.p, settings.o
// @js_externs settings.c, settings.d, settings.t, settings.f
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==

// Minification Steps
// 1. Remove touch support and optional code
// 2. Paste programs directly below here
// 3. Remove optional stuff listed below
// 4. Verify that it works the same
// 5. HTML Minifier http://minifycode.com/html-minifier/
// 6. Google Closure https://closure-compiler.appspot.com/home
// 7. Terser no extra compression https://xem.github.io/terser-online/
// 8. Zip
// 9. Advzip "advzip -z -4 -i 1000 OS13kMin.zip"

// Rework stuff marked OPTIONAL for final build
// - all files must be packed together to save space
// - smaller webgl names r10215
// - move css into code, get rid of names
// - remove system trophies
// - remove console messages

} // Minification Stuff

///////////////////////////////////////////////////////////////////////////////
// OS13k Client Interface

class _OS13k
{

/////////////////////////////////////////////////////////////////////////////
// OS13k Math

    Clamp   (a, min=0, max=1)  { return Math.min(Math.max(a, min), max); }
    Percent (v, a, b)          { return b-a ? this.Clamp((v-a)/(b-a), 0, 1) : 0; }
    Lerp    (p, a, b)          { return a + this.Clamp(p, 0, 1) * (b-a); }
    Hash    (s)                { return [...s].reduce((a,c)=>c.charCodeAt()+a*31|0, 0); }
    Random  (max=1, min=0)    
    {
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= (this.randomSeed||1) << 13;
        this.randomSeed ^= this.randomSeed >> 17;
        this.randomSeed ^= this.randomSeed << 5;
        return this.Percent(Math.abs(this.randomSeed) % 1e9 / 1e9, min, max);
    }

/////////////////////////////////////////////////////////////////////////////
// OS13k Trophies
    
    // award player with trophy, returns 0 if already owned
    Trophy(game='', icon='', name='', message='', language='ja')
    {
        // replace commas and apostrophes
        const Clean=string=>(string+'').replace(/`/g, "'").replace(/,/g, '');
        game    = Clean(game);
        name    = Clean(name);
        icon    = Clean(icon);
        message = Clean(message);
        
        // remove html tags
        icon    = this.StripHTML(icon,    maxWordLength, 1);
        name    = this.StripHTML(name,    maxWordLength, 1);
        game    = this.StripHTML(game,    maxWordLength, 1);
        message = this.StripHTML(message, maxWordLength, 1);
        
        // build key
        const key = game + `,${ icon },` + name;
        
        // find in trophy list
        const i = trophies.findIndex(e=>e[4]==key);
        
        // skip if same message
        if (i >=0 && trophies[i][3] == message) return;
        
        // add or update trophy list
        const trophyData = [game, name, icon, message, key];
        i < 0 ? trophies.unshift( trophyData ) :
            trophies[i] = trophyData;

        // save trophy
        localStorage['OS13kTrophy,' + key] = message;
        
        // reload trophy window
        trophyTrayIcon.program && 
            trophyTrayIcon.program.window &&
            trophyTrayIcon.program.window.Reload();
        
        // use game as name if there is no name
        name || game && (name = game, game = '');

        // add trophy popup
        this.Popup(
            `<div class=trophyIcon>${ 
                icon || 'üèÜ' }</div><div><b>${ // icon
                name }</b><br><i>${            // name
                game }</i></div>` +            // game
                message,                       // message
            name || game,                      // speak
            language);                         // language
            
        // save trophies
        OS13k.Save();
    }
    
    // get message, 0 if no trophy
    GetTrophy(game, name)
    {
        // find in trophy list
        const i = trophies.findIndex(e=>e[0]==game & e[1]==name);
        
        // return trophy message
        return i < 0 ? 0 : trophies[i][3];
    }
    
    // get trophy list
    Trophies() { return trophies; }
    
    // get trophy list
    ClearTrophies() { trophies = []; }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Audio

    // play seed sound
    PlaySeed(seed, lengthScale=1, volume=1, randomness=.05, frequency, music)
    { return this.PlaySamples(this.SeedSamples(...arguments), music); }
    
    // get seed samples
    SeedSamples(seed, lengthScale=1, volume=1, randomness=.05, frequency)
    { return zzfxG(...this.SeedParameters(...arguments)); }
    
    // get zzfx sound parameters from seed
    SeedParameters(seed, lengthScale=1, volume=1, randomness=.05, frequency)
    {
        // check if eed is a number
        if (parseFloat(seed = (seed+'').trim()) != seed)
        {
            // seed is not number, check if zzfx string
            if (seed.slice(0,9) == 'zzfx(...[')
            {
                // get zzfx parameters from string
                const parameters = [];
                for (const p of seed.slice(9).split(','))
                    parameters.push(p.length? parseFloat(p) : undefined);
                
                // play zzfx sound
                return parameters;
            }
            else
                seed = OS13k.Hash(seed);
        }

        // set seed
        this.randomSeed = seed;
           
        // clamp max length
        lengthScale = this.Clamp(lengthScale, 0, 5);
     
        // helper functions
        const R=()=>this.Random(), C=()=>R()<.5?R():0, S=e=>C()?e:-e,
        
        // randomize sound length
        attack  = R()**3/4*lengthScale,
        decay   = R()**3/4*lengthScale,
        sustain = R()**3/4*lengthScale,
        release = R()**3/4*lengthScale,
        length  = attack + decay + sustain + release,
        f = R()**2*2e3;
        
        // generate random sound
        return [
           volume,           // volume
           randomness,       // randomness
           frequency || f,   // frequency
           attack,           // attack
           sustain,          // sustain
           release,          // release
           R()*5|0,          // shape
           R()**2*3,         // shapeCurve
           C()**3*S(99),     // slide
           C()**3*S(99),     // deltaSlide
           C()**2*S(1e3),    // pitchJump
           R()**2 * length,  // pitchJumpTime
           C() * length,     // repeatTime
           C()**4,           // noise
           C()**3*S(9),      // modulation
           C()**4,           // bitCrush
           C()**3/2,         // delay
           1 - C(),          // sustain volume
           decay             // decay
        ];
    }
    
    // play audio sample data
    PlaySamples(samples, music, sampleRate=defaultSampleRate)
    { return this.PlaySamplesArray([samples], music, sampleRate); }
    
    // play and array of audio sample data
    PlaySamplesArray(samplesArray, music, sampleRate=defaultSampleRate)
    {
        // create buffer and source
        const buffer = audioContext.createBuffer
            (samplesArray.length, samplesArray[0].length, sampleRate),
            source = audioContext.createBufferSource();
        
        // copy samples to buffer and play
        samplesArray.map((d,i)=>buffer.getChannelData(i).set(d));
        source.buffer = buffer;
        
        // create custom gain node
        const customGain = source.gain = audioContext.createGain();
        source.connect(customGain);
        customGain.connect(music ? gainMusic : gain);
        source.start();
        return source;
    }
    
    PlayMusic(song) 
    { 
        // handle errors when playing music
        try { return this.PlaySamplesArray(zzfxM(...song), 1); }
        catch(e) {console.log(e)}
    }
    
    GetAnalyser() { return analyserCanvas; }
    GetAnalyserData() { return analyserData; }
    
    // get frequency of a musical note on a diatonic scale
    Note(semitoneOffset=0, rootNoteFrequency=440)
    { return rootNoteFrequency * 2**(semitoneOffset/12); }

    // speak text
    Speak(text, rate=1, pitch=1, volume=1, language='en', stopSpeech)
    {
        // common languages (not supported in all browsers)
        // it - italian,  fr - french, de - german,  es - spanish, pl - polish
        // ja - japanese, hi - hindi,  ru - russian, zh - chinese, ko - korean
    
        // set utterance parameters
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.volume = volume * gain.gain.value * 3;
        utterance.pitch = pitch;
        utterance.rate = rate;
        utterance.lang = language;

        // stop speech if set
        stopSpeech && OS13kSystem.StopSpeech();

        // play speech if allowed
        settings.s && finishedStartup && speechSynthesis && 
            speechSynthesis.speak(utterance);
    }
        
/////////////////////////////////////////////////////////////////////////////
// OS13k Shaders

    // create pixel shader
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // use hardcoded values to save space
        const xVERTEX_SHADER       = 35633;
        const xARRAY_BUFFER        = 34962;
        const xSTATIC_DRAW         = 35044;
        const xBYTE                = 5120;
        const xFRAGMENT_SHADER     = 35632;
        const xCOMPILE_STATUS      = 35713;
        const xTEXTURE_2D          = 3553;
        const xUNPACK_FLIP_Y_WEBGL = 37440;
        const xTEXTURE_MIN_FILTER  = 10241;
        const xLINEAR              = 9729;

        // create a simple pass through vertex shader
        const vertexShader = x.createShader(xVERTEX_SHADER);
        x.shaderSource(vertexShader,
            '#version 300 es\n' +
            'in vec4 c;' +
            'void main()' +
            '{gl_Position=c;}');
        x.compileShader(vertexShader);
        
        // create vertex buffer that is a big triangle
        const vertexBuffer = xARRAY_BUFFER;
        x.bindBuffer(vertexBuffer, x.createBuffer());
        x.bufferData(vertexBuffer, new Int8Array([-3,1,1,-3,1,1]), xSTATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0, 2, xBYTE, 0, 0, 0); // 2D vertex
        
        // check vertex shader for errors
        //if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
        //    throw x.getShaderInfoLog(vertexShader);
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(xFRAGMENT_SHADER);
        const shaderProgramCode = 
            '#version 300 es\n' +
            'precision mediump float;' +
            'uniform float iTime;' +
            'uniform int iFrame;' +
            'uniform vec4 iMouse;' +
            'uniform vec3 iResolution;' +
            'uniform sampler2D iChannel0;' +
            'out vec4 c;\n' +
            code +
            '\nvoid main()' +
            '{mainImage(c,gl_FragCoord.xy);' +
            'c.a=1.;}';
        x.shaderSource(pixelShader, shaderProgramCode);
        x.compileShader(pixelShader);

        // check pixel shader for errors
        if (!x.getShaderParameter(pixelShader, xCOMPILE_STATUS))
            throw x.getShaderInfoLog(pixelShader);

        // create texture
        x.bindTexture(xTEXTURE_2D, x.createTexture());
        x.texParameteri(xTEXTURE_2D, xTEXTURE_MIN_FILTER, xLINEAR);
        x.pixelStorei(xUNPACK_FLIP_Y_WEBGL, 1); 
        
        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    // render a pixel shader
    RenderShader(canvas, shaderProgram, time, frame, X, Y, Z, W)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // use hardcoded values to save space
        const xRGBA          = 6408;
        const xUNSIGNED_BYTE = 5121;
        const xTRIANGLE_FAN  = 6;
        const xTEXTURE_2D    = 3553;
        
        // set uniforms
        x.uniform3f(x.getUniformLocation(shaderProgram,'iResolution'), canvas.width, canvas.height, 1);
        x.uniform1f(x.getUniformLocation(shaderProgram,'iTime'), time);
        x.uniform1f(x.getUniformLocation(shaderProgram,'iFrame'), frame);
        x.uniform1i(x.getUniformLocation(shaderProgram,'iChannel0'), 0);
        x.uniform4f(x.getUniformLocation(shaderProgram,'iMouse'), X, Y, Z, W);
        
        // set vieport and render shader
        x.viewport(0, 0, canvas.width, canvas.height);
        x.drawArrays(xTRIANGLE_FAN, 0, 3);
        
        // set texture to newly rendered image
        x.texImage2D(xTEXTURE_2D, 0, xRGBA, xRGBA, xUNSIGNED_BYTE, canvas);
    }

/////////////////////////////////////////////////////////////////////////////
// OS13k Input

    // get direction from wasd or arrow keys
    KeyDirection(keyCode)
    {
        let x=0, y=0;
        (keyCode == 87 | keyCode == 38) && ++y; // up
        (keyCode == 83 | keyCode == 40) && --y; // down
        (keyCode == 68 | keyCode == 39) && ++x; // right
        (keyCode == 65 | keyCode == 37) && --x; // left
        return {x, y};
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Text
    
    // remove html tags from a string
    StripHTML(string, maxLength)
    {
        // convert to string
        return (string+='')
        
            // clamp max length
            .substring(0, maxLength? maxLength: string.length)
            
            // replace tags
            .replace(/<.*>/g,'');
    }
    
    Popup(html, speak, language)
    {
        // create popup
        const popup = popups.appendChild(document.createElement('div'));
        popup.className = 'popup';
        popup.innerHTML = html;
        popup.speak = speak;
        popup.speakLanguage = language;
        popup.style.visibility = 'hidden';
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Seralization
    
    Save()
    {
        // save data if finished startup
        finishedStartup && (
        localStorage.OS13k = JSON.stringify(
        {
            t:trophies,
            s:settings,
            i:programInfos,
            p:startProgramId,
            n:nextUserProgramId
        }));
        
        // gain, stop all speech if muted
        (gain.gain.value = settings.v) || OS13kSystem.StopSpeech();
           
        // music gain 
        gainMusic.gain.value = settings.m;
           
        // stop speech if not enabled
        settings.s || OS13kSystem.StopSpeech();
        
        // background
        background.style.background = 
            `linear-gradient(${settings.c},${settings.d})`;
        background.innerText = settings.t;
        
        // filter
        background.style.filter = desktop.style.filter = settings.f;
    }
    
    SaveSettings(volume, musicVolume, speech, showPopups, systemSounds, 
        color1, color2, text, filter)
    {
        // set settings and save
        this.Save(
            settings = 
            {
                v:gain.gain.value = volume,
                m:gainMusic.gain.value = musicVolume,
                s:speech,
                p:showPopups,
                o:systemSounds,
                c:color1,
                d:color2,
                t:text,
                f:filter
            });
    }
    
    Settings() { return settings; }
}; // _OS13k
var OS13k = new _OS13k;

///////////////////////////////////////////////////////////////////////////////
// OS13k Variables

const taskbarHeight = 44, titlebarHeight = 37, programHeight = 26, 
      startOpenOffset = 9, popupTime = 3, defaultVolume = .3, 
      maxWordLength = 32, defaultSampleRate = 44100, analyserWaitTime = 1e4,

    // system sounds
    soundOpen       = -8,
    soundClose      = 92,
    soundGrabStart  = 45,
    soundGrabEnd    = 42,
    soundMenu       = 8,
    soundTrophy     = 96,
    soundActive     = 66,
    soundShrink     = 75,
    soundGrow       = 61,
    soundFullScreen = -9,
    soundHelp       = 48,
    soundCode       = 16,
    soundReload     = 85,
    soundProgram    = 90,

    // init web audio
    audioContext = new AudioContext, 
    gain = audioContext.createGain(), 
    gainMusic = audioContext.createGain(), 
    musicAnalyser = audioContext.createAnalyser();

let grabWindow, grabOffsetX, grabOffsetY, finishedStartup, nextUserProgramId = 0,
    activeWindow, activeProgram, activeTaskbarIcon, loadIcon, safeCode,
    analyserCanvas, analyserData = [], lastMusicTime = -analyserWaitTime,
    lastActiveFrame, topZ = 0, loading = 0, hadInput = 0,
    windowOpenX = startOpenOffset, windowOpenY = startOpenOffset + taskbarHeight,
    startProgram, startProgramId, programInfos = [], trophies = [],
    trophyTrayIcon, settingsTrayIcon, clockTrayIcon, musicTrayIcon,

    // volume, musicVolume, speech, popups, color1, color2, text, filter
    settings = {v:.3, m:.3, s:1, p:1, o:1, c:'#222233', d:'#332222', t:'OS13k', f:''};

///////////////////////////////////////////////////////////////////////////////
// OS13k System Functions - handles non client facing features of OS13k

class _OS13kSystem
{
    Start()
    {
        // load os13k data
        if (localStorage.OS13k)
        {
            const saveData    = JSON.parse(localStorage.OS13k);
            trophies          = saveData.t;
            settings          = saveData.s;
            programInfos      = saveData.i;
            startProgramId    = saveData.p;
            nextUserProgramId = saveData.n;
        }
        
        // save and update settings
        OS13k.Save();
        
        // setup audio
        gain.connect(audioContext.destination);
        gainMusic.connect(audioContext.destination);
        gainMusic.connect(musicAnalyser);
        
        // create tray icons
        musicTrayIcon     = new OS13kTrayIcon();
        trophyTrayIcon    = new OS13kTrayIcon();
        settingsTrayIcon  = new OS13kTrayIcon();
        clockTrayIcon     = new OS13kTrayIcon();
        
        // create analyser canvas
        analyserCanvas = musicTrayIcon.appendChild(document.createElement('canvas'));
        analyserCanvas.style = 'width:16;height:16;margin:2;pointer-events:none'
        
        // listen for trophies from other windows
        onstorage=e=> this.CheckForTrophy(e.key);

        // stop spech if page is unloaded
        onunload=e=> this.StopSpeech();

        // set button functions
        buttonFullScreen.onmousedown =()=> activeWindow.FullScreen();
        buttonHelp.onmousedown       =
        buttonCode.onmousedown       =()=> activeWindow.ShowCode();
        buttonResetSize.onmousedown  =()=> activeWindow.SetActive(1, 1, activeWindow.Resize(1, soundGrow));
        buttonReload.onmousedown     =()=> activeWindow.Reload();
        buttonClose.onmousedown      =()=> activeWindow.Close();

        // create load program taskbar icon and add folders/programs
        loadIcon = new OS13kTaskbarIcon( {icon:'üíæ', name:'Load Program'} );
        loadIcon.windowOrMenu = new OS13kProgramMenu(programs);
        loadIcon.windowOrMenu.Rebuild();

        // welcome message
        OS13k.Trophy('','üëã','Welcome to OS13k!');

        // search local storage for new trophies (from other JS13k games)
        for (const key in localStorage) this.CheckForTrophy(key);

        // try to update startup and kick off first update
        this.Update(this.UpdateStartup());
    }

    // wait for startup to finish
    UpdateStartup()
    {
        // skip until not loading and finished startup
        if (loading | finishedStartup) return;
            
        // open start program (check top to stop infinite recursion if meta)
        startProgram && self == top | startProgram.sticky &&
            startProgram.Open(startProgram = 0);
            
        // finish startup after opening startup programs
        finishedStartup = 1;
        
        // save os13k data
        OS13k.Save();
    }

    // main update loop
    Update(time)
    {
        // request new animation frame
        requestAnimationFrame(OS13kSystem.Update);
            
        // check if iframe became new active element
        const activeElement = document.activeElement;
        const activeFrame = activeElement.shadowRoot &&
            activeElement.shadowRoot.activeElement == activeElement.iframe ?
                activeElement.iframe : 0;
                
        // set active element and set that we had input
        activeFrame && lastActiveFrame != activeFrame &&
            document.activeElement.SetActive(hadInput = 1);
         
         // set last active frame
        lastActiveFrame = activeFrame;

        // fade in desktop, convert opacity to number
        loading || (document.body.style.opacity 
            = Math.min(1,.02 + document.body.style.opacity*1));

        // update trophy count
        trophyTrayIcon.innerHTML = trophies.length + ' üèÜ';
        
        // update time
        clockTrayIcon.title = new Date();
        clockTrayIcon.innerHTML 
            = clockTrayIcon.title.replace(/.*(\d+:\d+):.*/, '$1');
        
        // get analyser data
        musicAnalyser.fftSize = 64
        const frequencyData = new Uint8Array(analyserCanvas.width = analyserCanvas.height = 32),
            context = analyserCanvas.getContext('2d');
        musicAnalyser.getByteFrequencyData(frequencyData);
        
        // render analyser
        let i = 0;
        for(; i < 32; )
        {
            // get frequency band volume and adjust for loudness
            const volume = frequencyData[i] / 255 * (1 + Math.log10((i+1) * defaultSampleRate / 64 ));

            // draw loudness bar
            context.fillStyle = `hsl(${-99-69*volume} 99%50%)`;
            context.fillRect(i, 31, 1, -8*volume);
            
            // set anaylzer data, normalize between 0-1
            analyserData[i++] = OS13k.Clamp(volume / 5, 0, 1);

            // save how long there has been no music
            volume && (lastMusicTime = time)
        }
        
        // set analyser visibility
        analyserCanvas.style.display = 
            time - lastMusicTime < analyserWaitTime ? '' : 'none';
        
        // show popups after startup is finished and there was input
        if (!finishedStartup || !hadInput) return;
        
        // update popups, use copy to prevent skipping if removed
        let offsetY = 0;
        [...popups.children].map((popup,i)=>
        {
            // popup sounds
            popup.speak && OS13k.Speak(popup.speak, 1, 1, 1, popup.speakLanguage);
            popup.speak = 0;
            
            if (!settings.p)
                popups.removeChild(popup);
            else if (!document.fullscreenElement)
            {
                // move popup up, set to bottom if it was invisible
                let y = popup.style.visibility ? 
                     innerHeight : parseFloat(popup.style.top) + offsetY - 9;
                popup.style.visibility = '';
                
                if (y < taskbarHeight)
                {
                    // stop popup below taskbar
                    y = taskbarHeight;

                    // fade out popup if at top
                    if (!i && !(popup.style.opacity = (popup.style.opacity || popupTime) - .01))
                    {
                        // remove when invisible and adjust for height
                        const rect = popup.getBoundingClientRect();
                        offsetY += rect.height;
                        popups.removeChild(popup);
                    }
                }

                // set popup position
                popup.style.top = y;
            }});
    }

    // close all menus
    CloseMenus()
    {
        // hide all menus
        [...programsMenu.children].map(child=>
            child.style.visibility = menu.style.visibility = '');
        
        // unselect active program
        activeProgram && (activeProgram.className = 'program');
    }

    // try to give trophy if key is valid
    CheckForTrophy(key)
    {
        const keyParts = key ? key.split(',') : [];
        return keyParts.shift() == 'OS13kTrophy' &&
            OS13k.Trophy(...keyParts, localStorage[key]);
    }
    
    // stop any current or queued speech
    StopSpeech() { speechSynthesis && speechSynthesis.cancel(); }
    
    // play system sound if enabled
    Sound(seed, length) 
    { hadInput && settings.o && OS13k.PlaySeed(seed, length); }

} // OS13kSystem
const OS13kSystem = new _OS13kSystem;

///////////////////////////////////////////////////////////////////////////////
// OS13kProgramMenu - holds a list of programs

class OS13kProgramMenu extends HTMLElement
{
	constructor(infos, parentMenu)
    {
		super();
        
        // add to programs menu
        this.className    = 'programMenu';
        this.parentMenu   = parentMenu;
        this.programInfos = infos;
        
        // add programs to menu
        for(const info of infos)
        {
            // create program and menu
            const program = info.program = new OS13kProgram(...info);  
            program.programMenu = program.folder ? 
                new OS13kProgramMenu(program.folder, this) : this;  
                
            // create user program info and add to info list after clear
            program.flags & clearUserPrograms &&
                programInfos.map(info=> info.code != undefined && infos.push(
                    [,info.icon,info.width,info.height,defaultFlags|code,info.name,,,info.id]));
        }
    }
    
    Rebuild(y = 0)
    {
        // clear programs menu
        this.parentMenu || (programsMenu.innerHTML = '');
        this.innerHTML = '';
        programsMenu.appendChild(this);
  
        // add programs to menu
        this.programInfos.map(info=>this.appendChild(info.program));
        
        // set position
        this.style.top  = y;
        this.style.left = this.parentMenu ?
            this.parentMenu.getBoundingClientRect().right - 2 : 
            programsMenu.style.left = 0;

        // add folders after programs so width is correct
        this.programInfos.map(info=>
        {
            // rebuild child program menus
            info.program.programMenu != this && 
                info.program.programMenu.Rebuild(y);
            
            // add program height as we move down list
            y += programHeight;
        });
    }

    SetActive()
    {
        // close menus so they can reopen with this active
        OS13kSystem.CloseMenus();
        
        // set parent active
        this.parentMenu && this.parentMenu.SetActive();
        
        // make visible
        this.style.visibility = 'visible';
    }

    AddUserProgram(copyProgram)
    {
        // create new program
        const program = new OS13kProgram(...(
            copyProgram ? 
            [, 
            copyProgram.icon, copyProgram.width, copyProgram.height, defaultFlags|code, 
                copyProgram.name + ' (Copy)', , ,++nextUserProgramId] :
            [,'‚úã',,,defaultFlags|code,,,,++nextUserProgramId]));
        
        // add to menu program infos
        this.programInfos.push({program});
        
        // set menu and rebuild menus
        program.programMenu = this;
        loadIcon.windowOrMenu.Rebuild();
        
        // set code and open, use default if none found
        program.userProgram = 1;
        program.info.code = copyProgram ? copyProgram.info.code :
        '// Auto detects HTML, Dweet, or Shadertoy! ‚úåÔ∏èüòÑ\n' +
        'for(x.fillRect(0,0,i=s=2e3,s);i--;x.fillStyle="#0001")\n' +
        'x.clearRect((S(i)*1e9-t*i/9)%s,i*9%s,i%9,i%9)';

        // copy program info
        copyProgram && (
            program.info.scale = copyProgram.info.scale,
            windowOpenX = copyProgram.info.x,
            windowOpenY = copyProgram.info.y + titlebarHeight);
            
        // mark code as safe and open
        program.Open(safeCode = 1);
        program.window.ShowCode(1);
        program.window.codeText.focus();
        return program;
    }

} // OS13kProgramMenu
customElements.define('m-', OS13kProgramMenu);

///////////////////////////////////////////////////////////////////////////////
// OS13kProgram - stores program info and handles loading from folders
    
class OS13kProgram extends HTMLElement
{
	constructor(src='', icon='üí†', width=defaultWidth, height=defaultHeight, flags, name='', help='', folder, userProgramId)
    {
		super();
        
        // split source by . to get extension
        const srcParts = src.split('.');
        
        // split source by / to get filename to convert camel case src OPTIONAL
        let srcCleanName = srcParts[0].split('/');

        // add spaces between lower case and capitals
        srcCleanName = srcCleanName[srcCleanName.length-1]
            .replace(/([a-z](?=[A-Z]))/g, '$1 ');
            
        // make first letter uppercase and set if no name
        name = name || srcCleanName && (srcCleanName[0].toUpperCase() + srcCleanName.slice(1));
        
        // check for special extensions
        const extension = src ? srcParts[1] : '';
        this.isDweet = extension == 'dweet';
        this.isShader = extension == 'shader';

        // set icon data
        this.className     = 'program';
        this.src           = src;
        this.width         = width;
        this.height        = height;
        this.folder        = folder;
        this.id            = userProgramId || name;

        // set the program name and id
        this.SetName(icon, name);

        // set code only if help not shown or if has extension and not disabled
        this.code = !(this.help = help) && 
            (flags & code || 
            ((this.isDweet || this.isShader) && flags == undefined));
        
        // set flags
        this.flags    = flags = flags || defaultFlags;
        this.sticky   = flags & sticky;
        this.reload   = flags & reload;
        this.awake    = flags & awake;
        this.full     = flags & full;
        this.resize   = flags & resize;
        
        // load saved program data
        this.Load();

        // check for user code
        this.userProgram = this.info.code != undefined;
        
        // save special programs
        name == 'Settings'     && settingsTrayIcon.SetProgram(this);
        name == 'Trophy Case'  && trophyTrayIcon.SetProgram(this);
        name == 'Clock'        && clockTrayIcon.SetProgram(this);
        name == 'Music Player' && musicTrayIcon.SetProgram(this);
        
        // open help if it has not been opened yet
        name == 'Help'        && 
            this.info.open == undefined && (startProgram = this);
        
        // check if start program or sticky open
        this.sticky ? this.info.open && this.Open() :
            this.id == startProgramId && (startProgram = this);
    }

    SetName(icon, name)
    {
        // clear html
        this.innerHTML = '';

        // create div for icon to auto close html tags
        const iconDisplay = this.appendChild(document.createElement('div'));
        iconDisplay.style = 'pointer-events:none;width:45;text-shadow:1px 1px 3px #000;text-align:center';
        iconDisplay.innerHTML = this.icon = icon;;
        
        // name and folder
        this.innerHTML += `<div style=flex:1;padding-right:9;pointer-events:none>${
            this.name = OS13k.StripHTML(name) || "User Program " + this.id
            }</div>` + (this.folder? '‚ñ∂' : '');
    }
    
    Move()
    {
        // set container program menu active 
        this.programMenu.SetActive();
        activeProgram !=this && OS13kSystem.Sound(soundProgram, 0);
        
        // set active
        activeProgram = this;
        this.className = 'program programActive';
    }
    
    Open()
    {
        if (this.window)
        {        
            // set window to be active and clamp
            this.window.SetActive(1, 1);
            
            // prevent main document focus
            return false;
        }
        if (this.src || this.userProgram)
        {
            // get saved window position
            let x = this.info.x, y = this.info.y;
            
            // update window open positions if no position was set
            x || (
                x = windowOpenX,
                y = windowOpenY,
                (windowOpenX += titlebarHeight) > 400 && (windowOpenX =  windowOpenY = startOpenOffset),
                (windowOpenY += titlebarHeight) > 300 && (windowOpenY =  windowOpenY = startOpenOffset + taskbarHeight));

            // open window
            this.window = new OS13kWindow(this, x, y);

            // update info and save
            this.Save();
            
            // prevent main document focus
            return false;
        }
        if (this.flags & newUserProgram)
        {
            // create user program with default code
            this.programMenu.AddUserProgram();
            
            // prevent main document focus
            return false;
        }
        if (this.flags & closeAll)
        {
            // close all windows if no src or folder
            [...desktop.children].map(child=> child.Close && child.Close());

            // reset window open position
            windowOpenX = startOpenOffset;
            windowOpenY = startOpenOffset + taskbarHeight;

            OS13k.Trophy('OS13k','‚òï','Coffee Is For Closers','Closed All');
        }
        if (this.flags & clearUserPrograms && confirm(this.name + '?'))
        {
            // remove from menu info and close windows
            this.programMenu.programInfos = this.programMenu.programInfos.filter(info=>
                !info.program.userProgram || 
                (info.program.window && info.program.window.Close(), false)
            );
            
            // remove user program infos
            programInfos = programInfos.filter(info=>info.code == undefined);
            OS13k.Save();
            
            // rebuild menu
            loadIcon.windowOrMenu.Rebuild();
        }
    }
    
    SetActive() { this.Open(); }
    
    // toggle program open or closed
    Toggle()
    {
        activeWindow && activeWindow == this.window ?
            this.window.Close() : this.Open();
    }
    
    // load saved program info from local storage
    Load() 
    {
        // find in program info list
        const i = programInfos.findIndex(e=>e.id == this.id);
        this.info = i < 0 ? {} : programInfos[i];
    }
   
    // save program info and reset settings when closed if non sticky
    Save(open = 1)
    {
        // build save info
        this.info = 
        {
            open,
            id: this.id,
            x: open | this.sticky ? parseInt(this.window.style.left) : 0,
            y: parseInt(this.window.style.top),
            scale: open | this.sticky ? this.window.scale : 1,

            // user program info
            name: this.name,
            icon: this.icon,
            width: this.width,
            height: this.height,
            code: this.info.code,
            allowSleep: this.userProgram? this.window.allowSleep.checked : 1,
            liveEdit: this.window.liveEdit.checked
        }
        
        // add to programs info and save
        const i = programInfos.findIndex(e=>e.id == this.id);
        i < 0 ? programInfos.push(this.info) : programInfos[i] = this.info
        OS13k.Save();
    }
    
} // OS13kProgram
customElements.define('p-', OS13kProgram);

///////////////////////////////////////////////////////////////////////////////
// OS13kWindow - window to a running program, handles program loading

class OS13kWindow extends HTMLElement
{
	constructor(program, x, y)
    {
		super();

        // add to desktop
        desktop.appendChild(this);
        
        // save settings
        this.program = program;
        this.style.left = x;
        this.style.top = y;
        this.menu = 1;
        this.activeCount = 0;
        
        // shadow root
		this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = T.innerHTML;
        
        // title bar
        this.titlebar = this.shadowRoot.appendChild(document.createElement('div'));
        this.titlebar.id = 'titlebar';
        
        // title bar name
        this.name = this.titlebar.appendChild(document.createElement('div'));
        this.name.id = 'name';

        const SetName=()=>
        {
            // clear html
            this.name.innerHTML = '';

            // create div for icon to auto close html tags
            const icon = this.name.appendChild(document.createElement('div'));
            icon.id = 'icon';
            icon.innerHTML = program.icon;

            // name
            this.name.innerHTML += program.name;
        }
        SetName();
       
        // create title bar icons
        const AddTitlebarIcon=(id, title, svg, shape='path')=>
        {
            const icon = this.titlebar.appendChild(document.createElement('div'));
            icon.id = id;
            icon.title = title;
            icon.innerHTML = 
            `<svg style=height:100%;width:28;pointer-events:none viewBox='0 0 10 10'><${shape} stroke=#000 fill=none ${svg} />`;
        }
        program.resize && 
            AddTitlebarIcon('grow', 'Grow', 'd="M2 5L8 5M5 8L5 2"',
            AddTitlebarIcon('shrink', 'Shrink', 'd="M2 5L8 5"'));
        program.full && AddTitlebarIcon(
            'full', 'Full Screen', 'x=1 y=2 width=8 height=6', 'rect');
        program.help && AddTitlebarIcon('help', 'Help', 'd="M5 8L8 2L2 2L5 8L8 2"');
        program.code && AddTitlebarIcon('code', 'Code', 'd="M5 2L8 8L2 8L5 2L8 8"');
        program.reload && AddTitlebarIcon(
            'reload', 'Reload', 'cx=5 cy=5 r=3', 'circle');
        AddTitlebarIcon('close', 'Close', 'd="M2 2L8 8M8 2L2 8"');

        // create content wrapper
        (this.iframeWrapper =
            this.shadowRoot.appendChild(document.createElement('div')))
            .style.background = '#000';

        // create code/help display
        (this.codeDisplay =
            this.shadowRoot.appendChild(document.createElement('div')))
            .id = 'codeDisplay';

        // create code/help display
        (this.codeText =
            this.codeDisplay.appendChild(document.createElement('textarea')))
            .id = 'codeText';
          
        // use custom code  
        program.userProgram ? this.codeText.value = program.info.code :
            this.codeText.setAttribute('readOnly', true);
        this.codeText.setAttribute('spellcheck', false);

        // init custom code options
        const codeOptions = this.codeOptions =
            this.codeDisplay.appendChild(document.createElement('div'));
        codeOptions.id = 'codeOptions';
        program.userProgram || (codeOptions.style.display = 'none');

        // build code options html
        codeOptions.innerHTML =
            'Icon <input style=width:35 id=I> ' +
            'Name <input id=N> ' +
            'Size <input style=width:50 type=number id=W> x <input style=width:50 type=number id=H><br><br> ' +  
            '&nbsp;<button id=S>üì∑</button> ' +
            `&nbsp;Live Edit <input type=checkbox id=L ${program.info.liveEdit != false ? 'checked' : ''}> ` +
            `&nbsp;Sleep <input type=checkbox id=P ${program.info.allowSleep != false ? 'checked' : ''}> ` +
            '&nbsp;<button id=G>Save</button> ' +
            '<button id=C>Copy</button> ' +
            '<button id=D>Delete</button> ' +
            `&nbsp;<span id=Z>${program.info.code && program.info.code.length}</span> Bytes` +
            '<a id=A><canvas id=V style=display:none>';

        // get links to code options and create error text
        const iconInput = this.shadowRoot.getElementById('I'),
            nameInput = this.shadowRoot.getElementById('N'),
            widthInput = this.shadowRoot.getElementById('W'),
            heightInput = this.shadowRoot.getElementById('H'),
            link = this.shadowRoot.getElementById('A'),
            canvas = this.shadowRoot.getElementById('V'),
            canvasContext = canvas.getContext('2d'),
            errorText = this.errorText = this.codeDisplay.appendChild(document.createElement('textarea'));
        errorText.id = 'errorText';
        errorText.readOnly = true;
        
        // copy button
        this.shadowRoot.getElementById('C').onmousedown=()=>program.programMenu.AddUserProgram(program);

        // delete button
        this.shadowRoot.getElementById('D').onmousedown=()=>
        {
            // remove from menu info and close
            program.programMenu.programInfos 
                = program.programMenu.programInfos.filter(info=>info.program.info.id != program.id);
            this.Close();
            
            // remove infos
            programInfos = programInfos.filter(info=>info.id != program.id);

            // close, save, and rebuild menu
            OS13k.Save();
            loadIcon.windowOrMenu.Rebuild();
        }
        
        // save button
        this.shadowRoot.getElementById('G').onmousedown=()=>
            link.click(link.href = URL.createObjectURL(new Blob([this.codeText.value], {type:"text/plain"})),
            link.download = 'OS13k_File_' + program.name);

        // screenshot button
        this.screenshot = this.shadowRoot.getElementById('S');
        this.screenshot.onmousedown=()=>
        {
            // wrap in try block in case canvas doesnt exist
            try {
                link.click(
                    // copy to a white canvas before saving
                    canvasContext.fillStyle = '#fff',
                    canvasContext.fillRect(0, 0, 
                        canvas.width  = this.iframeContent.c.width, 
                        canvas.height = this.iframeContent.c.height),
                        canvasContext.drawImage(this.iframeContent.c, 0, 0),
                    link.href = canvas.toDataURL("image/jpeg"),
                    link.download = 'OS13k_Image_' + program.name);
            } catch(e) {} // ignore screenshot errors
        }

        // get elements by id
        this.codeSize = this.shadowRoot.getElementById('Z');
        this.liveEdit = this.shadowRoot.getElementById('L'); 
        this.allowSleep = this.shadowRoot.getElementById('P'); 
        nameInput.value = program.name; 
        iconInput.value = program.icon;
        widthInput.value = program.width; 
        heightInput.value = program.height;

        // set new icon and name when changed
        iconInput.oninput =
        nameInput.oninput =
        this.liveEdit.oninput =e=>
        {
            program.SetName(OS13k.StripHTML(iconInput.value), nameInput.value);
            program.Save();
            SetName();
            this.taskbarIcon.SetName();
        }

        // size options
        widthInput.onchange =
        heightInput.onchange =e=>
        {
            program.width = widthInput.value = OS13k.Clamp(widthInput.value, 99, defaultWidth);
            program.height = heightInput.value = OS13k.Clamp(heightInput.value, 99, program.width * 2);

            // update to new size and clamp to desktop
            this.Resize(1);
            this.SetActive(1, 1);
        }

        // allow sleep button
        this.allowSleep.oninput =e=> this.Reload(1, program.Save());

        // resize window size to fit inner width while preserving aspect
        const width = program.resize ? 
            Math.min(program.width*(program.info.scale||1), innerWidth-6) :
            program.width;
            
        // set window width, height, and scale
        this.style.width                = width;
        this.iframeWrapper.style.height = width * program.height / program.width;
        this.scale = width / program.width;
        
        // announce game when first opened
        OS13k.Speak(program.name);
        
        // track if programs are loading during startup
        loading += !finishedStartup;
        
        // create iframe
        this.CreateFrame();
        
        // set active and clamp
        this.SetActive(1, 1);
    }
    
    WriteToFrame(code)
    {
        // open iframe to write code
        const iframeDocument = this.iframeContent.document;
        iframeDocument.open();

        // set on error now to catch errors on load
        this.iframeContent.onerror =(message, source, lineno, colno, e)=>((this.errorText.value = e), true);
        (!this.program.userProgram || safeCode) && iframeDocument.write(code);
        iframeDocument.close();
    }
    
    CreateFrame()
    {
        // wait for frame to load
        const loadFrame =()=>
        {
            // check for special extensions
            program.userProgram && (program.info.code.trim()[0] != '<' ?
                program.isDweet = !( program.isShader = program.info.code.search(/void\s+mainImage/) >= 0) :
                program.isDweet = program.isShader = 0);
            const hasExtension = program.isDweet || program.isShader;

            // check if code is safe to execute
            const codeIsSafe = !this.program.userProgram || safeCode;

            // only dweets and shadertoys can do screenshots
            this.screenshot.disabled = !hasExtension || !codeIsSafe;

            // show error messages from user code
            program.userProgram && (iframeContent.onerror =(message, source, lineno, colno, e)=>((this.errorText.value = e), true));

            // get iframe content and document (will fail if cross site)       
            const iframeDocument = iframeContent.document;
            const iframeText = program.userProgram ? program.info.code :
                program.help || iframeDocument.body
                    [hasExtension ? 'innerText' : 'innerHTML']
            
            // set help/code display
            program.userProgram || (this.codeText.value = iframeText);

            // pass OS13k and zzfx to iframe
            iframeContent.OS13k = OS13k;
            iframeContent.zzfx = zzfx;
            iframeContent.zzfxG = zzfxG;

            // set to black if code is not safe
            codeIsSafe || (iframeDocument.body.style.background = '#000');

            // check for extensions
            if (hasExtension && codeIsSafe) try
            {
                // create canvas
                this.WriteToFrame(
                    `<canvas id=c width=1920 height=1080 style=width:100%;background:${
                    program.isShader ?
                    '#000' : '#fff' }>`);

                // set body style
                iframeDocument.body.style =
                    'background:#111;' +
                    'overflow:hidden;' +
                    'margin:0;' +
                    'display:flex;' +
                    'align-items:center';
                    
                // loop protection for user dweets
                const code = program.userProgram && !program.isShader? 
                    'OS13kL=0;' +
                    iframeText.replace(
                        /(for\s*\((?!\s+of\s+)(?!\s+in\s+)[^;]*;[^;]*;|while\s*\()\s*(\S)/g, (a, b, c)=> b && c ? b +
                        `++OS13kL>1e5&&(u=e=>{throw'Timed out!'})()` +
                        (c == ')' ? '' : ',') + c : a ) : iframeText;

                // set iframe link to parent window
                iframeContent.OS13kW = this;

                // show error messages from user code (must be set again here because it got wiped out)
                program.userProgram && (iframeContent.onerror =(message, source, lineno, colno, e)=>((this.errorText.value = e), true));

                // create dweet or shader program
                iframeContent.eval(
                    'frame=0;' +
                    (program.isShader ? // preserve buffer for user programs for screenshot
                        `x=c.getContext('webgl2',${program.userProgram ? '{preserveDrawingBuffer:true}' : ''});` +
                        'onmousemove=e=>e.buttons&&(X=e.x,Y=c.height-e.y);' +
                        'onmousedown=e=>(X=Z=e.x,Y=W=c.height-e.y);' +
                        'onmouseup=e=>Z=W=0;' +
                        's=parent.OS13k.CreateShader(c,`' + code + '`);' +
                        'u=t=>(' +
                        'c.width=innerWidth,' +
                        'c.height=innerHeight,' +
                        'parent.OS13k.RenderShader(c,s,t,frame++,X,Y,Z,W));' +
                        'OS13k_=t=>requestAnimationFrame(OS13k_,' +
                            (program.awake || !program.info.allowSleep? '' : 
                                't<1e3|parent.document.activeElement==OS13kW&&') +
                            'u(t/1e3));' +
                            'OS13k_(X=Y=Z=W=0)'
                        :
                        'x=c.getContext`2d`;' +
                        'S=Math.sin;' +
                        'C=Math.cos;' +
                        'T=Math.tan;' +
                        'OS13k=parent.OS13k;' +
                        'zzfx=parent.zzfx;' +
                        'R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;' +
                        'u=t=>{' + code + '\n};' +

                        // update, limit framerate and fix time glitches
                        'OS13k_=t=>(requestAnimationFrame(OS13k_),' +
                            (program.awake || !program.info.allowSleep? '' : 
                                't<1e3|parent.document.activeElement==OS13kW&&') +
                            't>OS13kF-2&&'+
                            'u(((t=frame++/60)*60|0==frame-1)&&t>0?t+1e-6:t, OS13kF=Math.max(OS13kF+1000/60,t)));' +
                            'OS13k_(OS13kF=0)'));
            }
            catch (e)
            {
                // set error text and throw error if not user code
                this.errorText.value = e && e.message ? e.message : e;
                if (!program.userProgram) throw e;
            }
            
            // mouse down on iframe to load unsafe code, and call normal mousedown
            codeIsSafe || (iframeContent.onmousedown =e=>(this.Reload(safeCode = 1), onmousedown(e)));
            
            // prevent iframes context menu and drop events
            iframeContent.ondrop = iframeContent.ondragover = iframeContent.oncontextmenu =()=>false;
            
            // add taskbar icon if it doesnt exist and set active (from being reloaded)
            this.taskbarIcon || (this.taskbarIcon = new OS13kTaskbarIcon(program, this)).SetActive();

            // make visible
            this.style.visibility = this.iframe.style.visibility = 'visible';
            
            // update loading
            loading = loading && --loading
            
            // update startup routine
            OS13kSystem.UpdateStartup();

            // listen for reload from iframe
            program.userProgram && (iframe.onload =()=> reloadCount++ && this.Reload(1, 0));
        }
        
        // create iframe
        const iframe = this.iframe = this.iframeWrapper.appendChild(document.createElement('iframe')); 
        const iframeContent = this.iframeContent = iframe.contentWindow;
        const program = this.program;
        let reloadCount = 0;
        iframe.id = 'frame';
        
        // load src, force pages to be refreshed
        if (program.userProgram)
        {
            // clear error text
            this.errorText.value = '';

            // allow code editing
            this.codeText.onkeydown =e=> !e.altKey ||
                (e.keyCode == 13 && this.SetCode(this.codeText.value), e.keyCode != 18);
            this.codeText.oninput =e=> this.liveEdit.checked && this.SetCode(this.codeText.value);

            // reload when mouse pressed if not safe
            this.codeText.onmousedown =e=> (safeCode || 
                this.liveEdit.checked && this.Reload(safeCode = 1), e);

            // write code to iframe
            this.WriteToFrame(program.info.code);

            // load frame immediatly
            loadFrame();
        }
        else
        {
            this.iframe.src = program.src + '?v22';
            iframe.onload =()=> loadFrame();
        }
    }
        
    SetCode(code)
    {
        // set code when changed
        this.program.info.code = code;
        this.codeSize.innerHTML = code.length;
        this.program.Save();

        // reset iframe
        safeCode = 1;
        this.iframeWrapper.removeChild(this.iframe);
        this.CreateFrame();
    }
    
    Open(target, x, y)
    {
        // set active if not copy button
        target.id != 'C' && this.SetActive();
        
        // set grab window if name is target
        if (target == this.name)
        {
            // set grab window
            grabWindow = this;
            
            // use grabbing cursor
            background.style.cursor = taskbar.style.cursor = 'grabbing';
            
            // prevent anything from getting focus white grabbing
            desktop.style.pointerEvents = 'none';

            // save grab offset
            const rect = this.getBoundingClientRect();
            grabOffsetX = x - rect.left;
            grabOffsetY = y - rect.top;
            
            OS13kSystem.Sound(soundGrabStart)
            
            // stop event propogation
            return false;
        }
        
        // check for title bar buttons
        target.id == 'full'        && this.FullScreen();
        target.id == 'reload'      && this.Reload();
        target.id == 'close'       && this.Close();
        target.id == 'shrink'      && this.Resize(this.scale - .2, soundShrink);
        target.id == 'grow'        && this.Resize(this.scale + .2, soundGrow);
        (target.id == 'help' | target.id == 'code') && this.ShowCode();
        
        // allow event to contiue if it is input
        return /^(?:input|textarea)$/i.test(target.localName);
    }
    
    Resize(scale, sound)
    {
        sound && OS13kSystem.Sound(sound);
    
        // change size of window while preserving aspect
        const wNew = OS13k.Clamp(this.program.width * scale, 250, 1920);
        const hNew = this.program.height * (this.scale = wNew / this.program.width);
        
        // get old width
        const w = parseFloat(this.style.width);
        
        // offset window position for new width
        this.style.left = parseFloat(this.style.left) + w - wNew;
        
        // set new size
        this.style.width = wNew;
        this.iframeWrapper.style.height = hNew;
    
        // update program info
        this.program.Save();
    }
    
    SetActive(active=1, clamp)
    {
        // close menus when window is set active
        OS13kSystem.CloseMenus();
        
        // set style, dim non active windows
        this.className = active? 'activeWindow' : '';
        this.titlebar.className = 'titlebar titlebar' + 
            (active? 'Active' : '') + 
            (this.program.sticky ? 'Sticky' : this.program.userProgram ? 'User' : '');
        this.iframeWrapper.style.filter = active || this.program.awake ? 
            '' : 'saturate(.7)brightness(.7';

        // check if active
        if (!active) return;
        
        // save start program if finished startup and not sticky
        finishedStartup && !this.program.sticky && 
            (startProgramId = this.program.id, OS13k.Save());

        // set focus to iframe and set active frame to prevent user input being set
        loading || document.activeElement != this && this.iframeContent && this.iframeContent.focus(lastActiveFrame = this.iframe);

        // clamp window to screen
        const rect = this.getBoundingClientRect();
        clamp && (
            this.style.left = OS13k.Clamp(rect.x, 0, innerWidth - rect.width,
            this.style.top = OS13k.Clamp(rect.y, taskbarHeight, 
                Math.max(taskbarHeight, innerHeight - rect.height))));

        if (activeWindow != this)
        {
            // deactivate old window and set this one active
            activeWindow && activeWindow.SetActive(0);
            activeWindow = this;

            // move z to top
            this.style.zIndex = ++topZ;

            // show menu buttons
            const SetButtonVisibility = (button, visible)=>button.style.display = visible ? '' : 'none';
            SetButtonVisibility(buttonFullScreen, this.program.full);
            SetButtonVisibility(buttonCode,       this.program.code);
            SetButtonVisibility(buttonHelp,       this.program.help);
            SetButtonVisibility(buttonReload,     this.program.reload);
            SetButtonVisibility(buttonResetSize,  this.program.resize);

            // set taskbar icon active if it exists
            // it will not have been created yet if frame is loading
            this.taskbarIcon && this.taskbarIcon.SetActive();
            
            !grabWindow && hadInput && 
                OS13kSystem.Sound(this.activeCount ? soundActive : soundOpen);
            this.activeCount++;
        }
    
        return false;
    }
    
    FullScreen()
    {
        // check if full screen allowed
        if (!this.program.full) return;

        // reload code if it wasnt safe yet and set it is safe
        safeCode || this.Reload(safeCode = 1);
        
        // set full screen
        this.iframeWrapper.webkitRequestFullScreen &&
            this.iframeWrapper.webkitRequestFullScreen();
        this.iframeWrapper.mozRequestFullScreen &&
            this.iframeWrapper.mozRequestFullScreen();
            
        OS13kSystem.Sound(soundFullScreen);
        OS13k.Trophy('OS13k','üïπÔ∏è','Pro Gamer','Went Full Screen');
    }
    
    ShowCode(silent)
    {
        // toggle showing code
        this.codeDisplay.style.display = 
            (this.showCode = !this.showCode) ? 'inline' : '';
        
        // set active and clamp to window
        activeWindow.SetActive(1, 1);

        silent || OS13kSystem.Sound(this.program.help ? soundHelp : soundCode);
        this.program.help || OS13k.Trophy('OS13k','üë®‚Äçüíª','Hacker','Viewed Code');
    }
    
    Reload(silent, clamp=1)
    {
        // update program info
        this.program.userProgram && (this.program.info.code = this.codeText.value);
        this.program.Save();
        
        // set active and clamp to window
        activeWindow.SetActive(1, clamp);
        
        // reload program or reload iframe and set invisible
        this.iframeContent &&
            this.iframeContent.OS13kReload ?
            this.iframeContent.OS13kReload() :
            this.program.userProgram ?
                this.SetCode(this.program.info.code) :
            this.iframeContent.location.reload(this.iframe.style.visibility = '');
        
        silent || OS13kSystem.Sound(soundReload);
    }
    
    Close()
    {
        // remove start program if closed
        this.program.id == startProgramId && (startProgramId = '');
            
        // save info and set closed
        this.program.Save(0);
        
        // invalidate window after info is saved
        this.program.window = 0;
        
        // remove taskbar icon and self
        this.taskbarIcon && this.taskbarIcon.remove();
        this.remove();
        
        OS13kSystem.Sound(soundClose);
    }
} // OS13kWindow
customElements.define('w-', OS13kWindow);

///////////////////////////////////////////////////////////////////////////////
// OS13kTaskbarIcon - icon on taskbar that can be used as shortcut

class OS13kTaskbarIcon extends HTMLElement
{
	constructor(program, windowOrMenu)
    {
        super();
        
        // create icon
        this.className = 'taskbarIcon';
        this.program = program;
        this.windowOrMenu = this.menu = windowOrMenu;
        this.SetName();
        
        // add to taskbar
        taskbarSpace.before(this);
    }

    SetName()
    {
        this.innerHTML = '<div style=pointer-events:none>' + (this.program.icon || 'üí†');
        this.title = this.program.name;
    }
    
    Open()
    {
        // set active
        this.SetActive();
        
        // allow main document focus only if load icon
        return this == loadIcon;
    }
    
    SetActive(active=1)
    {
        // set window active and clamp
        active && this.windowOrMenu.SetActive(1, 1);
    
        // load icon cant be active taskbar item
        if (this == loadIcon) 
        { OS13kSystem.Sound(soundMenu, .5); return;}
        
        // set active style
        this.className = 'taskbarIcon ' + (active ? 'taskbarIconActive' : '');
        
        // check if active
        if (!active) return;
            
        // unselect old taskbar icon
        activeTaskbarIcon && activeTaskbarIcon != this &&
            activeTaskbarIcon.SetActive(0);

        // set this to be active taskbar icon
        activeTaskbarIcon = this;
    }
    
} // OS13kTaskbarIcon
customElements.define('i-', OS13kTaskbarIcon);

///////////////////////////////////////////////////////////////////////////////
// OS13kTrayIcon - icon on taskbar tray for OS shortcuts

class OS13kTrayIcon extends HTMLElement
{
	constructor()
    {
		super();
        
        // create tray icon and add it
        this.className = 'trayIcon';
        tray.appendChild(this);
    }
    
    SetProgram(program)
    {
        // set program, title, and icon
        this.program = program;
        this.title = program.name;
        
        // create span for icon so analyser will work
        const icon = this.appendChild(document.createElement('span'));
        icon.innerHTML = program.icon;
        icon.style.pointerEvents = 'none';
    }
    
    Open() { this.program ? this.program.Toggle() : this.functionCall(); }
} // OS13kTrayIcon
customElements.define('t-', OS13kTrayIcon);

///////////////////////////////////////////////////////////////////////////////
// Mouse Input

{
onmousedown=e=>
{
    // set there has been user input
    hadInput = 1;
    
    // check if load icon is target while programs menu was visible
    if (e.target == loadIcon && e.target.windowOrMenu.style.visibility)
    {
        // close menus because they were open
        OS13kSystem.CloseMenus();
        
        // reactivate active window
        activeWindow && activeWindow.SetActive();
        
        // prevent main document from taking focus
        return false;
    }
    
    // close menus on mouse down
    OS13kSystem.CloseMenus();

    // reset program menu position
    programsMenu.style.left = 0;
    programsMenu.style.top = taskbarHeight;

    // prevent stuck grab (from tabbing to another window while grabbing)
    if (grabWindow) return onmouseup(e);
    
    // get orignal target
    const originalTarget = e.originalTarget || e.path[0];
    
    // check if not left mouse button
    if (e.button)
    {
        // dont allow right click on buttons
        if (originalTarget.localName == 'button')
            return false;

        // check for right mouse button
        if (e.button & 2)
        {
            const target = e.target.window || e.target;

            // set target active, use load icon if no valid target
            (target.SetActive ? target : loadIcon).SetActive();

            // get which menu to open
            const targetMenu = e.target.menu ? (OS13kSystem.Sound(soundMenu, .5), menu) : programsMenu;

            // show context menu
            targetMenu.style.left = e.x;
            targetMenu.style.top  = e.y;
            targetMenu.style.visibility = 'visible';
        }
    
        // allow main document to take focus
        return;
    }

    // open window or reactivate if no valid target
    return e.target.Open ? e.target.Open(originalTarget, e.x, e.y) :
        activeWindow && activeWindow.SetActive();
}

onmousemove=e=>
{
    grabWindow &&
    (
        // update grab position
        grabWindow.style.left = e.x - grabOffsetX,
        grabWindow.style.top = e.y - grabOffsetY
    );
    
    // handle mouse move
    e.target.Move && e.target.Move();
}

onmouseup=()=>
    // set grab window active, no clamp, and set cursor to default, unset grab
    grabWindow && (grabWindow.program.Save(),
    OS13kSystem.Sound(soundGrabEnd),
    grabWindow.SetActive(1, 0),
        background.style.cursor = taskbar.style.cursor
            = desktop.style.pointerEvents = grabWindow = '');

// prevent default right click context menu
oncontextmenu=()=> false;
            
} // mouse input

///////////////////////////////////////////////////////////////////////////////
// Drag and Drop

// prevent default drop events
ondragover =e=>false;

// allow drag and drop code into editor
ondrop =e=>
{
    const originalTarget = e.originalTarget || e.path[0];
    if (originalTarget.id == 'codeText' && e.target.program.userProgram)
    {
        // read file and reload
        const target = e.target;
        const reader = new FileReader();
        reader.readAsText(e.dataTransfer.files[0], 'UTF-8'); 

        // set code and set active
        reader.onload =e=>target.SetActive(1,0,target.SetCode(target.codeText.value = e.target.result));
    }
    return false;
}

///////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth

// play a zzfx sound
var zzfx = (...parameters)=>OS13k.PlaySamples(zzfxG(...parameters)),

 // generate zzfx samples
zzfxG = (volume = 1, randomness = .05, frequency = 220, attack = 0, sustain = 0, release = .1, shape = 0, shapeCurve = 1, slide = 0, deltaSlide = 0, pitchJump = 0, pitchJumpTime = 0, repeatTime = 0, noise = 0, modulation = 0, bitCrush = 0, delay = 0, sustainVolume = 1, decay = 0, sampleRate = defaultSampleRate, b = [])=>
{
    attack = 99 + attack * sampleRate;
    sustain *= sampleRate;
    release *= sampleRate;
    decay *= sampleRate;
    delay *= sampleRate;
    
    for(
        // init parameters and helper functions
        let PI2 = Math.PI*2,
        random =r=> 1 + r*2*Math.random() - r,
        sign =v=> v>0? 1 : -1,
        length = attack + decay + sustain + release + delay,
        startSlide = slide *= 500 * PI2 / sampleRate**2,
        startFrequency = frequency *= random(randomness) * PI2 / sampleRate,
        modPhase = sign(modulation) * PI2/4,
        t=0, tm=0, i=0, j=1, r=0, c=0, s=0;
    
        // loop and generate waveform
        i < length; b[i++] = s)
    {
        if (++c>bitCrush*100)                            // bit crush
        {
            c = 0;                                       // reset bit crush
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation * PI2 / sampleRate - modPhase); // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
                Math.sin((s%PI2)**3) :                   // 4 noise
                Math.max(Math.min(Math.tan(s), 1), -1):  // 3 tan
                1-(2*s/PI2%2+2)%2:                       // 2 saw
                1-4*Math.abs(Math.round(s/PI2)-s/PI2):   // 1 triangle
                Math.sin(s);                             // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * (                              // envelope
                i < attack ? i/attack :                  // attack
                i < attack + decay ?                     // decay
                1-((i-attack)/decay)*(1-sustainVolume) : // decay falloff
                i < attack + decay + sustain ?           // sustain
                sustainVolume :                          // sustain volume
                i < length - delay ?                     // release
                (length - i - delay)/release *           // release falloff
                sustainVolume :                          // release volume
                0);                                      // post release

            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i - delay|0]/2) : s;                   // sample delay
        }

        t += random(noise);                          // noise
        tm += random(noise);                         // modulation noise
        frequency += slide += deltaSlide             // frequency slide
            * 500 * PI2 / sampleRate**3;             // apply sample rate

        if (j && ++j > pitchJumpTime * sampleRate)   // pitch jump
        {
            frequency += pitchJump                   // apply pitch jump
                * PI2 / sampleRate;                  // apply sample rate
            startFrequency += pitchJump              // also apply to start
                * PI2 / sampleRate;                  // apply sample rate
            j = 0;                                   // reset pitch jump time
        }

        if (repeatTime && ++r > repeatTime* sampleRate) // repeat
        {
            frequency = startFrequency;               // reset frequency
            slide = startSlide;                       // reset slide
            r = 1;                                    // reset repeat time
            j = j || 1;                               // reset pitch jump time
        }
    }
    
    return b;
},

//! ZzFXM (v1.0.0) | (C) Keith Clark | MIT | https://github.com/keithclark/ZzFXM
zzfxM = (instruments, patterns, sequence, speed = 6, panning) => {
  let SAMPLE_RATE = 44100;                  // this must match ZzFX sample rate
  let BPM = 125                             // beats per min - always 125
  let ticksPerSecond = 1000 / (2500 / BPM);
  let tickRowSize = SAMPLE_RATE / (ticksPerSecond / speed) | 0;
  let bufferStart = 0
  let bufferPos;
  let bufferOffset;
  let sample;
  let sampleCache = {};
  let sampleCacheKey;
  let sampleByte;
  let sampleOffset;
  let noteIndex;
  let pan;
  let attenuation;
  let instrument;
  let instrumentParams;
  let period;
  let leftChannelBuffer=[];
  let rightChannelBuffer=[];

  sequence.map(patternIndex => {

    // Walk over each channel of the pattern.
    patterns[patternIndex].map((channel, channelIndex) => {

      // for each channel we need to reset the buffer offset so we can layer
      // sample data.
      bufferOffset = bufferStart;

      // Determin the panning value for this channel. If no panning was provided
      // we fallback to alternating each song channel between the left and right
      // speakers (even channel indexes will come from the left speaker, odd
      // from the right speaker)
      pan = panning ? .5 + (panning[channelIndex] || 0) / 2 : channelIndex & 1;

      // Read the channel data.
      for (noteIndex = 0; noteIndex < channel.length; bufferOffset += tickRowSize) {

        // If there's a new instrument, set it.
        instrument = channel[noteIndex++] || instrument;

        // If we have a period then we need to play a note using the current
        // instrument.
        period = channel[noteIndex++];
        if (period) {
          // Reset the attenuation and sample buffer offset so we can play a new
          // note.
          attenuation = sampleOffset = 0;

          // Create a unique key for this sample (this will coerced to a string)
          sampleCacheKey = [period,instrument];

          // If we haven't done so already, build and cache the ZzFX sample for
          // the current period and instrument. Without caching the browser will
          // will hang.
          if (!sampleCache[sampleCacheKey]) {
            instrumentParams = [...instruments[instrument - 1]];
            instrumentParams[2] *= 2 ** ((period - 12) / 12);
            sampleCache[sampleCacheKey] = zzfxG(...instrumentParams);
          }

          sample = sampleCache[sampleCacheKey];
        }

        // Update the channel attenuation value. We'll use this to control the
        // volume when rendering the sample slice for this row.
        attenuation = (channel[noteIndex++] / 64) || attenuation;

        // Fill the left and right audio buffers with data for this channel.
        // If we have sample data (a new note or the remaining sample data from
        // the previous row) then we attenuate it for the left channel using the
        // channel panning value and again for the right channel. The values are
        // then merged with the values already in the buffer. If the buffer is
        // empty we need to prefill it with `0` values for periods of slience to
        // prevent the clicking and popping noises caused by `undefined` values
        // in some browsers.
        for (bufferPos = bufferOffset; bufferPos < bufferOffset + tickRowSize; bufferPos++) {
          sampleByte = sample && (sample[sampleOffset++] * (1 - attenuation)) || 0;
          leftChannelBuffer[bufferPos] = (leftChannelBuffer[bufferPos] || 0) + sampleByte * (1 - pan);
          rightChannelBuffer[bufferPos] = (rightChannelBuffer[bufferPos] || 0) + sampleByte * pan;
        }
      }

    });

    bufferStart = bufferPos;
  });

  return [leftChannelBuffer, rightChannelBuffer];
}
///////////////////////////////////////////////////////////////////////////////
// Start OS13k!

OS13kSystem.Start();

///////////////////////////////////////////////////////////////////////////////
// Mobile Support OPTIONAL

// save if user was touching
let wasTouching;
    
if (typeof ontouchstart != 'undefined')
{
    // remove hovers, they get stuck on mobile
    const RemoveHovers=e=>
    {
        [...e.styleSheets].map(sheet=>{
        for(let i = sheet.rules.length; i--; )
            sheet.rules[i].selectorText &&
            sheet.rules[i].selectorText.match('hover') &&
            sheet.deleteRule(i)});
    }
    RemoveHovers(document);
                
    // handle touch event
    const ProcessTouch=e=>
    {
        // check if touching
        const touching = e.touches.length;
        if (touching)
        {
            // set event pos
            e.x = e.touches[0].clientX;
            e.y = e.touches[0].clientY;

            // pass event to mousemove and give focus to main window
            window.focus(onmousemove(e));
        }

        // pass event to mouse down, prevent closing folders
        touching & !wasTouching & !e.target.folder && onmousedown(e);

        // pass event to mouse up
        !touching & wasTouching && onmouseup(e);

        // set was touching
        wasTouching = touching;
        
        // remove hovers from active window
        activeWindow && RemoveHovers(activeWindow.shadowRoot);
        
        // prevent default if not edit area
        const originalTarget = e.originalTarget || e.path[0];
        return originalTarget.parentElement.id == 'codeOptions' || 
            originalTarget.parentElement.parentElement && originalTarget.parentElement.parentElement.id == 'codeOptions' || 
            originalTarget.parentElement.id == 'codeDisplay' || !e.cancelable;
    }
    
    // set touch events
    ontouchstart = ontouchmove = ontouchend = ontouchcancel = ProcessTouch;
};

</script>