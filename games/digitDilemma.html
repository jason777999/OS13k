<!--

Digit Dilemma Plus - A Logic Puzzle Mashup of Sokoban and 2048
By Frank Force 2020

Push numbers until none are left. All puzzles are solvable!
`
Arrows = Move
Space = Undo
R = Randomize

-->
<title>Digit Dilemma Plus - Push numbers until none are left. Arrows=Move Space=Undo R=Randomize</title>
<body bgcolor=#000 id=B><script>

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// ==/ClosureCompiler==

// How to minify...
// 1. Closure
// 2. Remove white space, Terser recommended
// 3. Rework variables, remove let, remove if possible
// 4. Replace " with `
// 5. Regpack, don't replace B
// 6. Put it in <body bgcolor=#000 onload=""id=B>

setInterval(
x=>
{
    // no pieces left or randomize on R
    if (!pieceCount || controls[45])
    {
        level&&level>OS13k.GetTrophy('Digit Dilemma','High Score')&&OS13k.Trophy('☻ #'+level,'Digit Dilemma','High Score',level)

        // go up a level when there are no pieces left
        pieceCount || (size = ++level<11?4+level:15);

        for(o=0;!o;)
        {
            // generate puzzle
            o = 1e5;

            // clear playfield and add random blockers
            for(i=0; i<size*size; ++i)
                playArea[i] = (i+1)%size<2 || i%(size*size-size)<size || !R(19) ? 
                    -1 : 0;

            for(pieceCount = level; --o && pieceCount;)
            {
                // get a random piece
                x = R(size);
                y = R(size);
                
                // try again if -1 or 9 (to prevent 10s) or if empty and not first and large chance
                if (playArea[r = i=size*y+x] < 9 & playArea[i] >= 0 && (pieceCount == level | !R(999) || playArea[i]))
                {
                    // random direction
                    j = k = 0;
                    R(2) ? k = R(2)*2-1 : j = R(2)*2-1;

                    // save location
                    q = i - size*j-k;

                    // must be empty on push side
                    if (!playArea[i + size*j+k])
                    {
                        // move farther with randomness
                        for(;R(19) && !playArea[(i+=size*j+k) + size*j+k];x+=k)y+=j

                        // first piece must set player pos
                        pieceCount < level || (playerX = x+k*2, playerY = y+j*2);
                        
                        // check that it is possble to get to pushing location
                        playAreaFill = [...playArea];
                        if (C(x+k*2, y+j*2))
                        {
                            // make move
                            if (playArea[q] > 0 && playArea[q] != playArea[r])
                                // bump into a piece
                                playArea[i + size*j+k] = playArea[r], playArea[r] = 0; 
                            else if (!R(5) && pieceCount < level)
                                 // push into blocker (not for first piece)
                                playArea[i + size*j+k] = playArea[r], playArea[r] = -1; 
                            else // split
                                playArea[i + size*j+k] = ++playArea[r], --pieceCount;              
                            playerX = x+k*2, playerY = y+j*2;
                        }
                    }
                }
            }
         }

         // randomize player start
        for(;playAreaFill = [...playArea], !C(x = R(size), y = R(size)););
        rewind = [[[...playArea], playerX = x, playerY = y]];
    }
    else if (movePos)
    {
        // update moves
        n = playArea[movePos + moveOffset];
        if (moveOffset == 1 & movePos%size == size-1 || 
            moveOffset == -1 & movePos%size == 0)
            // prevent wrapping
            movePos = 0;
        else if (n == playArea[movePos])
        {
            // hit same number, join 
            playArea[movePos + moveOffset] = n-1;
            playArea[movePos] = movePos = 0;
        }
        else if (n < 1)
        {
            // open or wall, move into it
            playArea[movePos + moveOffset] = playArea[movePos];
            playArea[movePos] = 0;
            movePos = n<0 ? 0 : movePos + moveOffset;
        }
        else
            movePos = 0;
    }
    else
    {
        // player controls
        x = controls[2] - controls[0];
        y = x ? 0 : controls[3] - controls[1];

        // rewind
        if (controls[-5] && rewind.length)
            [playArea, playerX, playerY] = rewind.pop();

        // player movement
        // check if moving into empty space or push a number
        if (!playArea[i = size*y+x + size*playerY+playerX])
        {
            // empty space
            playArea[size*playerY+playerX] = 0;
            playerX += x;
            playerY += y;
            playArea[size*playerY+playerX] = -2;
        }
        else if (playArea[i] > 0) // push number
            rewind.push([[...playArea], playerX, playerY, 
                movePos = i, moveOffset = x + y*size]);
    }
    
    // draw the play area
    o = `<pre><b><big><big><big><big><center>`;
    for(pieceCount = i=0;i<size*size;controls = [0,0,0,0])
        o +=
            `<span style=color:hsl(${-40*playArea[i]},${
            playArea[i]>0 ? pieceCount = 80 : 0}%,${
            playArea[i]>0 ? 50 : 9-playArea[i]*46}%)>${ 
            (playArea[i]>0 ? playArea[i] : `·#☻`[-playArea[i]] )
            }${++i % size ? `` : `\n`}`;
            
    B.innerHTML = o + '<span style=color:#fff>' + level;
}, 16);

let level=0, pieceCount=0, movePos=0, playArea = [],

R=x=>(Math.random()*1e9|0)%x,

// check if it is possible to get to player pos
C =(x, y)=> playAreaFill[size*y+x] ? 0 : x == playerX & y == playerY ||
    (playAreaFill[size*y+x] = 1)&C(x+1,y)|C(x-1,y)|C(x,y-1)|C(x,y+1);
        
onkeydown = x=> controls[x.keyCode-37] = 1;

// remove from minified
let size, playerX, playerY, playAreaFill, rewind, moveOffset, controls;

</script>