<head>
<title>OS13k - A tiny pseudo operating system for JS13k</title>
<meta charset=utf-8>
<style>
*    { font-family:arial; }
body { overflow:hidden; background:linear-gradient(#223,#322); }
.title
{
    font-size:300;
    font-family:impact;
    color:#0002;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    user-select:none;
    pointer-events:none;
}
</style>
<template id=templateIcon>
<style>
:host
{
    position:absolute;
    display:flex;
    align-items:center;
    flex-direction:column;
    user-select:none;
    pointer-events:auto;
    cursor:grab;
}
.icon
{
    width:64;
    height:64;
    font-size:42;
    background:linear-gradient(#fff,#999);
    border-radius:9px;
    box-shadow:4px 4px 5px;
    overflow:hidden;
    white-space:nowrap;
    pointer-events:none;
    display:flex;
    align-items:center;
    justify-content:center;
}
.name
{
    position:absolute;
    top:70;
    text-align:center;
    font-size:17;
    color:#fff;
    text-shadow:1px 1px 5px #000;
}
</style>
</template>
<template id=templateWindow>
<style>
:host
{
    position:absolute;
    user-select:none;
    display:flex;
    flex-direction:column;
    box-shadow:9px 9px 9px;
    background:#000;
    border:2px solid;
    overflow:hidden;
    display:block;
}
.frame
{
    position:relative;
    width:100%;
    height:100%;
    border:none;
    background:#fff;
    overflow:hidden;
}
.titleBar
{
    height:44;
    font-size:30;
    display:flex;
    align-items:center;
    white-space:nowrap;
}
.name         { width:100%; height:100%; cursor:grab; }
.folder       { background:#222; }
.full         { height:100%; font-size:28; }
.close        { height:100%; font-size:40; }
.full:hover   { background:#fff; }
.close:hover  { background:#f00; }
</style>
</template>
</head>
<body>
<span id=os13kDesktop></span>
<span class=title>OS13k</span>
<script>

'use strict';

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs OS13k, OS13kIcon, OS13kWindow, zzfx, zzfxV
// @js_externs _OS13k.Medal, _OS13k.GetKeyDirection
// @js_externs _OS13k.CreateShader, _OS13k.RenderShader, _OS13k.CreateCanvas
// @js_externs _OS13k.PlaySamples, _OS13k.SetVolume
// @js_externs _OS13k.PlaySeedSound, _OS13k.GetSeedSound
// @js_externs _OS13k.Random, _OS13k.randomSeed 
// @js_externs _OS13k.Clamp, _OS13k.Percent, _OS13k.Lerp
// @js_externs iframeContent.OS13k, iframeContent.OS13kStart, iframeContent.zzfx
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==

/////////////////////////////////////////////////////////////////////////////
// OS13k Desktop

const desktopLayout = 
[
{name:'Help', icon:'❓', src:'help.html?9', open:1, width:380, height:340},
{name:'Code Info', icon:'👨‍💻', src:'codeInfo.html?2'},
{name:'System', icon:'⚙️', folder:
[
    {name:'Test', icon:'😄', src:'system/test.html?5'},
]},
{name:'Games', icon:'🎮', folder:
[
    {name:'Lava Rush', icon:'🌋', author:'Jeremy Burns', src:'games/lavaRush.html?4', width:640, height:400, background:'#000'},
    {name:'Sn1ke', icon:'👀', src:'games/sn1ke.html', author:'Codegolf Team', width:450, height:330, hideWhenClosed:1},
    {name:'Tetris', icon:'🆃', author:'Veubeke', src:'games/tetris.html', width:340, height:430},
    {name:`Queen's Gambit`, icon:'<span style=color:#f0f>♛</span>', src:'games/queensGambit.html?1', width:1290, height:720},
    {name:'Free Cell', icon:'♠️', src:'games/freeCell.html', width:800, height:1e3, hideWhenClosed:1},
    {name:'Digit Dilemma', icon:'<span style=font-family:monospace>☻</span>', src:'games/digitDilemma.html'},
    {name:'Hue Jumper', icon:'🌲', src:'games/hueJumper.html', width:1290, height:720},
]},
{name:'Utilities', icon:'🔧', folder:
[
    {name:'Photo Booth', icon:'📸', src:'utilities/photoBooth.html', width:1380, height:600},
    {name:'Unicode Toys', icon:'𝖀', author:'Xem', src:'utilities/unicodeToys.html', width:500, height:800},
    {name:'Mini Shadertoy', icon:'𝓢', src:'utilities/miniShadertoy.html', width:340, height:400},
]},
{name:'Toys', icon:'🤖', folder:
[
    {name:'ZzFX Soundboard', icon:'𝐙𝐙', src:'toys/zzfxSoundBoard.html'},
    {name:'Yin Yangs', icon:'☯️', src:'toys/infiniteYinYangs.shader.txt'},
    {name:'Vogel Spiral', icon:'🌀', src:'toys/vogelSpiral.shader.txt?2'},
    {name:'Meta OS13k', icon:'𝐎𝐒', src:'index.html'},
    {name:'ZzArt Landscape', icon:'𝓩', src:'toys/zzart.shader.txt'},
]},
{name:'Dweets', icon:'<b>III</b>', folder:
[
    {name:'Black Hole', icon:'🌌', src:'dweets/blackHole.dweet.js'},
    {name:'Mandelbrot Nebula', icon:'🌟', src:'dweets/mandelbrotNebula.dweet.js'},
    {name:'Bogus Roads', icon:'🛣️', src:'dweets/bogusRoads.dweet.js'},
    {name:'Automatic Breakout', icon:'●', src:'dweets/breakout.dweet.js'},
    {name:'Underwater Cavern', icon:'🌊', author:'Pavel', src:'dweets/underwaterCavern.dweet.js'},
    {name:'City Traffic', icon:'🚌', author:'Tomxor', src:'dweets/cityTraffic.dweet.js'},
    {name:'Train Set', icon:'🚂', author:'jylikangas', src:'dweets/trainSet.dweet.js'},
]},
{name:'Music', icon:'🎶', folder:
[
    {name:'Min Bytes', icon:'<span style=color:#f00>𝓜</span>', width:500, height:500, src:'music/minBytes.html?4'},
]},
{name:'Favorites', folder:[]},
];

os13kDesktop.Focus=()=>
{
    // deavtivate window if desktop is clicked on
    activeWindow && activeWindow.SetActive(0);
    
    // set focus
    this.focus();
}

/////////////////////////////////////////////////////////////////////////////
// OS13k System

class _OS13k
{
    constructor()
    {
        // init web audio
        this.audioContext = new (AudioContext || webkitAudioContext);
        this.audioContext._createBufferSource = this.audioContext.createBufferSource;
        this.audioContext.createBufferSource =
        (s = this.audioContext._createBufferSource())=>
        (
            s.start = s.start || s.noteOn,
            s.stop  = s.stop  || s.noteOff,
            s
        );
        
        // startup os13k
        this.randomSeed = Date.now();
        this.InitDesktop();
        setInterval(this.Update, 99);
    }
    
    InitDesktop()
    {
        // add icons to desktop
        let X = iconGridSizeX/4;
        const AddIcon=p=>
        {
            p.x = X;
            p.y = iconGridSizeX/4; 
            X += iconGridSizeX;
            const icon = new OS13kIcon(p); 
            os13kDesktop.appendChild(icon); 
            p.open && icon.Open();
            return icon;
        }
        for (const i of desktopLayout)
            AddIcon(i);
    }
    
    Update()
    {
        // listen for change in active element
        // this happens when clicking on an iframe
        const activeElement = document.activeElement;
        if (this.lastActiveElement != activeElement)
        {
            if (activeElement.localName == 'os13k-window')
                activeElement.Focus();
            this.lastActiveElement = activeElement;
        }
    }
    
    KeyDirection(keyCode)
    {
        // get direction from wasd or arrow keys
        let x = 0;
        let y = 0;
        if (keyCode == 87 || keyCode == 38) // up
            y += 1;
        if (keyCode == 83 || keyCode == 40) // down
            y -= 1;
        if (keyCode == 68 || keyCode == 39) // right
            x += 1;
        if (keyCode == 65 || keyCode == 37) // left
            x -= 1;
        return {x, y}
    }
    
    Medal(gameName, medalName='', difficulty=0)
    {
        // todo: show popup and unlock medal
    }
    
    PlaySeedSound(seed, lengthScale=1, volume=1, randomness=.05)
    {
        this.randomSeed = seed;
        const R=()=> this.Random();
        const attack = R()**3*lengthScale/2;
        const sustain = R()**3*lengthScale/2;
        const release = R()**3*lengthScale/2;
        const length = attack + sustain + release;
        
        // create random sound
        return zzfx(...
        [
           volume,                               // volume
           randomness,                           // randomness
           R()**2*2e3,                           // frequency
           attack,                               // attack
           sustain,                              // sustain
           release,                              // release
           R()*5|0,                              // shape
           R()**2*3,                             // shapeCurve
           R()<.5?0: R()**3*(R()<.5?-99:99),     // slide
           R()<.5?0: R()**3*(R()<.5?-99:99),     // deltaSlide
           R()<.5?0: R()**2*(R()<.5?-1e3:1e3),   // pitchJump
           R()**2*length,                        // pitchJumpTime
           R()<.5?0: R()*length,                 // repeatTime
           R()<.5?0: R()**4,                     // noise
           R()<.5?0: R()**3*(R()<.5?-9:9),       // modulation
           R()<.5?0: R()**4,                     // bitCrush
           R()<.5?0: R()**3/2,                   // delay
        ]);
    }
    
    PlaySamples(samples, sampleRate=44100)
    {
        // play raw audio sample data
        const buffer = this.audioContext.createBuffer(1, samples.length, sampleRate);
        const source = this.audioContext.createBufferSource();
        buffer.getChannelData(0).set(samples);
        source.buffer = buffer;
        source.connect(this.audioContext.destination);
        source.start();
        return source;
    }
    
    SetVolume(volume) { zzfxV = volume; }
    Speak(text) { speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }
    
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');

        // create a simple pass through vertex shader
        const vertexShader = x.createShader(x.VERTEX_SHADER);
        x.shaderSource(vertexShader,'#version 300 es\nin vec4 p;void main(){gl_Position=p;}');
        x.compileShader(vertexShader);
        
        // create vertex buffer that is a giant triangle to cover the viewport
        const vertexBuffer = x.ARRAY_BUFFER;
        x.bindBuffer(vertexBuffer,x.createBuffer());
        x.bufferData(vertexBuffer,new Int8Array([-3,1,1,-3,1,1]),x.STATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0,2,x.BYTE,0,0,0); // 2D vertex
        
        // check vertex shader for errors
        if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
            return console.log(x.getShaderInfoLog(vertexShader));
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(x.FRAGMENT_SHADER)
        const shaderProgramCode = 
            '#version 300 es\n' +
            'precision mediump float;' +
            'uniform float iTime;' +
            'uniform vec4 iMouse;' +
            'uniform vec3 iResolution;' +
            'uniform sampler2D iChannel0;' +
            'const float pi=' + Math.PI + ';' +
            'const float e='  + Math.E  + ';' +
            'out vec4 outColor;\n' +
            code +
            '\nvoid main()' +
            '{mainImage(outColor,gl_FragCoord.xy);outColor.a=1.;}';
        x.shaderSource(pixelShader, shaderProgramCode)
        x.compileShader(pixelShader);

        // check pixel shader for errors
        if (!x.getShaderParameter(pixelShader, x.COMPILE_STATUS))
            return console.log(x.getShaderInfoLog(pixelShader));

        // create texture
        x.bindTexture(x.TEXTURE_2D, x.createTexture());
        x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL, true); 
        x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.LINEAR);
        
        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    RenderShader(canvas, shaderProgram, time=0)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // set uniforms
        x.uniform1i(x.getUniformLocation(shaderProgram,'iChannel0'), 0);
        x.uniform1f(x.getUniformLocation(shaderProgram,'iTime'), time);
        x.uniform3f(x.getUniformLocation(shaderProgram,'iResolution'),
            canvas.width, canvas.height, 1);
        
        // render shader
        x.viewport(0, 0, canvas.width, canvas.height);
        x.drawArrays(x.TRIANGLE_FAN, 0, 3);
        
        // set texture
        x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, x.RGBA, x.UNSIGNED_BYTE, canvas);
    }
    
    // math functions
    Clamp(a, min=0, max=1) { return Math.min(Math.max(a, min),max); }
    Percent(v, a, b)       { return b-a? this.Clamp((v-a)/(b-a), 0, 1) : 0; }
    Lerp(p, a, b)          { return a + this.Clamp(p, 0, 1) * (b-a); }
    Random(max=1, min=0)
    {
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= this.randomSeed << 13;
        this.randomSeed ^= this.randomSeed >> 17;
        this.randomSeed ^= this.randomSeed << 5;
        return max + (min-max) * (Math.abs(this.randomSeed) % 1e9 / 1e9);
    }
}; // _OS13k

/////////////////////////////////////////////////////////////////////////////
// OS13kIcon

const iconGridSizeX = 99;
const iconGridSizeY = 130;
const titleBarHeight = 46;
let windowOpenOffset = 99;
let topIconZ = 0;

class OS13kIcon extends HTMLElement
{
	constructor({x, y, name, icon, src, width=720, height=405, author, folder, hideWhenClosed, allowMultiple, background})
    {
		super();
        
        // set defaults
        src = src || '';
        name = name || src.split('.')[0];
        icon = icon || ( folder ? '📁' : name[0]? name[0].toUpperCase() : '' );
        background = background || '#000';
        
        // set icon data
		this.shadow = this.attachShadow({mode: 'open'});
        this.name = name;
        this.icon = icon;
        this.src = src;
        this.windowWidth = width;
        this.windowHeight = height;
        this.style.left = x;
        this.style.top = y;
        this.author = author;
        this.hideWhenClosed = hideWhenClosed || folder;
        this.allowMultiple = allowMultiple;
        this.folder = folder;
        this.background = background;
        
        // create shadow root
        this.shadowRoot.innerHTML = templateIcon.innerHTML
            +`<span class=icon>${ icon }</span>`
            +`<span class=name style=pointer-events:none>${ name }</span>`;
    }
    
    Open()
    {
        if (this.os13kWindow && !this.allowMultiple)
        {
            // reopen the old window
            this.os13kWindow.style.display = '';
        }
        else
        {
            // stager open positions
            windowOpenOffset += titleBarHeight;
            if (windowOpenOffset > 300)
                windowOpenOffset = 99+20;

            // open the window
            this.os13kWindow = new OS13kWindow(windowOpenOffset, windowOpenOffset, this);
            os13kDesktop.appendChild(this.os13kWindow);
        }
        
        // set focus to window
        this.os13kWindow.Focus();
    }
    
    MouseDown()
    {
        // focus on icon's window if it exists
        const parent = this.parentElement && this.parentElement.offsetParent;
        parent.Focus ? parent.Focus() : os13kDesktop.Focus();
        
        // create move icon that is temporary copy
        const rect = this.getBoundingClientRect();
        const moveIcon = new OS13kIcon({x:rect.left, y:rect.top, name:this.name, icon:this.icon});
        moveIcon.realIcon = this;
        moveIcon.style.opacity = .5;
        moveIcon.style.zIndex = ++activeWindowZ;
        moveIcon.style.pointerEvents = 'none';
        os13kDesktop.appendChild(moveIcon);
        selected = moveIcon;
    }
    
    MouseUp(e)
    {
        // get rect before it is removed
        const rect = this.getBoundingClientRect();
        
        // get rid of this temporary move icon
        os13kDesktop.removeChild(this);
        
        // get element under mouse
        const element = document.elementFromPoint(e.x, e.y);
        if (!element)
            return;
        
        // try to move icon
        let target = os13kDesktop;
        let x = rect.left;
        let y = rect.top;
        if (element.localName == 'os13k-window')
        {
            // only allow dropping into folders
            if (!element.os13kIcon.folder)
                return;
               
            // prevent dropping on title bar
            const shadowElement = element.shadowRoot.elementFromPoint(e.x, e.y);
            if (shadowElement && shadowElement.id)
                return;
                
            // prevent folder self reference
            const DetectSelfReference=icon=>
            {
                if (icon.os13kWindow == element)
                    return 1;
                if (icon.os13kWindow && icon.os13kWindow.contentWrapper)
                    for( const c of icon.os13kWindow.contentWrapper.children)
                        if (DetectSelfReference(c))
                            return 1;
            }
            if (DetectSelfReference(this.realIcon))
                return alert(`You can't put a folder in itself, silly!`);
            
            // adjust position to local space of parent
            const rect = element.contentWrapper.getBoundingClientRect();
            x -= rect.left;
            y -= rect.top;
            
            // clamp icon to window so icon is not unreachable
            x = OS13k.Clamp(x, -32, rect.width-32);
            y = OS13k.Clamp(y, -32, rect.height-32-titleBarHeight);
            
            // put icon in folder
            target = element;
        }
        else
        {
            // clamp icon to window so icon is not unreachable
            x = OS13k.Clamp(x, -32, innerWidth-32);
            y = OS13k.Clamp(y, -32, innerHeight-32);
        }

        // move icon if it is a different folder
        const targetFolder = target.contentWrapper || target;
        if (targetFolder != this.realIcon.parentElement)
            targetFolder.appendChild(this.realIcon);
        
        // focus on target
        target.Focus();
            
        // set icon position
        this.realIcon.style.left = x;
        this.realIcon.style.top = y;
        this.realIcon.style.zIndex = ++topIconZ;
    }
} // OS13kIcon

customElements.define('os13k-icon', OS13kIcon);

/////////////////////////////////////////////////////////////////////////////
// OS13kWindow

let activeWindow;
let activeWindowZ = 1e7;

class OS13kWindow extends HTMLElement
{
	constructor(x, y, icon)
    {
		super();
        	
        // set window data
        this.os13kIcon = icon;
        this.style.left = x;
        this.style.top = y;
        
        // create shadow root
		this.shadow = this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = templateWindow.innerHTML;
        
        // create title bar
        const titleBar = this.titleBar = document.createElement('div');
        titleBar.className = 'titleBar';
        titleBar.innerHTML = '<span id=titleBar class=name>&nbsp;' 
            + icon.icon + '&nbsp;' 
            + icon.name + '&nbsp;' 
            + (icon.author ? '(' + icon.author + ')' : '')
            + '</span>'
            + (icon.folder ? '' : '<span id=full class=full>&nbsp;🗖&nbsp;</span>')
            + '<span id=close class=close>×</span>';
        this.shadowRoot.appendChild(titleBar);
        
        // create thin black line below title bar
        const titleBarGap = document.createElement('div');
        titleBarGap.style.height = 2;
        this.shadowRoot.appendChild(titleBarGap);

        // create content wrapper
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'folder frame';
        contentWrapper.style.width = icon.windowWidth;
        contentWrapper.style.height = icon.windowHeight;
        this.contentWrapper = contentWrapper;
        this.shadowRoot.appendChild(contentWrapper);
        
        if (icon.folder)
        {
            // add icons to folder
            let X = iconGridSizeX/4;
            let Y = iconGridSizeX/4;
            const AddIcon=p=>
            {
                p.x = X;
                p.y = Y;
                X += iconGridSizeX;
                if (X > iconGridSizeX*7)
                {
                    // wrap icons
                    X = iconGridSizeX/4;
                    Y += iconGridSizeY;
                }
                contentWrapper.appendChild(new OS13kIcon(p));
            }
            for (const i of icon.folder)
                AddIcon(i);
            
            // set focus
            this.Focus();
        }
        else if (icon.src)
        {
            // create iframe
            const iframe = document.createElement('iframe');
            iframe.className = 'frame';
            iframe.sandbox.add('allow-scripts');
            iframe.sandbox.add('allow-same-origin');
            iframe.sandbox.add('allow-popups');
            iframe.sandbox.add('allow-modals');
            iframe.sandbox.add('allow-pointer-lock');
            iframe.style.display = 'none'
            iframe.src = icon.src;
            icon.background && (contentWrapper.style.background = icon.background);
            contentWrapper.appendChild(iframe);
        
            // load frame
            iframe.onload=e=>
            {
                // set up iframe            
                const iframeContent = this.iframeContent = e.target.contentWindow;
                const iframeDocument = iframeContent.document;
                iframeDocument.body.style = 'overflow:hidden';
                iframeContent.oncontextmenu=e=>e.preventDefault();
                iframe.style.display = '';

                // try to pass os13k to iframe
                iframeContent.OS13k = OS13k;
                iframeContent.zzfx = zzfx;
                iframeContent.OS13kStart && iframeContent.OS13kStart();

                // check for extensions
                const src = this.os13kIcon.src;
                const extension = src? src.split('.')[1] : '';
                if (extension == 'dweet' || extension == 'shader')
                {
                    // create full body canvas
                    const iframeText = iframeDocument.body.innerText;
                    iframeDocument.body.innerHTML = '<canvas id=c width=1920 height=1080 style=width:100%;background:#fff>';
                    iframeDocument.body.style = 'overflow:hidden;margin:0';
    
                    // create dweet
                    (extension == 'dweet') && iframeContent.eval(
                        'u=t=>{' + iframeText + '};' +
                        'x=c.getContext`2d`;' +
                        'S=Math.sin;' +
                        'C=Math.cos;' +
                        'T=Math.tan;' +
                        'R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;' +
                        'loop=t=>requestAnimationFrame(loop,' +
                        'document.hasFocus()&&' +
                        'u((60*(frame++/60)-frame-1|0?frame-1:frame)/60));' +
                        'loop(frame=0)');
                    
                    // create shader
                    (extension == 'shader') && iframeContent.eval(
                        'g=c.getContext`webgl2`;' +
                        'x=y=z=w=0;' +
                        'onmousemove=e=>e.buttons&&(x=e.x,y=c.height-e.y);' +
                        'onmousedown=e=>(z=e.x,w=c.height-e.y);' +
                        'onmouseup=e=>z=w=0;' +
                        'loop=t=>requestAnimationFrame(loop,' +
                        'c.width=innerWidth,' + 
                        'c.height=innerHeight,' + 
                        'g.uniform4f(g.getUniformLocation(s,`iMouse`),x,y,z,w),' +
                        'document.hasFocus()&&OS13k.RenderShader(c,s,t/1e3));' + 
                        'loop(s=OS13k.CreateShader(c,`' + iframeText + '`))');
                }
                
                // set focus
                this.Focus();
            };
        }
    }
    
    Close()
    {
        if (this.os13kIcon.hideWhenClosed)
        {
            // hide window so it can be reopened
            this.style.display = 'none';
        }
        else
        {
            // destroy window
            this.os13kIcon.os13kWindow = 0;
            this.remove();
        }
    }
    
    MouseDown(id)
    {
        // check for title bar buttons
        (id == 'close') && this.Close();
        (id == 'full') && this.FullScreen();
        (id == 'titleBar') && (selected = this);
            
        // set focus
        this.Focus();
    }
    
    FullScreen()
    {
        // set fullscreen
        const fullScreenElement = this.contentWrapper;
        if (fullScreenElement.webkitRequestFullScreen)
            fullScreenElement.webkitRequestFullScreen();
        else if (fullScreenElement.mozRequestFullScreen)
            fullScreenElement.mozRequestFullScreen();
    }
    
    SetActive(active=1)
    {
        if (active)
        {
            // move to top when active
            this.style.zIndex = ++activeWindowZ;
            
            // deactivate old window
            if (activeWindow && activeWindow != this)
                activeWindow.SetActive(0);
        }
        
        // change title color when active
        this.titleBar.style.background = active ? '#aac' : '#777';
        
        // set active
        activeWindow = active ? this : 0;
    }
    
    Focus()
    {
        // set focus
        this.iframeContent ? this.iframeContent.focus() : this.focus();
        this.SetActive();
    }
} // OS13kWindow

customElements.define('os13k-window', OS13kWindow);

/////////////////////////////////////////////////////////////////////////////
// Input

let selected;
let seletOffsetX;
let seletOffsetY;

onmousedown=e=>
{
    // prevent getting stuck
    if (selected)
        return onmouseup(e);
    
    // get os13k target
    const originalTarget = e.originalTarget || e.path[0];
    
    // if icon was clicked on, used that instead of target which may be a window
    const target = (originalTarget.localName == 'os13k-icon') ? originalTarget : e.target;
    
    // set selected offset
    const rect = target.getBoundingClientRect();
    seletOffsetX = e.x - rect.left;
    seletOffsetY = e.y - rect.top;
    
    if (target.MouseDown)
    {
        // target mouse down event
        target.MouseDown(originalTarget.id);
        
        // prevent main document getting refocused if title bar is clicked
        if (originalTarget.id == 'titleBar' || originalTarget.id == 'full')
            e.preventDefault();
    }
    else
    {
        // deactivate window if not clicked on
        os13kDesktop.Focus();
    }
    
    // prevent pointer events while dragging
    os13kDesktop.style.pointerEvents = 'none';
    selected && (document.body.style.cursor = 'grabbing');
}

onmouseup=e=>
{
    // allow pointer events and reset cursor
    os13kDesktop.style.pointerEvents = '';
    document.body.style.cursor = '';
    
    // selected mouse up event
    selected && selected.MouseUp && selected.MouseUp(e);
        
    // release selected
    selected = 0;
}

onmousemove=e=>
{
    // update selected position
    if (selected)
    {
        // clamp to window
        const x = OS13k.Clamp(e.x, 9, innerWidth-9);
        const y = OS13k.Clamp(e.y, 9, innerHeight-9);
        selected.style.left = x - seletOffsetX;
        selected.style.top = y - seletOffsetY;
    }
}

ondblclick=e=>
{
    // open icon
    const target = e.originalTarget || e.path[0];
    target.Open && target.Open();
}

// disable context menu
oncontextmenu=e=>e.preventDefault();

/////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth 

let zzfxV = .3; // volume
const zzfx =    // play zzfx sound
(
    volume = 1, 
    randomness = .05,
    frequency = 220,
    attack = 0,
    sustain = 0,
    release = .1,
    shape = 0,
    shapeCurve = 1,
    slide = 0, 
    deltaSlide = 0, 
    pitchJump = 0, 
    pitchJumpTime = 0, 
    repeatTime = 0, 
    noise = 0,
    modulation = 0,
    bitCrush = 0,
    delay = 0,

    // locals
    PI2 = Math.PI*2,
    sampleRate = 44100,
    random = r => r*2*Math.random()-r,
    sign = v => v>0?1:-1,
    startSlide = slide *= 500 * PI2 / sampleRate**2,
    startFrequency = frequency *= 
        (1 + random(randomness)) * PI2 / sampleRate,
    modPhase = sign(modulation) * PI2/4,
    b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, d=.5,
    length, buffer
) =>
{
    // init parameters
    attack = 99 + attack * sampleRate | 0;
    sustain = sustain * sampleRate | 0;
    release = release * sampleRate | 0;
    delay = delay * sampleRate | 0;
    deltaSlide *= 500 * PI2 / sampleRate**3;
    length = attack + sustain + release + delay;
    modulation *= PI2 / sampleRate;
    pitchJump *= PI2 / sampleRate;
    pitchJumpTime = pitchJumpTime * sampleRate;
    repeatTime = repeatTime * sampleRate;

    // generate waveform
    for(; i < length;b[i++] = s)
    {
        if (++c>bitCrush*100)                            // bit crush
        {
            c = 0;
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation - modPhase);    // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
              Math.sin((s%PI2)**3) :                     // 4 noise
              Math.max(Math.min(Math.tan(s),1),-1):      // 3 tan
              1-(2*s/PI2%2+2)%2:                         // 2 saw
              1-4*Math.abs(Math.round(s/PI2)-s/PI2):     // 1 triangle
              Math.sin(s);                               // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * zzfxV * (                      // envelope
                i<attack ? i/attack :                    // attack
                i<attack+sustain ? 1 :                   // sustain
                i<length-delay ?                         // post release
                1 - (i-attack-sustain)/release : 0);     // release
                
            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i-delay]/2) : s;
        }

        t += 1 + random(noise);             // noise
        tm += 1 + random(noise);            // modulation noise
        frequency += slide += deltaSlide;   // frequency slide

        if (j && ++j > pitchJumpTime)       // pitch jump
        {
            frequency += pitchJump;         // apply pitch jump
            startFrequency += pitchJump;    // also apply to start
            j = 0;                          // reset pitch jump time
        };

        if (repeatTime && ++r > repeatTime) // repeat
        {
            frequency = startFrequency;     // reset frequency
            slide = startSlide;             // reset slide
            r = 1;                          // reset repeat time
            j = j||1;                       // reset pitch jump time
        }
    }
    
    return OS13k.PlaySamples(b);
}

/////////////////////////////////////////////////////////////////////////////
// Start OS13k!

const OS13k = new _OS13k;

</script>